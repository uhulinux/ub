diff -Naur orig/libintend/libparser/icl_grammar.c patched/libintend/libparser/icl_grammar.c
--- orig/libintend/libparser/icl_grammar.c	1970-01-01 01:00:00.000000000 +0100
+++ patched/libintend/libparser/icl_grammar.c	2013-10-20 23:31:47.000000000 +0200
@@ -0,0 +1,3940 @@
+/* A Bison parser, made by GNU Bison 2.4.2.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2006, 2009-2010 Free Software
+   Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 1
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         icl_parse
+#define yylex           icl_lex
+#define yyerror         icl_error
+#define yylval          icl_lval
+#define yychar          icl_char
+#define yydebug         icl_debug
+#define yynerrs         icl_nerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/* Line 189 of yacc.c  */
+#line 80 "icl_grammar.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 1
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     CONST_BOOL = 258,
+     CONST_INT = 259,
+     CONST_FLOAT = 260,
+     CONST_STRING = 261,
+     KW_INC = 262,
+     KW_USE = 263,
+     KW_IF = 264,
+     KW_ELSE = 265,
+     KW_WHILE = 266,
+     KW_DO = 267,
+     KW_RETURN = 268,
+     KW_FOR = 269,
+     KW_CONTINUE = 270,
+     KW_BREAK = 271,
+     KW_SWITCH = 272,
+     KW_CASE = 273,
+     KW_DEFAULT = 274,
+     KW_FORCE = 275,
+     KW_TRY = 276,
+     KW_THROW = 277,
+     KW_CATCH = 278,
+     KW_CLASS = 279,
+     KW_EXTENDS = 280,
+     KW_NEW = 281,
+     KW_STATIC = 282,
+     KW_FILE = 283,
+     KW_LINE = 284,
+     KW_NULL = 285,
+     TYPE_VOID = 286,
+     TYPE_BOOL = 287,
+     TYPE_INT = 288,
+     TYPE_FLOAT = 289,
+     TYPE_STRING = 290,
+     TYPE_ARRAY = 291,
+     TYPE_STRUCT = 292,
+     TYPE_FN = 293,
+     TYPE_RES = 294,
+     TYPE_MIXED = 295,
+     OP_ARSHIFT = 296,
+     OP_ALSHIFT = 297,
+     OP_AXOR = 298,
+     OP_AOR = 299,
+     OP_AAND = 300,
+     OP_ADIV = 301,
+     OP_AMUL = 302,
+     OP_AMINUS = 303,
+     OP_APLUS = 304,
+     OP_ASSIGN = 305,
+     OP_BOOL_OR = 306,
+     OP_BOOL_AND = 307,
+     OP_NOT = 308,
+     OP_LARGER = 309,
+     OP_SMALLER = 310,
+     OP_LEQ = 311,
+     OP_SEQ = 312,
+     OP_NOT_EQUAL = 313,
+     OP_EQUAL = 314,
+     OP_XOR = 315,
+     OP_OR = 316,
+     OP_AND = 317,
+     OP_MINUS = 318,
+     OP_PLUS = 319,
+     OP_MOD = 320,
+     OP_DIV = 321,
+     OP_MUL = 322,
+     OP_POW = 323,
+     OP_RSHIFT = 324,
+     OP_LSHIFT = 325,
+     OP_NEG = 326,
+     UNARY_MINUS = 327,
+     OP_MINUSMINUS = 328,
+     OP_PLUSPLUS = 329,
+     CAST_STRUCT = 330,
+     CAST_ARRAY = 331,
+     CAST_STRING = 332,
+     CAST_FLOAT = 333,
+     CAST_UINT = 334,
+     CAST_INT = 335,
+     CAST_BOOL = 336,
+     CAST_VOID = 337,
+     ID = 338
+   };
+#endif
+/* Tokens.  */
+#define CONST_BOOL 258
+#define CONST_INT 259
+#define CONST_FLOAT 260
+#define CONST_STRING 261
+#define KW_INC 262
+#define KW_USE 263
+#define KW_IF 264
+#define KW_ELSE 265
+#define KW_WHILE 266
+#define KW_DO 267
+#define KW_RETURN 268
+#define KW_FOR 269
+#define KW_CONTINUE 270
+#define KW_BREAK 271
+#define KW_SWITCH 272
+#define KW_CASE 273
+#define KW_DEFAULT 274
+#define KW_FORCE 275
+#define KW_TRY 276
+#define KW_THROW 277
+#define KW_CATCH 278
+#define KW_CLASS 279
+#define KW_EXTENDS 280
+#define KW_NEW 281
+#define KW_STATIC 282
+#define KW_FILE 283
+#define KW_LINE 284
+#define KW_NULL 285
+#define TYPE_VOID 286
+#define TYPE_BOOL 287
+#define TYPE_INT 288
+#define TYPE_FLOAT 289
+#define TYPE_STRING 290
+#define TYPE_ARRAY 291
+#define TYPE_STRUCT 292
+#define TYPE_FN 293
+#define TYPE_RES 294
+#define TYPE_MIXED 295
+#define OP_ARSHIFT 296
+#define OP_ALSHIFT 297
+#define OP_AXOR 298
+#define OP_AOR 299
+#define OP_AAND 300
+#define OP_ADIV 301
+#define OP_AMUL 302
+#define OP_AMINUS 303
+#define OP_APLUS 304
+#define OP_ASSIGN 305
+#define OP_BOOL_OR 306
+#define OP_BOOL_AND 307
+#define OP_NOT 308
+#define OP_LARGER 309
+#define OP_SMALLER 310
+#define OP_LEQ 311
+#define OP_SEQ 312
+#define OP_NOT_EQUAL 313
+#define OP_EQUAL 314
+#define OP_XOR 315
+#define OP_OR 316
+#define OP_AND 317
+#define OP_MINUS 318
+#define OP_PLUS 319
+#define OP_MOD 320
+#define OP_DIV 321
+#define OP_MUL 322
+#define OP_POW 323
+#define OP_RSHIFT 324
+#define OP_LSHIFT 325
+#define OP_NEG 326
+#define UNARY_MINUS 327
+#define OP_MINUSMINUS 328
+#define OP_PLUSPLUS 329
+#define CAST_STRUCT 330
+#define CAST_ARRAY 331
+#define CAST_STRING 332
+#define CAST_FLOAT 333
+#define CAST_UINT 334
+#define CAST_INT 335
+#define CAST_BOOL 336
+#define CAST_VOID 337
+#define ID 338
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 67 "icl_grammar.y"
+
+    char *string;
+    int unused;
+
+
+
+/* Line 214 of yacc.c  */
+#line 289 "icl_grammar.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+/* Line 264 of yacc.c  */
+#line 130 "icl_grammar.y"
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "parser.h"
+
+/*
+ * Print parser error message
+ */
+void icl_error(intend_state *state, char *msg)
+{
+    parser_data *p = (parser_data *)state->parser;
+
+    fatal(state, msg);
+    p->parser_error++;
+}
+
+/*
+ * Constant to translate the state to scanner context
+ * before calling lex
+ */
+#define scanner ((parser_data *)state->parser)->scanner
+
+
+
+/* Line 264 of yacc.c  */
+#line 329 "icl_grammar.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  116
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   1672
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  96
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  64
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  235
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  416
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   338
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      89,    90,     2,     2,    95,     2,    93,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    52,    86,
+       2,     2,     2,    51,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    91,    94,    92,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    87,     2,    88,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    53,    54,    55,    56,
+      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
+      67,    68,    69,    70,    71,    72,    73,    74,    75,    76,
+      77,    78,    79,    80,    81,    82,    83,    84,    85
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     4,     6,     8,    11,    13,    15,    17,
+      19,    22,    25,    29,    31,    32,    37,    40,    42,    43,
+      51,    52,    59,    60,    68,    69,    80,    81,    90,    91,
+     100,   101,   104,   105,   108,   109,   113,   118,   122,   129,
+     133,   136,   138,   139,   141,   143,   145,   147,   150,   153,
+     155,   157,   159,   162,   164,   166,   168,   170,   172,   174,
+     176,   182,   184,   186,   190,   192,   194,   196,   198,   200,
+     202,   204,   207,   211,   214,   219,   225,   226,   235,   238,
+     240,   244,   246,   250,   255,   260,   266,   271,   277,   279,
+     283,   285,   289,   294,   300,   302,   306,   308,   309,   314,
+     320,   327,   334,   335,   344,   350,   351,   359,   361,   364,
+     368,   372,   375,   380,   384,   388,   392,   396,   400,   404,
+     408,   412,   416,   420,   424,   429,   434,   439,   444,   449,
+     454,   459,   464,   469,   474,   477,   480,   483,   486,   489,
+     493,   497,   501,   505,   509,   513,   517,   521,   525,   529,
+     533,   537,   541,   545,   549,   553,   557,   561,   565,   568,
+     571,   573,   577,   580,   582,   584,   586,   588,   590,   592,
+     595,   597,   600,   603,   606,   609,   612,   615,   618,   621,
+     624,   625,   633,   635,   637,   639,   641,   643,   645,   647,
+     649,   651,   653,   656,   659,   662,   665,   668,   671,   674,
+     677,   680,   683,   685,   689,   690,   693,   696,   699,   702,
+     705,   708,   711,   714,   717,   720,   724,   728,   732,   736,
+     740,   744,   748,   752,   756,   760,   762,   763,   771,   774,
+     777,   778,   780,   783,   785,   788
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+      97,     0,    -1,    -1,    98,    -1,    99,    -1,    98,    99,
+      -1,   150,    -1,   155,    -1,   101,    -1,   101,    -1,   100,
+     101,    -1,   116,    86,    -1,     7,     6,    86,    -1,   103,
+      -1,    -1,    87,   102,   100,    88,    -1,    87,    88,    -1,
+      86,    -1,    -1,     9,   104,    89,   117,    90,   101,   110,
+      -1,    -1,    11,   105,    89,   117,    90,   101,    -1,    -1,
+      12,   106,   101,    11,    89,   117,    90,    -1,    -1,    14,
+     107,    89,   115,    86,   115,    86,   115,    90,   101,    -1,
+      -1,    17,   108,    89,   117,    90,    87,   111,    88,    -1,
+      -1,    21,   109,   101,    23,    89,    85,    90,   101,    -1,
+      -1,    10,   101,    -1,    -1,   112,   114,    -1,    -1,   111,
+     113,   114,    -1,    18,   117,    52,   100,    -1,    18,   117,
+      52,    -1,    18,   117,    52,   100,    16,    86,    -1,    19,
+      52,   100,    -1,    19,    52,    -1,   117,    -1,    -1,   117,
+      -1,    15,    -1,    16,    -1,    13,    -1,    13,   117,    -1,
+      22,   117,    -1,   139,    -1,   123,    -1,   118,    -1,   118,
+     119,    -1,   149,    -1,   147,    -1,   143,    -1,   144,    -1,
+     142,    -1,   141,    -1,   121,    -1,   117,    51,   117,    52,
+     117,    -1,    28,    -1,    29,    -1,    89,   117,    90,    -1,
+     126,    -1,   128,    -1,   131,    -1,   127,    -1,   135,    -1,
+     136,    -1,   120,    -1,   119,   120,    -1,    91,   117,    92,
+      -1,    93,    85,    -1,    93,    85,    89,    90,    -1,    93,
+      85,    89,   145,    90,    -1,    -1,    94,   122,    89,   153,
+      90,    87,   100,    88,    -1,     8,   124,    -1,   125,    -1,
+     124,    95,   125,    -1,    85,    -1,    85,    89,    90,    -1,
+      85,    89,   145,    90,    -1,    26,    85,    89,    90,    -1,
+      26,    85,    89,   145,    90,    -1,    26,    36,    89,    90,
+      -1,    26,    36,    89,   129,    90,    -1,   130,    -1,   129,
+      95,   130,    -1,   117,    -1,   117,    50,   117,    -1,    26,
+      37,    89,    90,    -1,    26,    37,    89,   132,    90,    -1,
+     133,    -1,   132,    95,   133,    -1,    85,    -1,    -1,    85,
+     134,    50,   117,    -1,    85,    27,    85,    89,    90,    -1,
+      85,    27,    85,    89,   145,    90,    -1,    85,   140,    93,
+      85,    89,    90,    -1,    -1,    85,   140,    93,    85,    89,
+     137,   145,    90,    -1,    85,    93,    85,    89,    90,    -1,
+      -1,    85,    93,    85,    89,   138,   145,    90,    -1,    85,
+      -1,    85,   140,    -1,    85,    27,    85,    -1,    91,   117,
+      92,    -1,    93,    85,    -1,   140,    91,   117,    92,    -1,
+     140,    93,    85,    -1,    85,    50,   117,    -1,    85,    49,
+     117,    -1,    85,    48,   117,    -1,    85,    47,   117,    -1,
+      85,    46,   117,    -1,    85,    45,   117,    -1,    85,    44,
+     117,    -1,    85,    43,   117,    -1,    85,    42,   117,    -1,
+      85,    41,   117,    -1,    85,   140,    50,   117,    -1,    85,
+     140,    49,   117,    -1,    85,   140,    48,   117,    -1,    85,
+     140,    47,   117,    -1,    85,   140,    46,   117,    -1,    85,
+     140,    45,   117,    -1,    85,   140,    44,   117,    -1,    85,
+     140,    43,   117,    -1,    85,   140,    42,   117,    -1,    85,
+     140,    41,   117,    -1,    55,   117,    -1,    65,   117,    -1,
+      76,   117,    -1,    75,   117,    -1,    73,   117,    -1,   117,
+      66,   117,    -1,   117,    65,   117,    -1,   117,    69,   117,
+      -1,   117,    68,   117,    -1,   117,    67,   117,    -1,   117,
+      70,   117,    -1,   117,    54,   117,    -1,   117,    53,   117,
+      -1,   117,    64,   117,    -1,   117,    63,   117,    -1,   117,
+      62,   117,    -1,   117,    72,   117,    -1,   117,    71,   117,
+      -1,   117,    61,   117,    -1,   117,    60,   117,    -1,   117,
+      59,   117,    -1,   117,    58,   117,    -1,   117,    57,   117,
+      -1,   117,    56,   117,    -1,   117,    76,    -1,   117,    75,
+      -1,   146,    -1,   145,    95,   146,    -1,    64,   117,    -1,
+     117,    -1,     3,    -1,     4,    -1,     5,    -1,   148,    -1,
+      30,    -1,    89,    90,    -1,     6,    -1,   148,     6,    -1,
+      84,   117,    -1,    83,   117,    -1,    82,   117,    -1,    81,
+     117,    -1,    80,   117,    -1,    79,   117,    -1,    78,   117,
+      -1,    77,   117,    -1,    -1,   151,   152,    85,    89,   153,
+      90,   101,    -1,    31,    -1,    32,    -1,    33,    -1,    34,
+      -1,    35,    -1,    36,    -1,    37,    -1,    38,    -1,    39,
+      -1,    40,    -1,    20,    31,    -1,    20,    32,    -1,    20,
+      33,    -1,    20,    34,    -1,    20,    35,    -1,    20,    36,
+      -1,    20,    37,    -1,    20,    38,    -1,    20,    39,    -1,
+      20,    40,    -1,   154,    -1,   153,    95,   154,    -1,    -1,
+      31,    85,    -1,    32,    85,    -1,    33,    85,    -1,    34,
+      85,    -1,    35,    85,    -1,    36,    85,    -1,    37,    85,
+      -1,    38,    85,    -1,    39,    85,    -1,    40,    85,    -1,
+      20,    31,    85,    -1,    20,    32,    85,    -1,    20,    33,
+      85,    -1,    20,    34,    85,    -1,    20,    35,    85,    -1,
+      20,    36,    85,    -1,    20,    37,    85,    -1,    20,    38,
+      85,    -1,    20,    39,    85,    -1,    20,    40,    85,    -1,
+      85,    -1,    -1,    24,   156,    85,   157,    87,   158,    88,
+      -1,    25,    85,    -1,    52,    85,    -1,    -1,   159,    -1,
+     158,   159,    -1,   150,    -1,    85,    86,    -1,    85,    50,
+     117,    86,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   159,   159,   160,   163,   164,   167,   168,   169,   172,
+     173,   176,   177,   178,   179,   179,   180,   181,   184,   184,
+     185,   185,   186,   186,   187,   187,   188,   188,   189,   189,
+     192,   193,   196,   196,   197,   197,   200,   201,   202,   203,
+     204,   207,   208,   211,   212,   213,   214,   215,   216,   219,
+     220,   221,   222,   223,   224,   225,   226,   227,   228,   229,
+     230,   231,   232,   235,   236,   237,   238,   239,   240,   241,
+     244,   245,   248,   249,   250,   251,   254,   254,   257,   260,
+     261,   264,   267,   268,   271,   272,   275,   276,   279,   280,
+     283,   284,   287,   288,   291,   292,   295,   296,   296,   299,
+     300,   303,   304,   304,   305,   306,   306,   309,   310,   311,
+     314,   315,   316,   317,   320,   321,   322,   323,   324,   325,
+     326,   327,   328,   329,   330,   331,   332,   333,   334,   335,
+     336,   337,   338,   339,   342,   343,   344,   345,   346,   349,
+     350,   351,   352,   353,   354,   355,   356,   357,   358,   359,
+     360,   361,   362,   363,   364,   365,   366,   367,   370,   371,
+     374,   375,   378,   379,   382,   383,   384,   385,   386,   387,
+     390,   391,   394,   395,   396,   397,   398,   399,   400,   401,
+     404,   404,   407,   408,   409,   410,   411,   412,   413,   414,
+     415,   416,   417,   418,   419,   420,   421,   422,   423,   424,
+     425,   426,   429,   430,   431,   434,   435,   436,   437,   438,
+     439,   440,   441,   442,   443,   444,   445,   446,   447,   448,
+     449,   450,   451,   452,   453,   454,   457,   457,   460,   461,
+     462,   465,   466,   469,   470,   471
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "CONST_BOOL", "CONST_INT", "CONST_FLOAT",
+  "CONST_STRING", "KW_INC", "KW_USE", "KW_IF", "KW_ELSE", "KW_WHILE",
+  "KW_DO", "KW_RETURN", "KW_FOR", "KW_CONTINUE", "KW_BREAK", "KW_SWITCH",
+  "KW_CASE", "KW_DEFAULT", "KW_FORCE", "KW_TRY", "KW_THROW", "KW_CATCH",
+  "KW_CLASS", "KW_EXTENDS", "KW_NEW", "KW_STATIC", "KW_FILE", "KW_LINE",
+  "KW_NULL", "TYPE_VOID", "TYPE_BOOL", "TYPE_INT", "TYPE_FLOAT",
+  "TYPE_STRING", "TYPE_ARRAY", "TYPE_STRUCT", "TYPE_FN", "TYPE_RES",
+  "TYPE_MIXED", "OP_ARSHIFT", "OP_ALSHIFT", "OP_AXOR", "OP_AOR", "OP_AAND",
+  "OP_ADIV", "OP_AMUL", "OP_AMINUS", "OP_APLUS", "OP_ASSIGN", "'?'", "':'",
+  "OP_BOOL_OR", "OP_BOOL_AND", "OP_NOT", "OP_LARGER", "OP_SMALLER",
+  "OP_LEQ", "OP_SEQ", "OP_NOT_EQUAL", "OP_EQUAL", "OP_XOR", "OP_OR",
+  "OP_AND", "OP_MINUS", "OP_PLUS", "OP_MOD", "OP_DIV", "OP_MUL", "OP_POW",
+  "OP_RSHIFT", "OP_LSHIFT", "OP_NEG", "UNARY_MINUS", "OP_MINUSMINUS",
+  "OP_PLUSPLUS", "CAST_STRUCT", "CAST_ARRAY", "CAST_STRING", "CAST_FLOAT",
+  "CAST_UINT", "CAST_INT", "CAST_BOOL", "CAST_VOID", "ID", "';'", "'{'",
+  "'}'", "'('", "')'", "'['", "']'", "'.'", "'\\\\'", "','", "$accept",
+  "program", "fstatements", "fblock", "statements", "block", "$@1",
+  "control", "$@2", "$@3", "$@4", "$@5", "$@6", "$@7", "else", "cases",
+  "$@8", "$@9", "case", "nullexpr", "statement", "expr", "indexable",
+  "indexes", "index", "lambda", "$@10", "moduse", "modlist", "modid",
+  "call", "cons", "arrinit", "arrlist", "arrarg", "structinit",
+  "structlist", "structarg", "$@11", "static", "method", "$@12", "$@13",
+  "ref", "refexp", "assign", "prefix", "infix", "postfix", "arglist",
+  "argexpr", "const", "conststring", "cast", "fundef", "$@14", "rettype",
+  "argdefs", "argdef", "classdef", "$@15", "extends", "classdecls",
+  "classdecl", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,    63,    58,   306,   307,   308,   309,   310,   311,   312,
+     313,   314,   315,   316,   317,   318,   319,   320,   321,   322,
+     323,   324,   325,   326,   327,   328,   329,   330,   331,   332,
+     333,   334,   335,   336,   337,   338,    59,   123,   125,    40,
+      41,    91,    93,    46,    92,    44
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    96,    97,    97,    98,    98,    99,    99,    99,   100,
+     100,   101,   101,   101,   102,   101,   101,   101,   104,   103,
+     105,   103,   106,   103,   107,   103,   108,   103,   109,   103,
+     110,   110,   112,   111,   113,   111,   114,   114,   114,   114,
+     114,   115,   115,   116,   116,   116,   116,   116,   116,   117,
+     117,   117,   117,   117,   117,   117,   117,   117,   117,   117,
+     117,   117,   117,   118,   118,   118,   118,   118,   118,   118,
+     119,   119,   120,   120,   120,   120,   122,   121,   123,   124,
+     124,   125,   126,   126,   127,   127,   128,   128,   129,   129,
+     130,   130,   131,   131,   132,   132,   133,   134,   133,   135,
+     135,   136,   137,   136,   136,   138,   136,   139,   139,   139,
+     140,   140,   140,   140,   141,   141,   141,   141,   141,   141,
+     141,   141,   141,   141,   141,   141,   141,   141,   141,   141,
+     141,   141,   141,   141,   142,   142,   142,   142,   142,   143,
+     143,   143,   143,   143,   143,   143,   143,   143,   143,   143,
+     143,   143,   143,   143,   143,   143,   143,   143,   144,   144,
+     145,   145,   146,   146,   147,   147,   147,   147,   147,   147,
+     148,   148,   149,   149,   149,   149,   149,   149,   149,   149,
+     151,   150,   152,   152,   152,   152,   152,   152,   152,   152,
+     152,   152,   152,   152,   152,   152,   152,   152,   152,   152,
+     152,   152,   153,   153,   153,   154,   154,   154,   154,   154,
+     154,   154,   154,   154,   154,   154,   154,   154,   154,   154,
+     154,   154,   154,   154,   154,   154,   156,   155,   157,   157,
+     157,   158,   158,   159,   159,   159
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     1,     1,     2,     1,     1,     1,     1,
+       2,     2,     3,     1,     0,     4,     2,     1,     0,     7,
+       0,     6,     0,     7,     0,    10,     0,     8,     0,     8,
+       0,     2,     0,     2,     0,     3,     4,     3,     6,     3,
+       2,     1,     0,     1,     1,     1,     1,     2,     2,     1,
+       1,     1,     2,     1,     1,     1,     1,     1,     1,     1,
+       5,     1,     1,     3,     1,     1,     1,     1,     1,     1,
+       1,     2,     3,     2,     4,     5,     0,     8,     2,     1,
+       3,     1,     3,     4,     4,     5,     4,     5,     1,     3,
+       1,     3,     4,     5,     1,     3,     1,     0,     4,     5,
+       6,     6,     0,     8,     5,     0,     7,     1,     2,     3,
+       3,     2,     4,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     4,     4,     4,     4,     4,     4,
+       4,     4,     4,     4,     2,     2,     2,     2,     2,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     2,     2,
+       1,     3,     2,     1,     1,     1,     1,     1,     1,     2,
+       1,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       0,     7,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     1,     3,     0,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     1,     0,     7,     2,     2,
+       0,     1,     2,     1,     2,     4
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+     180,   164,   165,   166,   170,     0,     0,    18,    20,    22,
+      46,    24,    44,    45,    26,    28,     0,   226,     0,    61,
+      62,   168,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   107,    17,    14,     0,    76,
+       0,   180,     4,     8,    13,     0,    43,    51,    59,    50,
+      64,    67,    65,    66,    68,    69,    49,    58,    57,    55,
+      56,    54,   167,    53,     6,     0,     7,     0,    81,    78,
+      79,     0,     0,     0,    47,     0,     0,     0,    48,     0,
+       0,     0,     0,   134,   135,   138,   137,   136,   179,   178,
+     177,   176,   175,   174,   173,   172,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     108,    16,     0,   169,     0,     0,     1,     5,    11,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   159,
+     158,     0,     0,    52,    70,   171,     0,   182,   183,   184,
+     185,   186,   187,   188,   189,   190,   191,     0,    12,     0,
+       0,     0,     0,    42,     0,     0,   230,     0,     0,     0,
+     109,   123,   122,   121,   120,   119,   118,   117,   116,   115,
+     114,     0,    82,   163,     0,   160,     0,   111,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     9,    63,   204,     0,   146,   145,   157,   156,   155,
+     154,   153,   152,   149,   148,   147,   140,   139,   143,   142,
+     141,   144,   151,   150,     0,    73,    71,   192,   193,   194,
+     195,   196,   197,   198,   199,   200,   201,     0,    80,     0,
+       0,     0,     0,    41,     0,     0,     0,     0,     0,    86,
+      90,     0,    88,    96,    92,     0,    94,    84,     0,     0,
+     162,    83,     0,   110,   105,   133,   132,   131,   130,   129,
+     128,   127,   126,   125,   124,     0,   113,    15,    10,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     225,     0,   202,     0,    72,     0,   204,     0,     0,     0,
+      42,     0,     0,   228,   229,   180,     0,    87,     0,     0,
+      93,     0,    85,    99,     0,   161,   104,     0,   112,   102,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     205,   206,   207,   208,   209,   210,   211,   212,   213,   214,
+       0,     0,    60,    74,     0,     0,    30,    21,     0,     0,
+      32,     0,     0,   233,   180,   231,    91,    89,     0,    95,
+     100,     0,   101,     0,   215,   216,   217,   218,   219,   220,
+     221,   222,   223,   224,     0,   203,    75,     0,     0,    19,
+      23,    42,    34,     0,     0,     0,   234,   227,   232,    98,
+     106,     0,     0,   181,    31,     0,    27,     0,     0,     0,
+      33,    29,     0,   103,    77,     0,    35,     0,    40,   235,
+      25,    37,    39,    36,     0,    38
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,    40,    41,    42,   200,   201,   112,    44,    71,    72,
+      73,    75,    76,    77,   379,   382,   383,   397,   400,   242,
+      45,    46,    47,   143,   144,    48,   115,    49,    69,    70,
+      50,    51,    52,   251,   252,    53,   255,   256,   309,    54,
+      55,   363,   317,    56,   110,    57,    58,    59,    60,   184,
+     185,    61,    62,    63,    64,    65,   157,   291,   292,    66,
+      79,   248,   354,   355
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -369
+static const yytype_int16 yypact[] =
+{
+     255,  -369,  -369,  -369,  -369,     6,   -69,  -369,  -369,  -369,
+    1181,  -369,  -369,  -369,  -369,  -369,  1181,  -369,   -34,  -369,
+    -369,  -369,  1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,
+    1181,  1181,  1181,  1181,  1181,    15,  -369,   -50,  1027,  -369,
+      46,   411,  -369,  -369,  -369,   -38,  1504,   -54,  -369,  -369,
+    -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,
+    -369,  -369,    49,  -369,  -369,   328,  -369,    23,  -369,   -23,
+    -369,    21,    22,   687,  1504,    24,    48,   687,  1504,    50,
+      51,    57,    59,  1575,    12,    12,  -369,  -369,  -369,  -369,
+    -369,  -369,  -369,  -369,  -369,  -369,    53,  1181,  1181,  1181,
+    1181,  1181,  1181,  1181,  1181,  1181,  1181,   139,  1181,    64,
+     353,  -369,   687,  -369,  1220,    61,  -369,  -369,  -369,  1181,
+    1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,
+    1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,  -369,
+    -369,  1181,    66,   -54,  -369,  -369,   882,  -369,  -369,  -369,
+    -369,  -369,  -369,  -369,  -369,  -369,  -369,    67,  -369,   -69,
+    1181,  1181,   142,  1181,  1181,   131,   -18,  1058,   -76,   812,
+      68,  1504,  1504,  1504,  1504,  1504,  1504,  1504,  1504,  1504,
+    1504,  1181,  -369,  1504,   -45,  -369,   485,    72,  1181,  1181,
+    1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,  1181,    75,
+     503,  -369,  -369,   206,  1452,  1554,   393,  1596,  1596,  1596,
+    1596,  1596,  1596,   756,   756,   756,    -1,    -1,   -40,   -40,
+     -40,   -40,    12,    12,   577,    77,  -369,  -369,  -369,  -369,
+    -369,  -369,  -369,  -369,  -369,  -369,  -369,    81,  -369,  1255,
+    1290,    82,    86,  1504,  1325,    84,    89,    90,    91,  -369,
+    1426,   -43,  -369,   127,  -369,   -41,  -369,  -369,   -14,   904,
+    1504,  -369,  1150,  -369,    92,  1504,  1504,  1504,  1504,  1504,
+    1504,  1504,  1504,  1504,  1504,   669,   106,  -369,  -369,   913,
+      94,    95,    96,   111,   112,   113,   114,   116,   117,   120,
+    -369,   -12,  -369,  1181,  -369,   935,   206,   687,   687,  1181,
+    1181,   119,   122,  -369,  -369,   123,  1181,  -369,  1181,   160,
+    -369,   126,  -369,  -369,   -11,  -369,  -369,  1150,  -369,   135,
+     128,   145,   146,   147,   149,   150,   151,   162,   163,   164,
+    -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,
+     140,   206,  1530,  -369,   -10,    -4,   240,  -369,  1360,   165,
+    -369,   166,   -42,  -369,   -75,  -369,  1504,  -369,  1181,  -369,
+    -369,    17,  -369,  1150,  -369,  -369,  -369,  -369,  -369,  -369,
+    -369,  -369,  -369,  -369,   687,  -369,  -369,   687,   687,  -369,
+    -369,  1181,   177,    71,   687,  1181,  -369,  -369,  -369,  1504,
+    -369,    44,   595,  -369,  -369,   183,  -369,    71,  1181,   200,
+    -369,  -369,  1395,  -369,  -369,   687,  -369,  1478,   687,  -369,
+    -369,   687,   687,   779,   167,  -369
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -369,  -369,  -369,   233,  -368,     0,  -369,  -369,  -369,  -369,
+    -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -122,  -299,
+    -369,    -5,  -369,  -369,   137,  -369,  -369,  -369,  -369,   130,
+    -369,  -369,  -369,  -369,   -30,  -369,  -369,   -29,  -369,  -369,
+    -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -369,  -154,
+      25,  -369,  -369,  -369,  -301,  -369,  -369,    -3,   -55,  -369,
+    -369,  -369,  -369,   -62
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -98
+static const yytype_int16 yytable[] =
+{
+      43,   349,    80,    81,   353,    74,   392,   246,   385,   253,
+     352,    78,    67,   387,   254,   258,    68,    83,    84,    85,
+      86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
+     136,   137,   138,   114,   247,   139,   140,   141,   111,   142,
+     412,    43,    96,   413,   386,   261,   116,   307,   118,   310,
+     262,    82,   308,   353,   311,   145,    97,    98,    99,   100,
+     101,   102,   103,   104,   105,   106,   133,   134,   135,   136,
+     137,   138,   159,   162,   139,   140,   312,   165,   340,   360,
+     376,   262,   395,   341,   262,   262,   377,   139,   140,   398,
+     399,   341,   171,   172,   173,   174,   175,   176,   177,   178,
+     179,   180,   183,   186,   107,   314,   108,   390,   109,   158,
+     160,   161,   262,   163,   204,   205,   206,   207,   208,   209,
+     210,   211,   212,   213,   214,   215,   216,   217,   218,   219,
+     220,   221,   222,   223,   403,   166,   224,   164,   170,   262,
+     167,   344,     1,     2,     3,     4,   168,     6,   169,   187,
+     203,   225,   237,   241,   245,   239,   240,   259,   243,   244,
+     276,   264,   250,   361,   183,    18,   295,    19,    20,    21,
+     296,   299,   300,   302,   303,   304,   260,   -97,   305,   330,
+     331,   332,   316,   265,   266,   267,   268,   269,   270,   271,
+     272,   273,   274,   275,    22,   319,   333,   334,   335,   336,
+     278,   337,   338,   181,    23,   339,   350,   351,   352,   391,
+     358,   253,    24,   364,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    35,   362,   279,   374,    38,   182,
+     365,   366,   367,    39,   368,   369,   370,   280,   281,   282,
+     283,   284,   285,   286,   287,   288,   289,   371,   372,   373,
+     378,   381,   408,   415,   183,    -2,   384,   183,     1,     2,
+       3,     4,     5,     6,     7,   396,     8,     9,    10,    11,
+      12,    13,    14,   405,   117,   406,    15,    16,   357,    17,
+     226,    18,   359,    19,    20,    21,   375,   315,   342,   238,
+     183,   290,   388,   345,   348,   243,     0,   346,   347,     0,
+       0,   356,     0,   250,     0,     0,     0,     0,     0,     0,
+      22,     0,   183,     0,     0,     0,     0,     0,     0,     0,
+      23,     0,     0,     0,     0,     0,     0,     0,    24,     0,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,     0,    38,     0,     0,     0,   146,    39,
+       0,     0,     0,   389,     0,     0,     0,     0,   183,   147,
+     148,   149,   150,   151,   152,   153,   154,   155,   156,     0,
+       0,     0,     0,     0,     0,     0,   243,   393,   394,     0,
+     402,     0,     0,     0,   401,     0,     0,     0,     0,     0,
+       0,     0,   278,   407,   188,   189,   190,   191,   192,   193,
+     194,   195,   196,   197,     0,   410,     0,     0,     0,     0,
+       0,    -3,   278,   278,     1,     2,     3,     4,     5,     6,
+       7,     0,     8,     9,    10,    11,    12,    13,    14,     0,
+       0,     0,    15,    16,     0,    17,     0,    18,     0,    19,
+      20,    21,     0,     0,   198,     0,   199,   121,     0,   122,
+     123,   124,   125,   126,   127,   128,   129,   130,   131,   132,
+     133,   134,   135,   136,   137,   138,    22,     0,   139,   140,
+       0,     0,     0,     0,     0,     0,    23,     0,     0,     0,
+       0,     0,     0,     0,    24,     0,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    35,    36,    37,     0,
+      38,     0,     0,     0,     0,    39,     1,     2,     3,     4,
+       5,     6,     7,     0,     8,     9,    10,    11,    12,    13,
+      14,     0,     0,     0,    15,    16,     0,     0,     0,    18,
+       0,    19,    20,    21,     0,     0,   119,     0,   120,   121,
+       0,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,    22,     0,
+     139,   140,     0,     0,     0,     0,     0,     0,    23,     0,
+       0,     0,     0,     0,     0,     0,    24,   263,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
+      37,   277,    38,     0,     0,     0,     0,    39,     1,     2,
+       3,     4,     5,     6,     7,     0,     8,     9,    10,    11,
+      12,    13,    14,     0,     0,     0,    15,    16,     0,     0,
+       0,    18,     0,    19,    20,    21,     0,     0,   119,     0,
+     120,   121,     0,   122,   123,   124,   125,   126,   127,   128,
+     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
+      22,     0,   139,   140,     0,     0,     0,     0,     0,     0,
+      23,     0,     0,     0,     0,     0,     0,     0,    24,   294,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,   404,    38,     0,     0,     0,     0,    39,
+       1,     2,     3,     4,     5,     6,     7,     0,     8,     9,
+      10,    11,    12,    13,    14,     0,     0,     0,    15,    16,
+       0,     0,     0,    18,     0,    19,    20,    21,     0,     0,
+     119,     0,   120,   121,     0,   122,   123,   124,   125,   126,
+     127,   128,   129,   130,   131,   132,   133,   134,   135,   136,
+     137,   138,    22,     0,   139,   140,     0,     0,     0,     0,
+       0,     0,    23,     0,     0,     0,     0,     0,     0,     0,
+      24,   318,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    35,    36,    37,     0,    38,     0,     0,     0,
+       0,    39,     1,     2,     3,     4,     5,     6,     7,     0,
+       8,     9,    10,    11,    12,   414,    14,     0,     0,     0,
+      15,    16,     0,     0,     0,    18,     0,    19,    20,    21,
+       0,     0,     0,     0,     0,     1,     2,     3,     4,     0,
+       6,   131,   132,   133,   134,   135,   136,   137,   138,     0,
+       0,   139,   140,     0,    22,     0,     0,     0,    18,     0,
+      19,    20,    21,     0,    23,     0,     0,     0,     0,     0,
+       0,     0,    24,     0,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    34,    35,    36,    37,    22,    38,     0,
+       0,     0,     0,    39,     0,     0,   181,    23,     0,     0,
+       0,     0,     0,     0,     0,    24,     0,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    34,    35,     0,     0,
+       0,    38,   257,     0,     0,     0,    39,     1,     2,     3,
+       4,     0,     6,   227,   228,   229,   230,   231,   232,   233,
+     234,   235,   236,     0,     0,     0,     0,     0,     0,     0,
+      18,     0,    19,    20,    21,     0,     0,     0,     1,     2,
+       3,     4,     0,     6,   320,   321,   322,   323,   324,   325,
+     326,   327,   328,   329,     0,     0,     0,     0,     0,    22,
+       0,    18,     0,    19,    20,    21,     0,     0,   181,    23,
+       0,     0,     0,     0,     0,     0,     0,    24,     0,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
+      22,     0,     0,    38,   313,     0,     0,     0,    39,   181,
+      23,     0,     0,     0,     0,     0,     0,     0,    24,     0,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,     0,     0,     0,    38,   343,     0,     0,     0,    39,
+       1,     2,     3,     4,     0,     6,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    18,     0,    19,    20,    21,     0,     0,
+       0,     1,     2,     3,     4,     0,     6,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    22,     0,    18,     0,    19,    20,    21,     0,
+       0,     0,    23,     0,     0,     0,     0,     0,     0,     0,
+      24,     0,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    34,    35,    22,     0,     0,    38,   113,     0,     0,
+       0,    39,     0,    23,     0,     0,     0,     0,     0,     0,
+       0,    24,     0,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    35,     0,     0,     0,    38,   249,     0,
+       0,     0,    39,     1,     2,     3,     4,     0,     6,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    18,     0,    19,    20,
+      21,     0,     0,     0,     1,     2,     3,     4,     0,     6,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    22,     0,    18,     0,    19,
+      20,    21,     0,     0,   181,    23,     0,     0,     0,     0,
+       0,     0,     0,    24,     0,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    34,    35,    22,     0,     0,    38,
+       0,     0,     0,     0,    39,     0,    23,     0,     0,     0,
+       0,     0,     0,     0,    24,     0,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    34,    35,     0,     0,     0,
+      38,   119,     0,   120,   121,    39,   122,   123,   124,   125,
+     126,   127,   128,   129,   130,   131,   132,   133,   134,   135,
+     136,   137,   138,     0,     0,   139,   140,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   119,     0,   120,   121,
+     202,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,     0,     0,
+     139,   140,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   119,     0,   120,   121,   297,   122,   123,   124,   125,
+     126,   127,   128,   129,   130,   131,   132,   133,   134,   135,
+     136,   137,   138,     0,     0,   139,   140,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   119,     0,   120,   121,
+     298,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,     0,     0,
+     139,   140,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   119,     0,   120,   121,   301,   122,   123,   124,   125,
+     126,   127,   128,   129,   130,   131,   132,   133,   134,   135,
+     136,   137,   138,     0,     0,   139,   140,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,   119,     0,   120,   121,
+     380,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,     0,     0,
+     139,   140,     0,     0,     0,     0,   306,   119,     0,   120,
+     121,   409,   122,   123,   124,   125,   126,   127,   128,   129,
+     130,   131,   132,   133,   134,   135,   136,   137,   138,     0,
+       0,   139,   140,   119,   293,   120,   121,     0,   122,   123,
+     124,   125,   126,   127,   128,   129,   130,   131,   132,   133,
+     134,   135,   136,   137,   138,     0,     0,   139,   140,   119,
+     411,   120,   121,     0,   122,   123,   124,   125,   126,   127,
+     128,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,     0,     0,   139,   140,   119,     0,   120,   121,     0,
+     122,   123,   124,   125,   126,   127,   128,   129,   130,   131,
+     132,   133,   134,   135,   136,   137,   138,     0,     0,   139,
+     140,   -98,     0,   120,   121,     0,   122,   123,   124,   125,
+     126,   127,   128,   129,   130,   131,   132,   133,   134,   135,
+     136,   137,   138,     0,     0,   139,   140,   120,   121,     0,
+     122,   123,   124,   125,   126,   127,   128,   129,   130,   131,
+     132,   133,   134,   135,   136,   137,   138,     0,     0,   139,
+     140,   122,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   136,   137,   138,     0,     0,
+     139,   140,   -98,   -98,   -98,   -98,   -98,   -98,   128,   129,
+     130,   131,   132,   133,   134,   135,   136,   137,   138,     0,
+       0,   139,   140
+};
+
+static const yytype_int16 yycheck[] =
+{
+       0,   300,    36,    37,   305,    10,   374,    25,    50,    85,
+      85,    16,     6,    88,    90,   169,    85,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      70,    71,    72,    38,    52,    75,    76,    91,    88,    93,
+     408,    41,    27,   411,    86,    90,     0,    90,    86,    90,
+      95,    85,    95,   354,    95,     6,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    67,    68,    69,    70,
+      71,    72,    95,    73,    75,    76,    90,    77,    90,    90,
+      90,    95,   381,    95,    95,    95,    90,    75,    76,    18,
+      19,    95,    97,    98,    99,   100,   101,   102,   103,   104,
+     105,   106,   107,   108,    89,   259,    91,    90,    93,    86,
+      89,    89,    95,    89,   119,   120,   121,   122,   123,   124,
+     125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,    90,    85,   141,    89,    85,    95,
+      89,   295,     3,     4,     5,     6,    89,     8,    89,    85,
+      89,    85,    85,    11,    23,   160,   161,    89,   163,   164,
+      85,    89,   167,   317,   169,    26,    89,    28,    29,    30,
+      89,    89,    86,    89,    85,    85,   181,    50,    87,    85,
+      85,    85,    90,   188,   189,   190,   191,   192,   193,   194,
+     195,   196,   197,   198,    55,    89,    85,    85,    85,    85,
+     200,    85,    85,    64,    65,    85,    87,    85,    85,   363,
+      50,    85,    73,    85,    75,    76,    77,    78,    79,    80,
+      81,    82,    83,    84,    85,    90,    20,    87,    89,    90,
+      85,    85,    85,    94,    85,    85,    85,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    85,    85,    85,
+      10,    86,    52,    86,   259,     0,    90,   262,     3,     4,
+       5,     6,     7,     8,     9,    88,    11,    12,    13,    14,
+      15,    16,    17,    90,    41,   397,    21,    22,   308,    24,
+     143,    26,   311,    28,    29,    30,   341,   262,   293,   159,
+     295,    85,   354,   296,   299,   300,    -1,   297,   298,    -1,
+      -1,   306,    -1,   308,    -1,    -1,    -1,    -1,    -1,    -1,
+      55,    -1,   317,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    -1,    89,    -1,    -1,    -1,    20,    94,
+      -1,    -1,    -1,   358,    -1,    -1,    -1,    -1,   363,    31,
+      32,    33,    34,    35,    36,    37,    38,    39,    40,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   381,   377,   378,    -1,
+     385,    -1,    -1,    -1,   384,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   392,   398,    41,    42,    43,    44,    45,    46,
+      47,    48,    49,    50,    -1,   405,    -1,    -1,    -1,    -1,
+      -1,     0,   412,   413,     3,     4,     5,     6,     7,     8,
+       9,    -1,    11,    12,    13,    14,    15,    16,    17,    -1,
+      -1,    -1,    21,    22,    -1,    24,    -1,    26,    -1,    28,
+      29,    30,    -1,    -1,    91,    -1,    93,    54,    -1,    56,
+      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
+      67,    68,    69,    70,    71,    72,    55,    -1,    75,    76,
+      -1,    -1,    -1,    -1,    -1,    -1,    65,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    73,    -1,    75,    76,    77,    78,
+      79,    80,    81,    82,    83,    84,    85,    86,    87,    -1,
+      89,    -1,    -1,    -1,    -1,    94,     3,     4,     5,     6,
+       7,     8,     9,    -1,    11,    12,    13,    14,    15,    16,
+      17,    -1,    -1,    -1,    21,    22,    -1,    -1,    -1,    26,
+      -1,    28,    29,    30,    -1,    -1,    51,    -1,    53,    54,
+      -1,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    55,    -1,
+      75,    76,    -1,    -1,    -1,    -1,    -1,    -1,    65,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    73,    92,    75,    76,
+      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
+      87,    88,    89,    -1,    -1,    -1,    -1,    94,     3,     4,
+       5,     6,     7,     8,     9,    -1,    11,    12,    13,    14,
+      15,    16,    17,    -1,    -1,    -1,    21,    22,    -1,    -1,
+      -1,    26,    -1,    28,    29,    30,    -1,    -1,    51,    -1,
+      53,    54,    -1,    56,    57,    58,    59,    60,    61,    62,
+      63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
+      55,    -1,    75,    76,    -1,    -1,    -1,    -1,    -1,    -1,
+      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,    92,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    -1,    -1,    -1,    -1,    94,
+       3,     4,     5,     6,     7,     8,     9,    -1,    11,    12,
+      13,    14,    15,    16,    17,    -1,    -1,    -1,    21,    22,
+      -1,    -1,    -1,    26,    -1,    28,    29,    30,    -1,    -1,
+      51,    -1,    53,    54,    -1,    56,    57,    58,    59,    60,
+      61,    62,    63,    64,    65,    66,    67,    68,    69,    70,
+      71,    72,    55,    -1,    75,    76,    -1,    -1,    -1,    -1,
+      -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      73,    92,    75,    76,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    86,    87,    -1,    89,    -1,    -1,    -1,
+      -1,    94,     3,     4,     5,     6,     7,     8,     9,    -1,
+      11,    12,    13,    14,    15,    16,    17,    -1,    -1,    -1,
+      21,    22,    -1,    -1,    -1,    26,    -1,    28,    29,    30,
+      -1,    -1,    -1,    -1,    -1,     3,     4,     5,     6,    -1,
+       8,    65,    66,    67,    68,    69,    70,    71,    72,    -1,
+      -1,    75,    76,    -1,    55,    -1,    -1,    -1,    26,    -1,
+      28,    29,    30,    -1,    65,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    73,    -1,    75,    76,    77,    78,    79,    80,
+      81,    82,    83,    84,    85,    86,    87,    55,    89,    -1,
+      -1,    -1,    -1,    94,    -1,    -1,    64,    65,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    73,    -1,    75,    76,    77,
+      78,    79,    80,    81,    82,    83,    84,    85,    -1,    -1,
+      -1,    89,    90,    -1,    -1,    -1,    94,     3,     4,     5,
+       6,    -1,     8,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      26,    -1,    28,    29,    30,    -1,    -1,    -1,     3,     4,
+       5,     6,    -1,     8,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    -1,    -1,    -1,    -1,    -1,    55,
+      -1,    26,    -1,    28,    29,    30,    -1,    -1,    64,    65,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,    75,
+      76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
+      55,    -1,    -1,    89,    90,    -1,    -1,    -1,    94,    64,
+      65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    73,    -1,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    -1,    -1,    -1,    89,    90,    -1,    -1,    -1,    94,
+       3,     4,     5,     6,    -1,     8,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    26,    -1,    28,    29,    30,    -1,    -1,
+      -1,     3,     4,     5,     6,    -1,     8,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    55,    -1,    26,    -1,    28,    29,    30,    -1,
+      -1,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      73,    -1,    75,    76,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    55,    -1,    -1,    89,    90,    -1,    -1,
+      -1,    94,    -1,    65,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    73,    -1,    75,    76,    77,    78,    79,    80,    81,
+      82,    83,    84,    85,    -1,    -1,    -1,    89,    90,    -1,
+      -1,    -1,    94,     3,     4,     5,     6,    -1,     8,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    26,    -1,    28,    29,
+      30,    -1,    -1,    -1,     3,     4,     5,     6,    -1,     8,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    55,    -1,    26,    -1,    28,
+      29,    30,    -1,    -1,    64,    65,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    73,    -1,    75,    76,    77,    78,    79,
+      80,    81,    82,    83,    84,    85,    55,    -1,    -1,    89,
+      -1,    -1,    -1,    -1,    94,    -1,    65,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    73,    -1,    75,    76,    77,    78,
+      79,    80,    81,    82,    83,    84,    85,    -1,    -1,    -1,
+      89,    51,    -1,    53,    54,    94,    56,    57,    58,    59,
+      60,    61,    62,    63,    64,    65,    66,    67,    68,    69,
+      70,    71,    72,    -1,    -1,    75,    76,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    51,    -1,    53,    54,
+      90,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    -1,    -1,
+      75,    76,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    51,    -1,    53,    54,    90,    56,    57,    58,    59,
+      60,    61,    62,    63,    64,    65,    66,    67,    68,    69,
+      70,    71,    72,    -1,    -1,    75,    76,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    51,    -1,    53,    54,
+      90,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    -1,    -1,
+      75,    76,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    51,    -1,    53,    54,    90,    56,    57,    58,    59,
+      60,    61,    62,    63,    64,    65,    66,    67,    68,    69,
+      70,    71,    72,    -1,    -1,    75,    76,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    51,    -1,    53,    54,
+      90,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    -1,    -1,
+      75,    76,    -1,    -1,    -1,    -1,    50,    51,    -1,    53,
+      54,    86,    56,    57,    58,    59,    60,    61,    62,    63,
+      64,    65,    66,    67,    68,    69,    70,    71,    72,    -1,
+      -1,    75,    76,    51,    52,    53,    54,    -1,    56,    57,
+      58,    59,    60,    61,    62,    63,    64,    65,    66,    67,
+      68,    69,    70,    71,    72,    -1,    -1,    75,    76,    51,
+      52,    53,    54,    -1,    56,    57,    58,    59,    60,    61,
+      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,
+      72,    -1,    -1,    75,    76,    51,    -1,    53,    54,    -1,
+      56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
+      66,    67,    68,    69,    70,    71,    72,    -1,    -1,    75,
+      76,    51,    -1,    53,    54,    -1,    56,    57,    58,    59,
+      60,    61,    62,    63,    64,    65,    66,    67,    68,    69,
+      70,    71,    72,    -1,    -1,    75,    76,    53,    54,    -1,
+      56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
+      66,    67,    68,    69,    70,    71,    72,    -1,    -1,    75,
+      76,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    -1,    -1,
+      75,    76,    56,    57,    58,    59,    60,    61,    62,    63,
+      64,    65,    66,    67,    68,    69,    70,    71,    72,    -1,
+      -1,    75,    76
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,     4,     5,     6,     7,     8,     9,    11,    12,
+      13,    14,    15,    16,    17,    21,    22,    24,    26,    28,
+      29,    30,    55,    65,    73,    75,    76,    77,    78,    79,
+      80,    81,    82,    83,    84,    85,    86,    87,    89,    94,
+      97,    98,    99,   101,   103,   116,   117,   118,   121,   123,
+     126,   127,   128,   131,   135,   136,   139,   141,   142,   143,
+     144,   147,   148,   149,   150,   151,   155,     6,    85,   124,
+     125,   104,   105,   106,   117,   107,   108,   109,   117,   156,
+      36,    37,    85,   117,   117,   117,   117,   117,   117,   117,
+     117,   117,   117,   117,   117,   117,    27,    41,    42,    43,
+      44,    45,    46,    47,    48,    49,    50,    89,    91,    93,
+     140,    88,   102,    90,   117,   122,     0,    99,    86,    51,
+      53,    54,    56,    57,    58,    59,    60,    61,    62,    63,
+      64,    65,    66,    67,    68,    69,    70,    71,    72,    75,
+      76,    91,    93,   119,   120,     6,    20,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,   152,    86,    95,
+      89,    89,   101,    89,    89,   101,    85,    89,    89,    89,
+      85,   117,   117,   117,   117,   117,   117,   117,   117,   117,
+     117,    64,    90,   117,   145,   146,   117,    85,    41,    42,
+      43,    44,    45,    46,    47,    48,    49,    50,    91,    93,
+     100,   101,    90,    89,   117,   117,   117,   117,   117,   117,
+     117,   117,   117,   117,   117,   117,   117,   117,   117,   117,
+     117,   117,   117,   117,   117,    85,   120,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    85,   125,   117,
+     117,    11,   115,   117,   117,    23,    25,    52,   157,    90,
+     117,   129,   130,    85,    90,   132,   133,    90,   145,    89,
+     117,    90,    95,    92,    89,   117,   117,   117,   117,   117,
+     117,   117,   117,   117,   117,   117,    85,    88,   101,    20,
+      31,    32,    33,    34,    35,    36,    37,    38,    39,    40,
+      85,   153,   154,    52,    92,    89,    89,    90,    90,    89,
+      86,    90,    89,    85,    85,    87,    50,    90,    95,   134,
+      90,    95,    90,    90,   145,   146,    90,   138,    92,    89,
+      31,    32,    33,    34,    35,    36,    37,    38,    39,    40,
+      85,    85,    85,    85,    85,    85,    85,    85,    85,    85,
+      90,    95,   117,    90,   145,   153,   101,   101,   117,   115,
+      87,    85,    85,   150,   158,   159,   117,   130,    50,   133,
+      90,   145,    90,   137,    85,    85,    85,    85,    85,    85,
+      85,    85,    85,    85,    87,   154,    90,    90,    10,   110,
+      90,    86,   111,   112,    90,    50,    86,    88,   159,   117,
+      90,   145,   100,   101,   101,   115,    88,   113,    18,    19,
+     114,   101,   117,    90,    88,    90,   114,   117,    52,    86,
+     101,    52,   100,   100,    16,    86
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (state, YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (&yylval, YYLEX_PARAM)
+#else
+# define YYLEX yylex (&yylval, scanner)
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value, state); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, intend_state *state)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep, state)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+    intend_state *state;
+#endif
+{
+  if (!yyvaluep)
+    return;
+  YYUSE (state);
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, intend_state *state)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep, state)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+    intend_state *state;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep, state);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule, intend_state *state)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule, state)
+    YYSTYPE *yyvsp;
+    int yyrule;
+    intend_state *state;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       , state);
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule, state); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, intend_state *state)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep, state)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+    intend_state *state;
+#endif
+{
+  YYUSE (yyvaluep);
+  YYUSE (state);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (intend_state *state);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (intend_state *state)
+#else
+int
+yyparse (state)
+    intend_state *state;
+#endif
+#endif
+{
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+    /* Number of syntax errors so far.  */
+    int yynerrs;
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 12:
+
+/* Line 1464 of yacc.c  */
+#line 177 "icl_grammar.y"
+    { parser_enter_include(state, (yyvsp[(2) - (3)].string)); }
+    break;
+
+  case 14:
+
+/* Line 1464 of yacc.c  */
+#line 179 "icl_grammar.y"
+    { stmt_begin_block(state); }
+    break;
+
+  case 15:
+
+/* Line 1464 of yacc.c  */
+#line 179 "icl_grammar.y"
+    { stmt_end_block(state); }
+    break;
+
+  case 16:
+
+/* Line 1464 of yacc.c  */
+#line 180 "icl_grammar.y"
+    { stmt_begin_block(state); stmt_end_nop(state); stmt_end_block(state); }
+    break;
+
+  case 17:
+
+/* Line 1464 of yacc.c  */
+#line 181 "icl_grammar.y"
+    { stmt_end_nop(state); }
+    break;
+
+  case 18:
+
+/* Line 1464 of yacc.c  */
+#line 184 "icl_grammar.y"
+    { stmt_begin_if(state); }
+    break;
+
+  case 19:
+
+/* Line 1464 of yacc.c  */
+#line 184 "icl_grammar.y"
+    { stmt_end_if(state); }
+    break;
+
+  case 20:
+
+/* Line 1464 of yacc.c  */
+#line 185 "icl_grammar.y"
+    { stmt_begin_while(state); }
+    break;
+
+  case 21:
+
+/* Line 1464 of yacc.c  */
+#line 185 "icl_grammar.y"
+    { stmt_end_while(state); }
+    break;
+
+  case 22:
+
+/* Line 1464 of yacc.c  */
+#line 186 "icl_grammar.y"
+    { stmt_begin_do(state); }
+    break;
+
+  case 23:
+
+/* Line 1464 of yacc.c  */
+#line 186 "icl_grammar.y"
+    { stmt_end_do(state); }
+    break;
+
+  case 24:
+
+/* Line 1464 of yacc.c  */
+#line 187 "icl_grammar.y"
+    { stmt_begin_for(state); }
+    break;
+
+  case 25:
+
+/* Line 1464 of yacc.c  */
+#line 187 "icl_grammar.y"
+    { stmt_end_for(state); }
+    break;
+
+  case 26:
+
+/* Line 1464 of yacc.c  */
+#line 188 "icl_grammar.y"
+    { stmt_begin_switch(state); }
+    break;
+
+  case 27:
+
+/* Line 1464 of yacc.c  */
+#line 188 "icl_grammar.y"
+    { stmt_end_switch(state); }
+    break;
+
+  case 28:
+
+/* Line 1464 of yacc.c  */
+#line 189 "icl_grammar.y"
+    { stmt_begin_try(state); }
+    break;
+
+  case 29:
+
+/* Line 1464 of yacc.c  */
+#line 189 "icl_grammar.y"
+    { stmt_end_try(state, (yyvsp[(6) - (8)].string)); }
+    break;
+
+  case 31:
+
+/* Line 1464 of yacc.c  */
+#line 193 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 32:
+
+/* Line 1464 of yacc.c  */
+#line 196 "icl_grammar.y"
+    { stmt_begin_case(state) ; }
+    break;
+
+  case 33:
+
+/* Line 1464 of yacc.c  */
+#line 196 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 34:
+
+/* Line 1464 of yacc.c  */
+#line 197 "icl_grammar.y"
+    { stmt_begin_case(state) ; }
+    break;
+
+  case 35:
+
+/* Line 1464 of yacc.c  */
+#line 197 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 36:
+
+/* Line 1464 of yacc.c  */
+#line 200 "icl_grammar.y"
+    { stmt_end_case(state,  1); }
+    break;
+
+  case 37:
+
+/* Line 1464 of yacc.c  */
+#line 201 "icl_grammar.y"
+    { stmt_end_nop(state); stmt_end_case(state,  1); }
+    break;
+
+  case 38:
+
+/* Line 1464 of yacc.c  */
+#line 202 "icl_grammar.y"
+    { stmt_end_case(state,  0); }
+    break;
+
+  case 39:
+
+/* Line 1464 of yacc.c  */
+#line 203 "icl_grammar.y"
+    { stmt_end_default(state); }
+    break;
+
+  case 40:
+
+/* Line 1464 of yacc.c  */
+#line 204 "icl_grammar.y"
+    { stmt_end_nop(state); stmt_end_default(state); }
+    break;
+
+  case 41:
+
+/* Line 1464 of yacc.c  */
+#line 207 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 42:
+
+/* Line 1464 of yacc.c  */
+#line 208 "icl_grammar.y"
+    { expr_end_true(state); }
+    break;
+
+  case 43:
+
+/* Line 1464 of yacc.c  */
+#line 211 "icl_grammar.y"
+    { stmt_end_expr(state); }
+    break;
+
+  case 44:
+
+/* Line 1464 of yacc.c  */
+#line 212 "icl_grammar.y"
+    { stmt_end_continue(state); }
+    break;
+
+  case 45:
+
+/* Line 1464 of yacc.c  */
+#line 213 "icl_grammar.y"
+    { stmt_end_break(state); }
+    break;
+
+  case 46:
+
+/* Line 1464 of yacc.c  */
+#line 214 "icl_grammar.y"
+    { stmt_end_return(state); }
+    break;
+
+  case 47:
+
+/* Line 1464 of yacc.c  */
+#line 215 "icl_grammar.y"
+    { stmt_end_return_value(state); }
+    break;
+
+  case 48:
+
+/* Line 1464 of yacc.c  */
+#line 216 "icl_grammar.y"
+    { stmt_end_throw(state); }
+    break;
+
+  case 49:
+
+/* Line 1464 of yacc.c  */
+#line 219 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 50:
+
+/* Line 1464 of yacc.c  */
+#line 220 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 51:
+
+/* Line 1464 of yacc.c  */
+#line 221 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 52:
+
+/* Line 1464 of yacc.c  */
+#line 222 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 53:
+
+/* Line 1464 of yacc.c  */
+#line 223 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 54:
+
+/* Line 1464 of yacc.c  */
+#line 224 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 55:
+
+/* Line 1464 of yacc.c  */
+#line 225 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 56:
+
+/* Line 1464 of yacc.c  */
+#line 226 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 57:
+
+/* Line 1464 of yacc.c  */
+#line 227 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 58:
+
+/* Line 1464 of yacc.c  */
+#line 228 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 59:
+
+/* Line 1464 of yacc.c  */
+#line 229 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 60:
+
+/* Line 1464 of yacc.c  */
+#line 230 "icl_grammar.y"
+    { expr_end_if(state); }
+    break;
+
+  case 61:
+
+/* Line 1464 of yacc.c  */
+#line 231 "icl_grammar.y"
+    { expr_end_file(state); }
+    break;
+
+  case 62:
+
+/* Line 1464 of yacc.c  */
+#line 232 "icl_grammar.y"
+    { expr_end_line(state); }
+    break;
+
+  case 63:
+
+/* Line 1464 of yacc.c  */
+#line 235 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 64:
+
+/* Line 1464 of yacc.c  */
+#line 236 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 65:
+
+/* Line 1464 of yacc.c  */
+#line 237 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 66:
+
+/* Line 1464 of yacc.c  */
+#line 238 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 67:
+
+/* Line 1464 of yacc.c  */
+#line 239 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 68:
+
+/* Line 1464 of yacc.c  */
+#line 240 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 69:
+
+/* Line 1464 of yacc.c  */
+#line 241 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 72:
+
+/* Line 1464 of yacc.c  */
+#line 248 "icl_grammar.y"
+    { expr_end_first(state); expr_end_index(state); }
+    break;
+
+  case 73:
+
+/* Line 1464 of yacc.c  */
+#line 249 "icl_grammar.y"
+    { expr_end_field(state, (yyvsp[(2) - (2)].string)); expr_end_first(state); expr_end_index(state); }
+    break;
+
+  case 74:
+
+/* Line 1464 of yacc.c  */
+#line 250 "icl_grammar.y"
+    { expr_end_method_void(state, (yyvsp[(2) - (4)].string)); }
+    break;
+
+  case 75:
+
+/* Line 1464 of yacc.c  */
+#line 251 "icl_grammar.y"
+    { expr_end_method(state, (yyvsp[(2) - (5)].string)); }
+    break;
+
+  case 76:
+
+/* Line 1464 of yacc.c  */
+#line 254 "icl_grammar.y"
+    { expr_begin_lambda(state); }
+    break;
+
+  case 77:
+
+/* Line 1464 of yacc.c  */
+#line 254 "icl_grammar.y"
+    { expr_end_lambda(state); }
+    break;
+
+  case 78:
+
+/* Line 1464 of yacc.c  */
+#line 257 "icl_grammar.y"
+    { expr_end_use(state); }
+    break;
+
+  case 79:
+
+/* Line 1464 of yacc.c  */
+#line 260 "icl_grammar.y"
+    { expr_end_first(state); }
+    break;
+
+  case 80:
+
+/* Line 1464 of yacc.c  */
+#line 261 "icl_grammar.y"
+    { expr_end_next(state); }
+    break;
+
+  case 81:
+
+/* Line 1464 of yacc.c  */
+#line 264 "icl_grammar.y"
+    { expr_end_const_string(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 82:
+
+/* Line 1464 of yacc.c  */
+#line 267 "icl_grammar.y"
+    { expr_end_call_void(state, (yyvsp[(1) - (3)].string), 0); }
+    break;
+
+  case 83:
+
+/* Line 1464 of yacc.c  */
+#line 268 "icl_grammar.y"
+    { expr_end_call(state, (yyvsp[(1) - (4)].string), 0); }
+    break;
+
+  case 84:
+
+/* Line 1464 of yacc.c  */
+#line 271 "icl_grammar.y"
+    { expr_end_call_void(state, (yyvsp[(2) - (4)].string), 1); }
+    break;
+
+  case 85:
+
+/* Line 1464 of yacc.c  */
+#line 272 "icl_grammar.y"
+    { expr_end_call(state, (yyvsp[(2) - (5)].string), 1); }
+    break;
+
+  case 86:
+
+/* Line 1464 of yacc.c  */
+#line 275 "icl_grammar.y"
+    { expr_end_typeinit_void(state, 1); }
+    break;
+
+  case 87:
+
+/* Line 1464 of yacc.c  */
+#line 276 "icl_grammar.y"
+    { expr_end_typeinit(state, 1); }
+    break;
+
+  case 88:
+
+/* Line 1464 of yacc.c  */
+#line 279 "icl_grammar.y"
+    { expr_end_first(state); expr_end_next(state); }
+    break;
+
+  case 89:
+
+/* Line 1464 of yacc.c  */
+#line 280 "icl_grammar.y"
+    { expr_end_next(state); expr_end_next(state); }
+    break;
+
+  case 90:
+
+/* Line 1464 of yacc.c  */
+#line 283 "icl_grammar.y"
+    { expr_end_keyarray_single(state); }
+    break;
+
+  case 91:
+
+/* Line 1464 of yacc.c  */
+#line 284 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 92:
+
+/* Line 1464 of yacc.c  */
+#line 287 "icl_grammar.y"
+    { expr_end_typeinit_void(state, 2); }
+    break;
+
+  case 93:
+
+/* Line 1464 of yacc.c  */
+#line 288 "icl_grammar.y"
+    { expr_end_typeinit(state, 2); }
+    break;
+
+  case 94:
+
+/* Line 1464 of yacc.c  */
+#line 291 "icl_grammar.y"
+    { expr_end_first(state); expr_end_next(state); }
+    break;
+
+  case 95:
+
+/* Line 1464 of yacc.c  */
+#line 292 "icl_grammar.y"
+    { expr_end_next(state); expr_end_next(state); }
+    break;
+
+  case 96:
+
+/* Line 1464 of yacc.c  */
+#line 295 "icl_grammar.y"
+    { expr_end_const_string(state, (yyvsp[(1) - (1)].string)); expr_end_const_void(state); }
+    break;
+
+  case 97:
+
+/* Line 1464 of yacc.c  */
+#line 296 "icl_grammar.y"
+    { expr_end_const_string(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 98:
+
+/* Line 1464 of yacc.c  */
+#line 296 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 99:
+
+/* Line 1464 of yacc.c  */
+#line 299 "icl_grammar.y"
+    { expr_end_static_void(state, (yyvsp[(1) - (5)].string), (yyvsp[(3) - (5)].string)); }
+    break;
+
+  case 100:
+
+/* Line 1464 of yacc.c  */
+#line 300 "icl_grammar.y"
+    { expr_end_static(state, (yyvsp[(1) - (6)].string), (yyvsp[(3) - (6)].string)); }
+    break;
+
+  case 101:
+
+/* Line 1464 of yacc.c  */
+#line 303 "icl_grammar.y"
+    { expr_end_ref_array(state, (yyvsp[(1) - (6)].string)); expr_end_method_void(state, (yyvsp[(4) - (6)].string)); }
+    break;
+
+  case 102:
+
+/* Line 1464 of yacc.c  */
+#line 304 "icl_grammar.y"
+    { expr_end_ref_array(state, (yyvsp[(1) - (5)].string)); }
+    break;
+
+  case 103:
+
+/* Line 1464 of yacc.c  */
+#line 304 "icl_grammar.y"
+    { expr_end_method(state, (yyvsp[(4) - (8)].string)); }
+    break;
+
+  case 104:
+
+/* Line 1464 of yacc.c  */
+#line 305 "icl_grammar.y"
+    { expr_end_ref(state, (yyvsp[(1) - (5)].string)); expr_end_method_void(state, (yyvsp[(3) - (5)].string)); }
+    break;
+
+  case 105:
+
+/* Line 1464 of yacc.c  */
+#line 306 "icl_grammar.y"
+    { expr_end_ref(state, (yyvsp[(1) - (4)].string)); }
+    break;
+
+  case 106:
+
+/* Line 1464 of yacc.c  */
+#line 306 "icl_grammar.y"
+    { expr_end_method(state, (yyvsp[(3) - (7)].string)); }
+    break;
+
+  case 107:
+
+/* Line 1464 of yacc.c  */
+#line 309 "icl_grammar.y"
+    { expr_end_ref(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 108:
+
+/* Line 1464 of yacc.c  */
+#line 310 "icl_grammar.y"
+    { expr_end_ref_array(state, (yyvsp[(1) - (2)].string)); }
+    break;
+
+  case 109:
+
+/* Line 1464 of yacc.c  */
+#line 311 "icl_grammar.y"
+    { expr_end_static_ref(state, (yyvsp[(1) - (3)].string), (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 110:
+
+/* Line 1464 of yacc.c  */
+#line 314 "icl_grammar.y"
+    { expr_end_first(state); }
+    break;
+
+  case 111:
+
+/* Line 1464 of yacc.c  */
+#line 315 "icl_grammar.y"
+    { expr_end_field(state, (yyvsp[(2) - (2)].string)); expr_end_first(state); }
+    break;
+
+  case 112:
+
+/* Line 1464 of yacc.c  */
+#line 316 "icl_grammar.y"
+    { expr_end_next(state); }
+    break;
+
+  case 113:
+
+/* Line 1464 of yacc.c  */
+#line 317 "icl_grammar.y"
+    { expr_end_field(state, (yyvsp[(3) - (3)].string)); expr_end_next(state); }
+    break;
+
+  case 114:
+
+/* Line 1464 of yacc.c  */
+#line 320 "icl_grammar.y"
+    { expr_end_assign(state, (yyvsp[(1) - (3)].string)); }
+    break;
+
+  case 115:
+
+/* Line 1464 of yacc.c  */
+#line 321 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_PLUS); }
+    break;
+
+  case 116:
+
+/* Line 1464 of yacc.c  */
+#line 322 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_MINUS); }
+    break;
+
+  case 117:
+
+/* Line 1464 of yacc.c  */
+#line 323 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_MUL); }
+    break;
+
+  case 118:
+
+/* Line 1464 of yacc.c  */
+#line 324 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_DIV); }
+    break;
+
+  case 119:
+
+/* Line 1464 of yacc.c  */
+#line 325 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_AND); }
+    break;
+
+  case 120:
+
+/* Line 1464 of yacc.c  */
+#line 326 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_OR); }
+    break;
+
+  case 121:
+
+/* Line 1464 of yacc.c  */
+#line 327 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_XOR); }
+    break;
+
+  case 122:
+
+/* Line 1464 of yacc.c  */
+#line 328 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_LSHIFT); }
+    break;
+
+  case 123:
+
+/* Line 1464 of yacc.c  */
+#line 329 "icl_grammar.y"
+    { expr_end_op_assign(state, (yyvsp[(1) - (3)].string), OPTYPE_RSHIFT); }
+    break;
+
+  case 124:
+
+/* Line 1464 of yacc.c  */
+#line 330 "icl_grammar.y"
+    { expr_end_assign_array(state, (yyvsp[(1) - (4)].string)); }
+    break;
+
+  case 125:
+
+/* Line 1464 of yacc.c  */
+#line 331 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_PLUS); }
+    break;
+
+  case 126:
+
+/* Line 1464 of yacc.c  */
+#line 332 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_MINUS); }
+    break;
+
+  case 127:
+
+/* Line 1464 of yacc.c  */
+#line 333 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_MUL); }
+    break;
+
+  case 128:
+
+/* Line 1464 of yacc.c  */
+#line 334 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_DIV); }
+    break;
+
+  case 129:
+
+/* Line 1464 of yacc.c  */
+#line 335 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_AND); }
+    break;
+
+  case 130:
+
+/* Line 1464 of yacc.c  */
+#line 336 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_OR); }
+    break;
+
+  case 131:
+
+/* Line 1464 of yacc.c  */
+#line 337 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_XOR); }
+    break;
+
+  case 132:
+
+/* Line 1464 of yacc.c  */
+#line 338 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_LSHIFT); }
+    break;
+
+  case 133:
+
+/* Line 1464 of yacc.c  */
+#line 339 "icl_grammar.y"
+    { expr_end_op_assign_array(state, (yyvsp[(1) - (4)].string), OPTYPE_RSHIFT); }
+    break;
+
+  case 134:
+
+/* Line 1464 of yacc.c  */
+#line 342 "icl_grammar.y"
+    { expr_end_prefix(state, OPTYPE_NOT); }
+    break;
+
+  case 135:
+
+/* Line 1464 of yacc.c  */
+#line 343 "icl_grammar.y"
+    { expr_end_prefix(state, OPTYPE_MINUS); }
+    break;
+
+  case 136:
+
+/* Line 1464 of yacc.c  */
+#line 344 "icl_grammar.y"
+    { expr_end_prefix(state, OPTYPE_PREINC); }
+    break;
+
+  case 137:
+
+/* Line 1464 of yacc.c  */
+#line 345 "icl_grammar.y"
+    { expr_end_prefix(state, OPTYPE_PREDEC); }
+    break;
+
+  case 138:
+
+/* Line 1464 of yacc.c  */
+#line 346 "icl_grammar.y"
+    { expr_end_prefix(state, OPTYPE_NEG); }
+    break;
+
+  case 139:
+
+/* Line 1464 of yacc.c  */
+#line 349 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_PLUS); }
+    break;
+
+  case 140:
+
+/* Line 1464 of yacc.c  */
+#line 350 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_MINUS); }
+    break;
+
+  case 141:
+
+/* Line 1464 of yacc.c  */
+#line 351 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_MUL); }
+    break;
+
+  case 142:
+
+/* Line 1464 of yacc.c  */
+#line 352 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_DIV); }
+    break;
+
+  case 143:
+
+/* Line 1464 of yacc.c  */
+#line 353 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_MOD); }
+    break;
+
+  case 144:
+
+/* Line 1464 of yacc.c  */
+#line 354 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_POW); }
+    break;
+
+  case 145:
+
+/* Line 1464 of yacc.c  */
+#line 355 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_BOOL_AND); }
+    break;
+
+  case 146:
+
+/* Line 1464 of yacc.c  */
+#line 356 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_BOOL_OR); }
+    break;
+
+  case 147:
+
+/* Line 1464 of yacc.c  */
+#line 357 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_AND); }
+    break;
+
+  case 148:
+
+/* Line 1464 of yacc.c  */
+#line 358 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_OR); }
+    break;
+
+  case 149:
+
+/* Line 1464 of yacc.c  */
+#line 359 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_XOR); }
+    break;
+
+  case 150:
+
+/* Line 1464 of yacc.c  */
+#line 360 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_LSHIFT); }
+    break;
+
+  case 151:
+
+/* Line 1464 of yacc.c  */
+#line 361 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_RSHIFT); }
+    break;
+
+  case 152:
+
+/* Line 1464 of yacc.c  */
+#line 362 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_EQUAL); }
+    break;
+
+  case 153:
+
+/* Line 1464 of yacc.c  */
+#line 363 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_NOT_EQUAL); }
+    break;
+
+  case 154:
+
+/* Line 1464 of yacc.c  */
+#line 364 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_SEQ); }
+    break;
+
+  case 155:
+
+/* Line 1464 of yacc.c  */
+#line 365 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_LEQ); }
+    break;
+
+  case 156:
+
+/* Line 1464 of yacc.c  */
+#line 366 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_SMALLER); }
+    break;
+
+  case 157:
+
+/* Line 1464 of yacc.c  */
+#line 367 "icl_grammar.y"
+    { expr_end_infix(state, OPTYPE_LARGER); }
+    break;
+
+  case 158:
+
+/* Line 1464 of yacc.c  */
+#line 370 "icl_grammar.y"
+    { expr_end_postfix(state, OPTYPE_POSTINC); }
+    break;
+
+  case 159:
+
+/* Line 1464 of yacc.c  */
+#line 371 "icl_grammar.y"
+    { expr_end_postfix(state, OPTYPE_POSTDEC); }
+    break;
+
+  case 160:
+
+/* Line 1464 of yacc.c  */
+#line 374 "icl_grammar.y"
+    { expr_end_first(state); }
+    break;
+
+  case 161:
+
+/* Line 1464 of yacc.c  */
+#line 375 "icl_grammar.y"
+    { expr_end_next(state); }
+    break;
+
+  case 162:
+
+/* Line 1464 of yacc.c  */
+#line 378 "icl_grammar.y"
+    { expr_end_pass_ref(state); }
+    break;
+
+  case 163:
+
+/* Line 1464 of yacc.c  */
+#line 379 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 164:
+
+/* Line 1464 of yacc.c  */
+#line 382 "icl_grammar.y"
+    { expr_end_const_bool(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 165:
+
+/* Line 1464 of yacc.c  */
+#line 383 "icl_grammar.y"
+    { expr_end_const_int(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 166:
+
+/* Line 1464 of yacc.c  */
+#line 384 "icl_grammar.y"
+    { expr_end_const_float(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 167:
+
+/* Line 1464 of yacc.c  */
+#line 385 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 168:
+
+/* Line 1464 of yacc.c  */
+#line 386 "icl_grammar.y"
+    { expr_end_const_void(state); }
+    break;
+
+  case 169:
+
+/* Line 1464 of yacc.c  */
+#line 387 "icl_grammar.y"
+    { expr_end_const_void(state); }
+    break;
+
+  case 170:
+
+/* Line 1464 of yacc.c  */
+#line 390 "icl_grammar.y"
+    { expr_end_const_string(state, (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 171:
+
+/* Line 1464 of yacc.c  */
+#line 391 "icl_grammar.y"
+    { expr_end_const_string(state, (yyvsp[(2) - (2)].string)); expr_end_infix(state, OPTYPE_PLUS); }
+    break;
+
+  case 172:
+
+/* Line 1464 of yacc.c  */
+#line 394 "icl_grammar.y"
+    { expr_end_cast(state, "void"); }
+    break;
+
+  case 173:
+
+/* Line 1464 of yacc.c  */
+#line 395 "icl_grammar.y"
+    { expr_end_cast(state, "bool"); }
+    break;
+
+  case 174:
+
+/* Line 1464 of yacc.c  */
+#line 396 "icl_grammar.y"
+    { expr_end_cast(state, "int"); }
+    break;
+
+  case 175:
+
+/* Line 1464 of yacc.c  */
+#line 397 "icl_grammar.y"
+    { expr_end_cast(state, "uint"); }
+    break;
+
+  case 176:
+
+/* Line 1464 of yacc.c  */
+#line 398 "icl_grammar.y"
+    { expr_end_cast(state, "float"); }
+    break;
+
+  case 177:
+
+/* Line 1464 of yacc.c  */
+#line 399 "icl_grammar.y"
+    { expr_end_cast(state, "string"); }
+    break;
+
+  case 178:
+
+/* Line 1464 of yacc.c  */
+#line 400 "icl_grammar.y"
+    { expr_end_cast(state, "array"); }
+    break;
+
+  case 179:
+
+/* Line 1464 of yacc.c  */
+#line 401 "icl_grammar.y"
+    { expr_end_cast(state, "struct"); }
+    break;
+
+  case 180:
+
+/* Line 1464 of yacc.c  */
+#line 404 "icl_grammar.y"
+    { stmt_begin_func(state); }
+    break;
+
+  case 181:
+
+/* Line 1464 of yacc.c  */
+#line 404 "icl_grammar.y"
+    { stmt_end_func(state, (yyvsp[(3) - (7)].string)); }
+    break;
+
+  case 182:
+
+/* Line 1464 of yacc.c  */
+#line 407 "icl_grammar.y"
+    { stmt_end_rettype(state, 'v'); }
+    break;
+
+  case 183:
+
+/* Line 1464 of yacc.c  */
+#line 408 "icl_grammar.y"
+    { stmt_end_rettype(state, 'b'); }
+    break;
+
+  case 184:
+
+/* Line 1464 of yacc.c  */
+#line 409 "icl_grammar.y"
+    { stmt_end_rettype(state, 'i'); }
+    break;
+
+  case 185:
+
+/* Line 1464 of yacc.c  */
+#line 410 "icl_grammar.y"
+    { stmt_end_rettype(state, 'f'); }
+    break;
+
+  case 186:
+
+/* Line 1464 of yacc.c  */
+#line 411 "icl_grammar.y"
+    { stmt_end_rettype(state, 's'); }
+    break;
+
+  case 187:
+
+/* Line 1464 of yacc.c  */
+#line 412 "icl_grammar.y"
+    { stmt_end_rettype(state, 'a'); }
+    break;
+
+  case 188:
+
+/* Line 1464 of yacc.c  */
+#line 413 "icl_grammar.y"
+    { stmt_end_rettype(state, 'c'); }
+    break;
+
+  case 189:
+
+/* Line 1464 of yacc.c  */
+#line 414 "icl_grammar.y"
+    { stmt_end_rettype(state, 'p'); }
+    break;
+
+  case 190:
+
+/* Line 1464 of yacc.c  */
+#line 415 "icl_grammar.y"
+    { stmt_end_rettype(state, 'r'); }
+    break;
+
+  case 191:
+
+/* Line 1464 of yacc.c  */
+#line 416 "icl_grammar.y"
+    { stmt_end_rettype(state, '?'); }
+    break;
+
+  case 192:
+
+/* Line 1464 of yacc.c  */
+#line 417 "icl_grammar.y"
+    { stmt_end_rettype(state, 'V'); }
+    break;
+
+  case 193:
+
+/* Line 1464 of yacc.c  */
+#line 418 "icl_grammar.y"
+    { stmt_end_rettype(state, 'B'); }
+    break;
+
+  case 194:
+
+/* Line 1464 of yacc.c  */
+#line 419 "icl_grammar.y"
+    { stmt_end_rettype(state, 'I'); }
+    break;
+
+  case 195:
+
+/* Line 1464 of yacc.c  */
+#line 420 "icl_grammar.y"
+    { stmt_end_rettype(state, 'F'); }
+    break;
+
+  case 196:
+
+/* Line 1464 of yacc.c  */
+#line 421 "icl_grammar.y"
+    { stmt_end_rettype(state, 'S'); }
+    break;
+
+  case 197:
+
+/* Line 1464 of yacc.c  */
+#line 422 "icl_grammar.y"
+    { stmt_end_rettype(state, 'A'); }
+    break;
+
+  case 198:
+
+/* Line 1464 of yacc.c  */
+#line 423 "icl_grammar.y"
+    { stmt_end_rettype(state, 'C'); }
+    break;
+
+  case 199:
+
+/* Line 1464 of yacc.c  */
+#line 424 "icl_grammar.y"
+    { stmt_end_rettype(state, 'P'); }
+    break;
+
+  case 200:
+
+/* Line 1464 of yacc.c  */
+#line 425 "icl_grammar.y"
+    { stmt_end_rettype(state, 'R'); }
+    break;
+
+  case 201:
+
+/* Line 1464 of yacc.c  */
+#line 426 "icl_grammar.y"
+    { stmt_end_rettype(state, '?'); }
+    break;
+
+  case 202:
+
+/* Line 1464 of yacc.c  */
+#line 429 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 203:
+
+/* Line 1464 of yacc.c  */
+#line 430 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 204:
+
+/* Line 1464 of yacc.c  */
+#line 431 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 205:
+
+/* Line 1464 of yacc.c  */
+#line 434 "icl_grammar.y"
+    { stmt_end_arg(state, 'v', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 206:
+
+/* Line 1464 of yacc.c  */
+#line 435 "icl_grammar.y"
+    { stmt_end_arg(state, 'b', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 207:
+
+/* Line 1464 of yacc.c  */
+#line 436 "icl_grammar.y"
+    { stmt_end_arg(state, 'i', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 208:
+
+/* Line 1464 of yacc.c  */
+#line 437 "icl_grammar.y"
+    { stmt_end_arg(state, 'f', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 209:
+
+/* Line 1464 of yacc.c  */
+#line 438 "icl_grammar.y"
+    { stmt_end_arg(state, 's', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 210:
+
+/* Line 1464 of yacc.c  */
+#line 439 "icl_grammar.y"
+    { stmt_end_arg(state, 'a', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 211:
+
+/* Line 1464 of yacc.c  */
+#line 440 "icl_grammar.y"
+    { stmt_end_arg(state, 'c', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 212:
+
+/* Line 1464 of yacc.c  */
+#line 441 "icl_grammar.y"
+    { stmt_end_arg(state, 'p', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 213:
+
+/* Line 1464 of yacc.c  */
+#line 442 "icl_grammar.y"
+    { stmt_end_arg(state, 'r', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 214:
+
+/* Line 1464 of yacc.c  */
+#line 443 "icl_grammar.y"
+    { stmt_end_arg(state, '?', (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 215:
+
+/* Line 1464 of yacc.c  */
+#line 444 "icl_grammar.y"
+    { stmt_end_arg(state, 'V', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 216:
+
+/* Line 1464 of yacc.c  */
+#line 445 "icl_grammar.y"
+    { stmt_end_arg(state, 'B', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 217:
+
+/* Line 1464 of yacc.c  */
+#line 446 "icl_grammar.y"
+    { stmt_end_arg(state, 'I', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 218:
+
+/* Line 1464 of yacc.c  */
+#line 447 "icl_grammar.y"
+    { stmt_end_arg(state, 'F', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 219:
+
+/* Line 1464 of yacc.c  */
+#line 448 "icl_grammar.y"
+    { stmt_end_arg(state, 'S', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 220:
+
+/* Line 1464 of yacc.c  */
+#line 449 "icl_grammar.y"
+    { stmt_end_arg(state, 'A', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 221:
+
+/* Line 1464 of yacc.c  */
+#line 450 "icl_grammar.y"
+    { stmt_end_arg(state, 'C', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 222:
+
+/* Line 1464 of yacc.c  */
+#line 451 "icl_grammar.y"
+    { stmt_end_arg(state, 'P', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 223:
+
+/* Line 1464 of yacc.c  */
+#line 452 "icl_grammar.y"
+    { stmt_end_arg(state, 'R', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 224:
+
+/* Line 1464 of yacc.c  */
+#line 453 "icl_grammar.y"
+    { stmt_end_arg(state, '?', (yyvsp[(3) - (3)].string)); }
+    break;
+
+  case 225:
+
+/* Line 1464 of yacc.c  */
+#line 454 "icl_grammar.y"
+    { stmt_end_arg(state, '?', (yyvsp[(1) - (1)].string)); }
+    break;
+
+  case 226:
+
+/* Line 1464 of yacc.c  */
+#line 457 "icl_grammar.y"
+    { stmt_begin_class(state); }
+    break;
+
+  case 227:
+
+/* Line 1464 of yacc.c  */
+#line 457 "icl_grammar.y"
+    { stmt_end_class(state, (yyvsp[(3) - (7)].string)); }
+    break;
+
+  case 228:
+
+/* Line 1464 of yacc.c  */
+#line 460 "icl_grammar.y"
+    { stmt_end_extends(state, (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 229:
+
+/* Line 1464 of yacc.c  */
+#line 461 "icl_grammar.y"
+    { stmt_end_extends(state, (yyvsp[(2) - (2)].string)); }
+    break;
+
+  case 230:
+
+/* Line 1464 of yacc.c  */
+#line 462 "icl_grammar.y"
+    { stmt_end_extends(state, NULL); }
+    break;
+
+  case 233:
+
+/* Line 1464 of yacc.c  */
+#line 469 "icl_grammar.y"
+    { /* nop */ }
+    break;
+
+  case 234:
+
+/* Line 1464 of yacc.c  */
+#line 470 "icl_grammar.y"
+    { expr_end_const_void(state); expr_end_assign(state, (yyvsp[(1) - (2)].string)); stmt_end_expr(state); }
+    break;
+
+  case 235:
+
+/* Line 1464 of yacc.c  */
+#line 471 "icl_grammar.y"
+    { expr_end_assign(state, (yyvsp[(1) - (4)].string)); stmt_end_expr(state); }
+    break;
+
+
+
+/* Line 1464 of yacc.c  */
+#line 3727 "icl_grammar.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (state, YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (state, yymsg);
+	  }
+	else
+	  {
+	    yyerror (state, YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval, state);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp, state);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (state, YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval, state);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp, state);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1684 of yacc.c  */
+#line 474 "icl_grammar.y"
+
+
diff -Naur orig/libintend/libparser/icl_grammar.h patched/libintend/libparser/icl_grammar.h
--- orig/libintend/libparser/icl_grammar.h	1970-01-01 01:00:00.000000000 +0100
+++ patched/libintend/libparser/icl_grammar.h	2013-10-20 23:31:47.000000000 +0200
@@ -0,0 +1,232 @@
+/* A Bison parser, made by GNU Bison 2.4.2.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2006, 2009-2010 Free Software
+   Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     CONST_BOOL = 258,
+     CONST_INT = 259,
+     CONST_FLOAT = 260,
+     CONST_STRING = 261,
+     KW_INC = 262,
+     KW_USE = 263,
+     KW_IF = 264,
+     KW_ELSE = 265,
+     KW_WHILE = 266,
+     KW_DO = 267,
+     KW_RETURN = 268,
+     KW_FOR = 269,
+     KW_CONTINUE = 270,
+     KW_BREAK = 271,
+     KW_SWITCH = 272,
+     KW_CASE = 273,
+     KW_DEFAULT = 274,
+     KW_FORCE = 275,
+     KW_TRY = 276,
+     KW_THROW = 277,
+     KW_CATCH = 278,
+     KW_CLASS = 279,
+     KW_EXTENDS = 280,
+     KW_NEW = 281,
+     KW_STATIC = 282,
+     KW_FILE = 283,
+     KW_LINE = 284,
+     KW_NULL = 285,
+     TYPE_VOID = 286,
+     TYPE_BOOL = 287,
+     TYPE_INT = 288,
+     TYPE_FLOAT = 289,
+     TYPE_STRING = 290,
+     TYPE_ARRAY = 291,
+     TYPE_STRUCT = 292,
+     TYPE_FN = 293,
+     TYPE_RES = 294,
+     TYPE_MIXED = 295,
+     OP_ARSHIFT = 296,
+     OP_ALSHIFT = 297,
+     OP_AXOR = 298,
+     OP_AOR = 299,
+     OP_AAND = 300,
+     OP_ADIV = 301,
+     OP_AMUL = 302,
+     OP_AMINUS = 303,
+     OP_APLUS = 304,
+     OP_ASSIGN = 305,
+     OP_BOOL_OR = 306,
+     OP_BOOL_AND = 307,
+     OP_NOT = 308,
+     OP_LARGER = 309,
+     OP_SMALLER = 310,
+     OP_LEQ = 311,
+     OP_SEQ = 312,
+     OP_NOT_EQUAL = 313,
+     OP_EQUAL = 314,
+     OP_XOR = 315,
+     OP_OR = 316,
+     OP_AND = 317,
+     OP_MINUS = 318,
+     OP_PLUS = 319,
+     OP_MOD = 320,
+     OP_DIV = 321,
+     OP_MUL = 322,
+     OP_POW = 323,
+     OP_RSHIFT = 324,
+     OP_LSHIFT = 325,
+     OP_NEG = 326,
+     UNARY_MINUS = 327,
+     OP_MINUSMINUS = 328,
+     OP_PLUSPLUS = 329,
+     CAST_STRUCT = 330,
+     CAST_ARRAY = 331,
+     CAST_STRING = 332,
+     CAST_FLOAT = 333,
+     CAST_UINT = 334,
+     CAST_INT = 335,
+     CAST_BOOL = 336,
+     CAST_VOID = 337,
+     ID = 338
+   };
+#endif
+/* Tokens.  */
+#define CONST_BOOL 258
+#define CONST_INT 259
+#define CONST_FLOAT 260
+#define CONST_STRING 261
+#define KW_INC 262
+#define KW_USE 263
+#define KW_IF 264
+#define KW_ELSE 265
+#define KW_WHILE 266
+#define KW_DO 267
+#define KW_RETURN 268
+#define KW_FOR 269
+#define KW_CONTINUE 270
+#define KW_BREAK 271
+#define KW_SWITCH 272
+#define KW_CASE 273
+#define KW_DEFAULT 274
+#define KW_FORCE 275
+#define KW_TRY 276
+#define KW_THROW 277
+#define KW_CATCH 278
+#define KW_CLASS 279
+#define KW_EXTENDS 280
+#define KW_NEW 281
+#define KW_STATIC 282
+#define KW_FILE 283
+#define KW_LINE 284
+#define KW_NULL 285
+#define TYPE_VOID 286
+#define TYPE_BOOL 287
+#define TYPE_INT 288
+#define TYPE_FLOAT 289
+#define TYPE_STRING 290
+#define TYPE_ARRAY 291
+#define TYPE_STRUCT 292
+#define TYPE_FN 293
+#define TYPE_RES 294
+#define TYPE_MIXED 295
+#define OP_ARSHIFT 296
+#define OP_ALSHIFT 297
+#define OP_AXOR 298
+#define OP_AOR 299
+#define OP_AAND 300
+#define OP_ADIV 301
+#define OP_AMUL 302
+#define OP_AMINUS 303
+#define OP_APLUS 304
+#define OP_ASSIGN 305
+#define OP_BOOL_OR 306
+#define OP_BOOL_AND 307
+#define OP_NOT 308
+#define OP_LARGER 309
+#define OP_SMALLER 310
+#define OP_LEQ 311
+#define OP_SEQ 312
+#define OP_NOT_EQUAL 313
+#define OP_EQUAL 314
+#define OP_XOR 315
+#define OP_OR 316
+#define OP_AND 317
+#define OP_MINUS 318
+#define OP_PLUS 319
+#define OP_MOD 320
+#define OP_DIV 321
+#define OP_MUL 322
+#define OP_POW 323
+#define OP_RSHIFT 324
+#define OP_LSHIFT 325
+#define OP_NEG 326
+#define UNARY_MINUS 327
+#define OP_MINUSMINUS 328
+#define OP_PLUSPLUS 329
+#define CAST_STRUCT 330
+#define CAST_ARRAY 331
+#define CAST_STRING 332
+#define CAST_FLOAT 333
+#define CAST_UINT 334
+#define CAST_INT 335
+#define CAST_BOOL 336
+#define CAST_VOID 337
+#define ID 338
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1685 of yacc.c  */
+#line 67 "icl_grammar.y"
+
+    char *string;
+    int unused;
+
+
+
+/* Line 1685 of yacc.c  */
+#line 224 "icl_grammar.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+
+
diff -Naur orig/libintend/libparser/Makefile.in patched/libintend/libparser/Makefile.in
--- orig/libintend/libparser/Makefile.in	2008-12-05 17:02:42.000000000 +0100
+++ patched/libintend/libparser/Makefile.in	2013-10-21 00:05:51.330357764 +0200
@@ -296,9 +296,6 @@
 .l.c:
 	$(am__skiplex) $(SHELL) $(YLWRAP) $< $(LEX_OUTPUT_ROOT).c $@ -- $(LEXCOMPILE)
 
-.y.c:
-	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
-
 mostlyclean-libtool:
 	-rm -f *.lo
 

diff -Naurd a/netboot/e1000.c b/netboot/e1000.c
--- a/netboot/e1000.c	2006-02-27 17:18:29.000000000 +0100
+++ b/netboot/e1000.c	2004-07-14 04:07:54.000000000 +0200
@@ -68,10 +82,6 @@
 /* Define this to behave more like the Linux driver. */
 #undef LINUX_DRIVER
 
-/* Define this (and implement the needed functions) if you want to differ
- * between port an memory mapped io. */
-#undef PORT_IO_AND_MEMORY_IO_DIFFER
-
 #include "e1000_hw.h"
 
 /* NIC specific static variables go here */
@@ -88,7 +98,7 @@
 
 /* Function forward declarations */
 static int e1000_setup_link(struct e1000_hw *hw);
-static int e1000_setup_fiber_link(struct e1000_hw *hw);
+static int e1000_setup_fiber_serdes_link(struct e1000_hw *hw);
 static int e1000_setup_copper_link(struct e1000_hw *hw);
 static int e1000_phy_setup_autoneg(struct e1000_hw *hw);
 static void e1000_config_collision_dist(struct e1000_hw *hw);
@@ -98,7 +108,9 @@
 static int e1000_wait_autoneg(struct e1000_hw *hw);
 static void e1000_get_speed_and_duplex(struct e1000_hw *hw, uint16_t *speed, uint16_t *duplex);
 static int e1000_read_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t *phy_data);
+static int e1000_read_phy_reg_ex(struct e1000_hw *hw, uint32_t reg_addr, uint16_t *phy_data);
 static int e1000_write_phy_reg(struct e1000_hw *hw, uint32_t reg_addr, uint16_t phy_data);
+static int e1000_write_phy_reg_ex(struct e1000_hw *hw, uint32_t reg_addr, uint16_t phy_data);
 static void e1000_phy_hw_reset(struct e1000_hw *hw);
 static int e1000_phy_reset(struct e1000_hw *hw);
 static int e1000_detect_gig_phy(struct e1000_hw *hw);
@@ -155,6 +167,18 @@
 
 #define E1000_WRITE_FLUSH(a) {uint32_t x; x = E1000_READ_REG(a, STATUS);}
 
+uint32_t
+e1000_io_read(struct e1000_hw *hw __unused, uint32_t port)
+{
+        return inl(port);
+}
+
+void
+e1000_io_write(struct e1000_hw *hw __unused, uint32_t port, uint32_t value)
+{
+        outl(value, port);
+}
+
 static inline void e1000_pci_set_mwi(struct e1000_hw *hw)
 {
 	pci_write_config_word(hw->pdev, PCI_COMMAND, hw->pci_cmd_word);
@@ -265,7 +289,8 @@
  * hw - Struct containing variables accessed by shared code
  *****************************************************************************/
 static uint16_t
-e1000_shift_in_ee_bits(struct e1000_hw *hw, uint16_t count)
+e1000_shift_in_ee_bits(struct e1000_hw *hw,
+                       uint16_t count)
 {
 	uint32_t eecd;
 	uint32_t i;
@@ -521,13 +546,17 @@
 	}
 
 	/*  Prepare the EEPROM for reading  */
-	if (e1000_acquire_eeprom(hw) != E1000_SUCCESS)
+	if(e1000_acquire_eeprom(hw) != E1000_SUCCESS)
 		return -E1000_ERR_EEPROM;
 
 	if(eeprom->type == e1000_eeprom_spi) {
+		uint16_t word_in;
 		uint8_t read_opcode = EEPROM_READ_OPCODE_SPI;
 
-		if(e1000_spi_eeprom_ready(hw)) return -E1000_ERR_EEPROM;
+		if(e1000_spi_eeprom_ready(hw)) {
+			e1000_release_eeprom(hw);
+			return -E1000_ERR_EEPROM;
+		}
 
 		e1000_standby_eeprom(hw);
 
@@ -538,30 +567,35 @@
 		/* Send the READ command (opcode + addr)  */
 		e1000_shift_out_ee_bits(hw, read_opcode, eeprom->opcode_bits);
 		e1000_shift_out_ee_bits(hw, (uint16_t)(offset*2), eeprom->address_bits);
-	}
-	else if(eeprom->type == e1000_eeprom_microwire) {
-		/*  Send the READ command (opcode + addr)  */
-		e1000_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
-					eeprom->opcode_bits);
-		e1000_shift_out_ee_bits(hw, offset, eeprom->address_bits);
-	}
 
-	/* Read the data.  The address of the eeprom internally increments with
-	 * each word (microwire) or byte (spi) being read, saving on the overhead
-	 * of eeprom setup and tear-down.  The address counter will roll over if
-	 * reading beyond the size of the eeprom, thus allowing the entire memory
-	 * to be read starting from any offset. */
-	for (i = 0; i < words; i++) {
-		uint16_t word_in = e1000_shift_in_ee_bits(hw, 16);
-		if (eeprom->type == e1000_eeprom_spi)
-			word_in = (word_in >> 8) | (word_in << 8);
-		data[i] = word_in;
+		/* Read the data.  The address of the eeprom internally increments with
+		 * each byte (spi) being read, saving on the overhead of eeprom setup
+		 * and tear-down.  The address counter will roll over if reading beyond
+		 * the size of the eeprom, thus allowing the entire memory to be read
+		 * starting from any offset. */
+		for (i = 0; i < words; i++) {
+			word_in = e1000_shift_in_ee_bits(hw, 16);
+			data[i] = (word_in >> 8) | (word_in << 8);
+		}
+	} else if(eeprom->type == e1000_eeprom_microwire) {
+		for (i = 0; i < words; i++) {
+			/*  Send the READ command (opcode + addr)  */
+			e1000_shift_out_ee_bits(hw, EEPROM_READ_OPCODE_MICROWIRE,
+						eeprom->opcode_bits);
+			e1000_shift_out_ee_bits(hw, (uint16_t)(offset + i),
+			                        eeprom->address_bits);
+
+			/* Read the data.  For microwire, each word requires the overhead
+			 * of eeprom setup and tear-down. */
+			data[i] = e1000_shift_in_ee_bits(hw, 16);
+			e1000_standby_eeprom(hw);
+		}
 	}
 
 	/* End this read operation */
 	e1000_release_eeprom(hw);
 
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -589,9 +623,9 @@
 		checksum += eeprom_data;
 	}
 	
-	if(checksum == (uint16_t) EEPROM_SUM) {
-		return 0;
-	} else {
+	if(checksum == (uint16_t) EEPROM_SUM)
+		return E1000_SUCCESS;
+	else {
 		DEBUGOUT("EEPROM Checksum Invalid\n");    
 		return -E1000_ERR_EEPROM;
 	}
@@ -621,12 +655,11 @@
 		hw->mac_addr[i] = eeprom_data & 0xff;
 		hw->mac_addr[i+1] = (eeprom_data >> 8) & 0xff;
 	}
-	if((hw->mac_type == e1000_82546) &&
-		(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1)) {
+	if(((hw->mac_type == e1000_82546) || (hw->mac_type == e1000_82546_rev_3)) &&
+		(E1000_READ_REG(hw, STATUS) & E1000_STATUS_FUNC_1))
 		/* Invert the last bit if this is the second device */
 		hw->mac_addr[5] ^= 1;
-	}
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -682,6 +715,19 @@
 }
 
 /******************************************************************************
+* Writes a value to one of the devices registers using port I/O (as opposed to
+* memory mapped I/O). Only 82544 and newer devices support port I/O. *
+* hw - Struct containing variables accessed by shared code
+* offset - offset to write to * value - value to write
+*****************************************************************************/
+void e1000_write_reg_io(struct e1000_hw *hw, uint32_t offset, uint32_t value){
+	uint32_t io_addr = hw->io_base;
+	uint32_t io_data = hw->io_base + 4;
+	e1000_io_write(hw, io_addr, offset);
+	e1000_io_write(hw, io_data, value);
+}
+
+/******************************************************************************
  * Set the phy type member in the hw struct.
  *
  * hw - Struct containing variables accessed by shared code
@@ -719,51 +765,50 @@
 {
 	DEBUGFUNC("e1000_phy_init_script");
 
+#if 0
+	/* See e1000_sw_init() of the Linux driver */
 	if(hw->phy_init_script) {
-		mdelay(10);
+#else
+	if((hw->mac_type == e1000_82541) ||
+	   (hw->mac_type == e1000_82547) ||
+	   (hw->mac_type == e1000_82541_rev_2) ||
+	   (hw->mac_type == e1000_82547_rev_2)) {
+#endif
+		mdelay(20);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
 		e1000_write_phy_reg(hw,0x0000,0x0140);
 
 		mdelay(5);
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F95);
-		e1000_write_phy_reg(hw,0x0015,0x0001);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F71);
-		e1000_write_phy_reg(hw,0x0011,0xBD21);
+		if(hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547) {
+			e1000_write_phy_reg(hw, 0x1F95, 0x0001);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F79);
-		e1000_write_phy_reg(hw,0x0019,0x0018);
+			e1000_write_phy_reg(hw, 0x1F71, 0xBD21);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F30);
-		e1000_write_phy_reg(hw,0x0010,0x1600);
+			e1000_write_phy_reg(hw, 0x1F79, 0x0018);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F31);
-		e1000_write_phy_reg(hw,0x0011,0x0014);
+			e1000_write_phy_reg(hw, 0x1F30, 0x1600);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F32);
-		e1000_write_phy_reg(hw,0x0012,0x161C);
+			e1000_write_phy_reg(hw, 0x1F31, 0x0014);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F94);
-		e1000_write_phy_reg(hw,0x0014,0x0003);
+			e1000_write_phy_reg(hw, 0x1F32, 0x161C);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x1F96);
-		e1000_write_phy_reg(hw,0x0016,0x003F);
+			e1000_write_phy_reg(hw, 0x1F94, 0x0003);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x2010);
-		e1000_write_phy_reg(hw,0x0010,0x0008);
+			e1000_write_phy_reg(hw, 0x1F96, 0x003F);
 
-		e1000_write_phy_reg(hw,IGP01E1000_PHY_PAGE_SELECT,0x0000);
-		e1000_write_phy_reg(hw,0x0000,0x3300);
+			e1000_write_phy_reg(hw, 0x2010, 0x0008);
+		} else {
+			e1000_write_phy_reg(hw, 0x1F73, 0x0099);
+		}
+
+		e1000_write_phy_reg(hw, 0x0000, 0x3300);
 
 
 		if(hw->mac_type == e1000_82547) {
 			uint16_t fused, fine, coarse;
 
 			/* Move to analog registers page */
-			e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
-					IGP01E1000_ANALOG_REGS_PAGE);
-
 			e1000_read_phy_reg(hw, IGP01E1000_ANALOG_SPARE_FUSE_STATUS, &fused);
 
 			if(!(fused & IGP01E1000_ANALOG_SPARE_FUSE_ENABLED)) {
@@ -786,9 +831,6 @@
 				e1000_write_phy_reg(hw, IGP01E1000_ANALOG_FUSE_BYPASS,
 						IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL);
 			}
-			/* Return to first page of registers */
-			e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT,
-					IGP01E1000_IEEE_REGS_PAGE);
 		}
 	}
 }
@@ -838,27 +880,83 @@
 	case E1000_DEV_ID_82545EM_FIBER:
 		hw->mac_type = e1000_82545;
 		break;
+	case E1000_DEV_ID_82545GM_COPPER:
+	case E1000_DEV_ID_82545GM_FIBER:
+	case E1000_DEV_ID_82545GM_SERDES:
+		hw->mac_type = e1000_82545_rev_3;
+		break;
 	case E1000_DEV_ID_82546EB_COPPER:
 	case E1000_DEV_ID_82546EB_FIBER:
 	case E1000_DEV_ID_82546EB_QUAD_COPPER:
 		hw->mac_type = e1000_82546;
 		break;
+	case E1000_DEV_ID_82546GB_COPPER:
+	case E1000_DEV_ID_82546GB_FIBER:
+	case E1000_DEV_ID_82546GB_SERDES:
+		hw->mac_type = e1000_82546_rev_3;
+		break;
 	case E1000_DEV_ID_82541EI:
-	case E1000_DEV_ID_82541EP:
+	case E1000_DEV_ID_82541EI_MOBILE:
 		hw->mac_type = e1000_82541;
 		break;
+	case E1000_DEV_ID_82541ER:
+	case E1000_DEV_ID_82541GI:
+	case E1000_DEV_ID_82541GI_MOBILE:
+		hw->mac_type = e1000_82541_rev_2;
+		break;
 	case E1000_DEV_ID_82547EI:
 		hw->mac_type = e1000_82547;
 		break;
+	case E1000_DEV_ID_82547GI:
+		hw->mac_type = e1000_82547_rev_2;
+		break;
 	default:
 		/* Should never have loaded on this device */
 		return -E1000_ERR_MAC_TYPE;
 	}
 
-
 	return E1000_SUCCESS;
 }
 
+/*****************************************************************************
+ * Set media type and TBI compatibility.
+ *
+ * hw - Struct containing variables accessed by shared code
+ * **************************************************************************/
+static void
+e1000_set_media_type(struct e1000_hw *hw)
+{
+	uint32_t status;
+
+	DEBUGFUNC("e1000_set_media_type");
+	
+	if(hw->mac_type != e1000_82543) {
+		/* tbi_compatibility is only valid on 82543 */
+		hw->tbi_compatibility_en = FALSE;
+	}
+
+	switch (hw->device_id) {
+		case E1000_DEV_ID_82545GM_SERDES:
+		case E1000_DEV_ID_82546GB_SERDES:
+			hw->media_type = e1000_media_type_internal_serdes;
+			break;
+		default:
+			if(hw->mac_type >= e1000_82543) {
+				status = E1000_READ_REG(hw, STATUS);
+				if(status & E1000_STATUS_TBIMODE) {
+					hw->media_type = e1000_media_type_fiber;
+					/* tbi_compatibility not valid on fiber */
+					hw->tbi_compatibility_en = FALSE;
+				} else {
+					hw->media_type = e1000_media_type_copper;
+				}
+			} else {
+				/* This is an 82542 (fiber only) */
+				hw->media_type = e1000_media_type_fiber;
+			}
+	}
+}
+
 /******************************************************************************
  * Reset the transmit and receive units; mask and clear all interrupts.
  *
@@ -900,57 +998,75 @@
 	 */ 
 	mdelay(10);
 
-	/* Issue a global reset to the MAC.  This will reset the chip's
-	 * transmit, receive, DMA, and link units.  It will not effect
-	 * the current PCI configuration.  The global reset bit is self-
-	 * clearing, and should clear within a microsecond.
-	 */
-	DEBUGOUT("Issuing a global reset to MAC\n");
 	ctrl = E1000_READ_REG(hw, CTRL);
 
 	/* Must reset the PHY before resetting the MAC */
 	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
-#ifdef PORT_IO_AND_MEMORY_IO_DIFFER
 		E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
-#else
-		E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_PHY_RST));
-#endif
 		mdelay(5);
 	}
 
-#ifdef PORT_IO_AND_MEMORY_IO_DIFFER
+	/* Issue a global reset to the MAC.  This will reset the chip's
+	 * transmit, receive, DMA, and link units.  It will not effect
+	 * the current PCI configuration.  The global reset bit is self-
+	 * clearing, and should clear within a microsecond.
+	 */
+	DEBUGOUT("Issuing a global reset to MAC\n");
+
 	switch(hw->mac_type) {
 		case e1000_82544:
 		case e1000_82540:
 		case e1000_82545:
 		case e1000_82546:
 		case e1000_82541:
+		case e1000_82541_rev_2:
 			/* These controllers can't ack the 64-bit write when issuing the
 			 * reset, so use IO-mapping as a workaround to issue the reset */
 			E1000_WRITE_REG_IO(hw, CTRL, (ctrl | E1000_CTRL_RST));
 			break;
+		case e1000_82545_rev_3:
+		case e1000_82546_rev_3:
+			/* Reset is performed on a shadow of the control register */
+			E1000_WRITE_REG(hw, CTRL_DUP, (ctrl | E1000_CTRL_RST));
+			break;
 		default:
-#endif
 			E1000_WRITE_REG(hw, CTRL, (ctrl | E1000_CTRL_RST));
-#ifdef PORT_IO_AND_MEMORY_IO_DIFFER
 			break;
 	}
-#endif
 
-	/* Force a reload from the EEPROM if necessary */
-	if(hw->mac_type < e1000_82540) {
-		/* Wait for reset to complete */
-		udelay(10);
-		ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
-		ctrl_ext |= E1000_CTRL_EXT_EE_RST;
-		E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
-		E1000_WRITE_FLUSH(hw);
-		/* Wait for EEPROM reload */
-		mdelay(2);
-	} else {
-		/* Wait for EEPROM reload (it happens automatically) */
-		mdelay(5);
-		/* Dissable HW ARPs on ASF enabled adapters */
+	/* After MAC reset, force reload of EEPROM to restore power-on settings to
+	 * device.  Later controllers reload the EEPROM automatically, so just wait
+	 * for reload to complete.
+	 */
+	switch(hw->mac_type) {
+		case e1000_82542_rev2_0:
+		case e1000_82542_rev2_1:
+		case e1000_82543:
+		case e1000_82544:
+			/* Wait for reset to complete */
+			udelay(10);
+			ctrl_ext = E1000_READ_REG(hw, CTRL_EXT);
+			ctrl_ext |= E1000_CTRL_EXT_EE_RST;
+			E1000_WRITE_REG(hw, CTRL_EXT, ctrl_ext);
+			E1000_WRITE_FLUSH(hw);
+			/* Wait for EEPROM reload */
+			mdelay(2);
+			break;
+		case e1000_82541:
+		case e1000_82541_rev_2:
+		case e1000_82547:
+		case e1000_82547_rev_2:
+			/* Wait for EEPROM reload */
+			mdelay(20);
+			break;
+		default:
+			/* Wait for EEPROM reload (it happens automatically) */
+			mdelay(5);
+			break;
+	}
+
+	/* Disable HW ARPs on ASF enabled adapters */
+	if(hw->mac_type >= e1000_82540) {
 		manc = E1000_READ_REG(hw, MANC);
 		manc &= ~(E1000_MANC_ARP_EN);
 		E1000_WRITE_REG(hw, MANC, manc);
@@ -1001,35 +1117,9 @@
 
 	DEBUGFUNC("e1000_init_hw");
 
-#if 0
-	/* Initialize Identification LED */
-	ret_val = e1000_id_led_init(hw);
-	if(ret_val < 0) {
-		DEBUGOUT("Error Initializing Identification LED\n");
-		return ret_val;
-	}
-#endif
-	
-	/* Set the Media Type and exit with error if it is not valid. */
-	if(hw->mac_type != e1000_82543) {
-		/* tbi_compatibility is only valid on 82543 */
-		hw->tbi_compatibility_en = FALSE;
-	}
-	
-	if(hw->mac_type >= e1000_82543) {
-		status = E1000_READ_REG(hw, STATUS);
-		if(status & E1000_STATUS_TBIMODE) {
-			hw->media_type = e1000_media_type_fiber;
-			/* tbi_compatibility not valid on fiber */
-			hw->tbi_compatibility_en = FALSE;
-		} else {
-			hw->media_type = e1000_media_type_copper;
-		}
-	} else {
-		/* This is an 82542 (fiber only) */
-		hw->media_type = e1000_media_type_fiber;
-	}
-	
+	/* Set the media type and TBI compatibility */
+	e1000_set_media_type(hw);
+
 	/* Disabling VLAN filtering. */
 	DEBUGOUT("Initializing the IEEE VLAN\n");
 	E1000_WRITE_REG(hw, VET, 0);
@@ -1076,29 +1166,38 @@
 		E1000_WRITE_REG(hw, CTRL, ctrl | E1000_CTRL_PRIOR);
 	}
 #endif
-	if (hw->mac_type >= e1000_82543) {
-		status = E1000_READ_REG(hw, STATUS);
-		bus_type = (status & E1000_STATUS_PCIX_MODE) ?
-			e1000_bus_type_pcix : e1000_bus_type_pci;
-	}
-	
-	/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
-	if(bus_type == e1000_bus_type_pcix) {
-		pci_read_config_word(hw->pdev, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
-		pci_read_config_word(hw->pdev, PCIX_STATUS_REGISTER_HI, &pcix_stat_hi_word);
-		cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
-			PCIX_COMMAND_MMRBC_SHIFT;
-		stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
-			PCIX_STATUS_HI_MMRBC_SHIFT;
-		if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
-			stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
-		if(cmd_mmrbc > stat_mmrbc) {
-			pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
-			pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
-			pci_write_config_word(hw->pdev, PCIX_COMMAND_REGISTER, pcix_cmd_word);
-		}
+
+	switch(hw->mac_type) {
+		case e1000_82545_rev_3:
+		case e1000_82546_rev_3:
+			break;
+		default:
+			if (hw->mac_type >= e1000_82543) {
+				/* See e1000_get_bus_info() of the Linux driver */
+				status = E1000_READ_REG(hw, STATUS);
+				bus_type = (status & E1000_STATUS_PCIX_MODE) ?
+					e1000_bus_type_pcix : e1000_bus_type_pci;
+			}
+
+			/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */
+			if(bus_type == e1000_bus_type_pcix) {
+				pci_read_config_word(hw->pdev, PCIX_COMMAND_REGISTER, &pcix_cmd_word);
+				pci_read_config_word(hw->pdev, PCIX_STATUS_REGISTER_HI, &pcix_stat_hi_word);
+				cmd_mmrbc = (pcix_cmd_word & PCIX_COMMAND_MMRBC_MASK) >>
+					PCIX_COMMAND_MMRBC_SHIFT;
+				stat_mmrbc = (pcix_stat_hi_word & PCIX_STATUS_HI_MMRBC_MASK) >>
+					PCIX_STATUS_HI_MMRBC_SHIFT;
+				if(stat_mmrbc == PCIX_STATUS_HI_MMRBC_4K)
+					stat_mmrbc = PCIX_STATUS_HI_MMRBC_2K;
+				if(cmd_mmrbc > stat_mmrbc) {
+					pcix_cmd_word &= ~PCIX_COMMAND_MMRBC_MASK;
+					pcix_cmd_word |= stat_mmrbc << PCIX_COMMAND_MMRBC_SHIFT;
+					pci_write_config_word(hw->pdev, PCIX_COMMAND_REGISTER, pcix_cmd_word);
+				}
+			}
+			break;
 	}
-	
+
 	/* Call a subroutine to configure the link and setup flow control. */
 	ret_val = e1000_setup_link(hw);
 	
@@ -1108,6 +1207,7 @@
 		ctrl = (ctrl & ~E1000_TXDCTL_WTHRESH) | E1000_TXDCTL_FULL_TX_DESC_WB;
 		E1000_WRITE_REG(hw, TXDCTL, ctrl);
 	}
+
 #if 0
 	/* Clear all of the statistics registers (clear on read).  It is
 	 * important that we do this after we have tried to establish link
@@ -1121,6 +1221,46 @@
 }
 
 /******************************************************************************
+ * Adjust SERDES output amplitude based on EEPROM setting.
+ *
+ * hw - Struct containing variables accessed by shared code.
+ *****************************************************************************/
+static int32_t
+e1000_adjust_serdes_amplitude(struct e1000_hw *hw)
+{
+	uint16_t eeprom_data;
+	int32_t  ret_val;
+
+	DEBUGFUNC("e1000_adjust_serdes_amplitude");
+
+	if(hw->media_type != e1000_media_type_internal_serdes)
+		return E1000_SUCCESS;
+
+	switch(hw->mac_type) {
+		case e1000_82545_rev_3:
+		case e1000_82546_rev_3:
+			break;
+		default:
+			return E1000_SUCCESS;
+	}
+
+	if ((ret_val = e1000_read_eeprom(hw, EEPROM_SERDES_AMPLITUDE, 1,
+					&eeprom_data))) {
+		return ret_val;
+	}
+
+	if(eeprom_data != EEPROM_RESERVED_WORD) {
+		/* Adjust SERDES output amplitude only. */
+		eeprom_data &= EEPROM_SERDES_AMPLITUDE_MASK;
+		if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_EXT_CTRL,
+		                                  eeprom_data)))
+			return ret_val;
+	}
+
+	return E1000_SUCCESS;
+}
+								   
+/******************************************************************************
  * Configures flow control and link settings.
  * 
  * hw - Struct containing variables accessed by shared code
@@ -1169,12 +1309,19 @@
 	 */
 	if(hw->mac_type == e1000_82542_rev2_0)
 		hw->fc &= (~e1000_fc_tx_pause);
-	
+
+#if 0
+	/* See e1000_sw_init() of the Linux driver */
 	if((hw->mac_type < e1000_82543) && (hw->report_tx_early == 1))
+#else
+	if((hw->mac_type < e1000_82543) && (hw->mac_type >= e1000_82543))
+#endif
 		hw->fc &= (~e1000_fc_rx_pause);
 	
+#if 0
 	hw->original_fc = hw->fc;
-	
+#endif
+
 	DEBUGOUT1("After fix-ups FlowControl is now = %x\n", hw->fc);
 	
 	/* Take the 4 bits from EEPROM word 0x0F that determine the initial
@@ -1191,9 +1338,9 @@
 	}
 	
 	/* Call the necessary subroutine to configure the link. */
-	ret_val = (hw->media_type == e1000_media_type_fiber) ?
-		e1000_setup_fiber_link(hw) :
-		e1000_setup_copper_link(hw);
+	ret_val = (hw->media_type == e1000_media_type_copper) ?
+		e1000_setup_copper_link(hw) :
+		e1000_setup_fiber_serdes_link(hw);
 	if (ret_val < 0) {
 		return ret_val;
 	}
@@ -1208,7 +1355,11 @@
 	E1000_WRITE_REG(hw, FCAL, FLOW_CONTROL_ADDRESS_LOW);
 	E1000_WRITE_REG(hw, FCAH, FLOW_CONTROL_ADDRESS_HIGH);
 	E1000_WRITE_REG(hw, FCT, FLOW_CONTROL_TYPE);
+#if 0
 	E1000_WRITE_REG(hw, FCTTV, hw->fc_pause_time);
+#else
+	E1000_WRITE_REG(hw, FCTTV, FC_DEFAULT_TX_TIMER);
+#endif
 	
 	/* Set the flow control receive threshold registers.  Normally,
 	 * these registers will be set to a default threshold that may be
@@ -1223,6 +1374,7 @@
 		/* We need to set up the Receive Threshold high and low water marks
 		 * as well as (optionally) enabling the transmission of XON frames.
 		 */
+#if 0
 		if(hw->fc_send_xon) {
 			E1000_WRITE_REG(hw, FCRTL, (hw->fc_low_water | E1000_FCRTL_XONE));
 			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
@@ -1230,12 +1382,16 @@
 			E1000_WRITE_REG(hw, FCRTL, hw->fc_low_water);
 			E1000_WRITE_REG(hw, FCRTH, hw->fc_high_water);
 		}
+#else
+		E1000_WRITE_REG(hw, FCRTL, (FC_DEFAULT_LO_THRESH | E1000_FCRTL_XONE));
+		E1000_WRITE_REG(hw, FCRTH, FC_DEFAULT_HI_THRESH);
+#endif
 	}
 	return ret_val;
 }
 
 /******************************************************************************
- * Sets up link for a fiber based adapter
+ * Sets up link for a fiber based or serdes based adapter
  *
  * hw - Struct containing variables accessed by shared code
  *
@@ -1244,28 +1400,39 @@
  * and receiver are not enabled.
  *****************************************************************************/
 static int
-e1000_setup_fiber_link(struct e1000_hw *hw)
+e1000_setup_fiber_serdes_link(struct e1000_hw *hw)
 {
 	uint32_t ctrl;
 	uint32_t status;
 	uint32_t txcw = 0;
 	uint32_t i;
-	uint32_t signal;
+	uint32_t signal = 0;
 	int32_t ret_val;
 
-	DEBUGFUNC("e1000_setup_fiber_link");
+	DEBUGFUNC("e1000_setup_fiber_serdes_link");
 
-	/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
+	/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be 
 	 * set when the optics detect a signal. On older adapters, it will be 
-	 * cleared when there is a signal
+	 * cleared when there is a signal.  This applies to fiber media only.
+	 * If we're on serdes media, adjust the output amplitude to value set in
+	 * the EEPROM.
 	 */
 	ctrl = E1000_READ_REG(hw, CTRL);
-	if(hw->mac_type > e1000_82544) signal = E1000_CTRL_SWDPIN1;
-	else signal = 0;
-	
+	if(hw->media_type == e1000_media_type_fiber)
+		signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
+
+	if((ret_val = e1000_adjust_serdes_amplitude(hw)))
+		return ret_val;
+
 	/* Take the link out of reset */
 	ctrl &= ~(E1000_CTRL_LRST);
-	
+
+#if 0
+	/* Adjust VCO speed to improve BER performance */
+	if((ret_val = e1000_set_vco_speed(hw)))
+		return ret_val;
+#endif
+
 	e1000_config_collision_dist(hw);
 	
 	/* Check for a software override of the flow control settings, and setup
@@ -1332,8 +1499,10 @@
 	 * indication in the Device Status Register.  Time-out if a link isn't 
 	 * seen in 500 milliseconds seconds (Auto-negotiation should complete in 
 	 * less than 500 milliseconds even if the other end is doing it in SW).
+	 * For internal serdes, we just assume a signal is present, then poll.
 	 */
-	if((E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
+	if(hw->media_type == e1000_media_type_internal_serdes ||
+	   (E1000_READ_REG(hw, CTRL) & E1000_CTRL_SWDPIN1) == signal) {
 		DEBUGOUT("Looking for Link\n");
 		for(i = 0; i < (LINK_UP_TIMEOUT / 10); i++) {
 			mdelay(10);
@@ -1341,15 +1510,14 @@
 			if(status & E1000_STATUS_LU) break;
 		}
 		if(i == (LINK_UP_TIMEOUT / 10)) {
+			DEBUGOUT("Never got a valid link from auto-neg!!!\n");
+			hw->autoneg_failed = 1;
 			/* AutoNeg failed to achieve a link, so we'll call 
-			 * e1000_check_for_link. This routine will force the link up if we
-			 * detect a signal. This will allow us to communicate with
+			 * e1000_check_for_link. This routine will force the link up if
+			 * we detect a signal. This will allow us to communicate with
 			 * non-autonegotiating link partners.
 			 */
-			DEBUGOUT("Never got a valid link from auto-neg!!!\n");
-			hw->autoneg_failed = 1;
-			ret_val = e1000_check_for_link(hw);
-			if(ret_val < 0) {
+			if((ret_val = e1000_check_for_link(hw))) {
 				DEBUGOUT("Error while checking for link\n");
 				return ret_val;
 			}
@@ -1361,7 +1529,7 @@
 	} else {
 		DEBUGOUT("No Signal Detected\n");
 	}
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -1395,17 +1563,25 @@
 	}
 	
 	/* Make sure we have a valid PHY */
-	ret_val = e1000_detect_gig_phy(hw);
-	if(ret_val < 0) {
+	if((ret_val = e1000_detect_gig_phy(hw))) {
 		DEBUGOUT("Error, did not detect valid phy.\n");
 		return ret_val;
 	}
 	DEBUGOUT1("Phy ID = %x \n", hw->phy_id);
 
+	if(hw->mac_type <= e1000_82543 ||
+	   hw->mac_type == e1000_82541 || hw->mac_type == e1000_82547 ||
+#if 0
+	   hw->mac_type == e1000_82541_rev_2 || hw->mac_type == e1000_82547_rev_2)
+		hw->phy_reset_disable = FALSE;
+
+	if(!hw->phy_reset_disable) {
+#else
+	   hw->mac_type == e1000_82541_rev_2 || hw->mac_type == e1000_82547_rev_2) {
+#endif
 	if (hw->phy_type == e1000_phy_igp) {
 
-		ret_val = e1000_phy_reset(hw);
-		if(ret_val < 0) {
+		if((ret_val = e1000_phy_reset(hw))) {
 			DEBUGOUT("Error Resetting the PHY\n");
 			return ret_val;
 		}
@@ -1413,58 +1589,146 @@
 		/* Wait 10ms for MAC to configure PHY from eeprom settings */
 		mdelay(15);
 
-		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
-			DEBUGOUT("PHY Write Error\n");
-			return -E1000_ERR_PHY;
+#if 0
+		/* disable lplu d3 during driver init */
+		if((ret_val = e1000_set_d3_lplu_state(hw, FALSE))) {
+			DEBUGOUT("Error Disabling LPLU D3\n");
+			return ret_val;
 		}
 
+		/* Configure mdi-mdix settings */
+		if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
+		if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
+			hw->dsp_config_state = e1000_dsp_config_disabled;
+			/* Force MDI for IGP B-0 PHY */
+			phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
+			              IGP01E1000_PSCR_FORCE_MDI_MDIX);
+			hw->mdix = 1;
+
+		} else {
+			hw->dsp_config_state = e1000_dsp_config_enabled;
+			phy_data &= ~IGP01E1000_PSCR_AUTO_MDIX;
+
+			switch (hw->mdix) {
+			case 1:
+				phy_data &= ~IGP01E1000_PSCR_FORCE_MDI_MDIX;
+				break;
+			case 2:
+				phy_data |= IGP01E1000_PSCR_FORCE_MDI_MDIX;
+				break;
+			case 0:
+			default:
+				phy_data |= IGP01E1000_PSCR_AUTO_MDIX;
+				break;
+			}
+		}
+		if((ret_val = e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL,
+		                                  phy_data)))
+			return ret_val;
+
+		/* set auto-master slave resolution settings */
+		e1000_ms_type phy_ms_setting = hw->master_slave;
+
+		if(hw->ffe_config_state == e1000_ffe_config_active)
+			hw->ffe_config_state = e1000_ffe_config_enabled;
+
+		if(hw->dsp_config_state == e1000_dsp_config_activated)
+			hw->dsp_config_state = e1000_dsp_config_enabled;
+#endif
+
+		/* when autonegotiation advertisment is only 1000Mbps then we
+		 * should disable SmartSpeed and enable Auto MasterSlave
+		 * resolution as hardware default. */
 		if(hw->autoneg_advertised == ADVERTISE_1000_FULL) {
 			/* Disable SmartSpeed */
-			if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
-						&phy_data) < 0) {
-				DEBUGOUT("PHY Read Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_read_phy_reg(hw,
+			                                 IGP01E1000_PHY_PORT_CONFIG,
+			                                 &phy_data)))
+				return ret_val;
 			phy_data &= ~IGP01E1000_PSCFR_SMART_SPEED;
-			if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CONFIG,
-						phy_data) < 0) {
-				DEBUGOUT("PHY Write Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_write_phy_reg(hw,
+			                                  IGP01E1000_PHY_PORT_CONFIG,
+			                                  phy_data)))
+				return ret_val;
 			/* Set auto Master/Slave resolution process */
-			if(e1000_read_phy_reg(hw, PHY_1000T_CTRL, &phy_data) < 0) {
-				DEBUGOUT("PHY Read Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL,
+			                                 &phy_data)))
+				return ret_val;
 			phy_data &= ~CR_1000T_MS_ENABLE;
-			if(e1000_write_phy_reg(hw, PHY_1000T_CTRL, phy_data) < 0) {
-				DEBUGOUT("PHY Write Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
+			                                  phy_data)))
+				return ret_val;
 		}
 
-		if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL,
+		                                 &phy_data)))
+			return ret_val;
 
-		/* Force MDI for IGP PHY */
-		phy_data &= ~(IGP01E1000_PSCR_AUTO_MDIX |
-			      IGP01E1000_PSCR_FORCE_MDI_MDIX);
+#if 0
+		/* load defaults for future use */
+		hw->original_master_slave = (phy_data & CR_1000T_MS_ENABLE) ?
+		                            ((phy_data & CR_1000T_MS_VALUE) ?
+		                             e1000_ms_force_master :
+		                             e1000_ms_force_slave) :
+		                             e1000_ms_auto;
 
-		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PORT_CTRL, phy_data) < 0) {
-			DEBUGOUT("PHY Write Error\n");
-			return -E1000_ERR_PHY;
+		switch (phy_ms_setting) {
+		case e1000_ms_force_master:
+			phy_data |= (CR_1000T_MS_ENABLE | CR_1000T_MS_VALUE);
+			break;
+		case e1000_ms_force_slave:
+			phy_data |= CR_1000T_MS_ENABLE;
+			phy_data &= ~(CR_1000T_MS_VALUE);
+			break;
+		case e1000_ms_auto:
+			phy_data &= ~CR_1000T_MS_ENABLE;
+		default:
+			break;
 		}
+#endif
 
+		if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL,
+		                                  phy_data)))
+			return ret_val;
 	} else {
 		/* Enable CRS on TX. This must be set for half-duplex operation. */
-		if(e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
 		phy_data |= M88E1000_PSCR_ASSERT_CRS_ON_TX;
-		phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+
+		/* Options:
+		 *   MDI/MDI-X = 0 (default)
+		 *   0 - Auto for all speeds
+		 *   1 - MDI mode
+		 *   2 - MDI-X mode
+		 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)
+		 */
+#if 0
+		phy_data &= ~M88E1000_PSCR_AUTO_X_MODE;
+
+		switch (hw->mdix) {
+		case 1:
+			phy_data |= M88E1000_PSCR_MDI_MANUAL_MODE;
+			break;
+		case 2:
+			phy_data |= M88E1000_PSCR_MDIX_MANUAL_MODE;
+			break;
+		case 3:
+			phy_data |= M88E1000_PSCR_AUTO_X_1000T;
+			break;
+		case 0:
+		default:
+#endif
+			phy_data |= M88E1000_PSCR_AUTO_X_MODE;
+#if 0
+			break;
+		}
+#endif
 
 		/* Options:
 		 *   disable_polarity_correction = 0 (default)
@@ -1473,18 +1737,17 @@
 		 *   1 - Enabled
 		 */
 		phy_data &= ~M88E1000_PSCR_POLARITY_REVERSAL;
-		if(e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, phy_data) < 0) {
-			DEBUGOUT("PHY Write Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL,
+		                                  phy_data)))
+			return ret_val;
 
 		/* Force TX_CLK in the Extended PHY Specific Control Register
 		 * to 25MHz clock.
 		 */
-		if(e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
+		                                 &phy_data)))
+			return ret_val;
+
 		phy_data |= M88E1000_EPSCR_TX_CLK_25;
 
 #ifdef LINUX_DRIVER
@@ -1495,16 +1758,14 @@
 				M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK);
 			phy_data |= (M88E1000_EPSCR_MASTER_DOWNSHIFT_1X |
 				M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X);
-			if(e1000_write_phy_reg(hw, M88E1000_EXT_PHY_SPEC_CTRL,
-					       phy_data) < 0) {
-				DEBUGOUT("PHY Write Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_write_phy_reg(hw,
+			                                  M88E1000_EXT_PHY_SPEC_CTRL,
+			                                  phy_data)))
+				return ret_val;
 		}
 	
 		/* SW Reset the PHY so all changes take effect */
-		ret_val = e1000_phy_reset(hw);
-		if(ret_val < 0) {
+		if((ret_val = e1000_phy_reset(hw))) {
 			DEBUGOUT("Error Resetting the PHY\n");
 			return ret_val;
 #ifdef LINUX_DRIVER
@@ -1521,11 +1782,11 @@
 	 *      depending on value parsed from forced_speed_duplex.
 	 */
 	
-	/* Is autoneg enabled?  This is enabled by default or by software override.
-	 * If so, call e1000_phy_setup_autoneg routine to parse the
-	 * autoneg_advertised and fc options. If autoneg is NOT enabled, then the
-	 * user should have provided a speed/duplex override.  If so, then call
-	 * e1000_phy_force_speed_duplex to parse and set this up.
+	/* Is autoneg enabled?  This is enabled by default or by software
+	 * override.  If so, call e1000_phy_setup_autoneg routine to parse the
+	 * autoneg_advertised and fc options. If autoneg is NOT enabled, then
+	 * the user should have provided a speed/duplex override.  If so, then
+	 * call e1000_phy_force_speed_duplex to parse and set this up.
 	 */
 	/* Perform some bounds checking on the hw->autoneg_advertised
 	 * parameter.  If this variable is zero, then set it to the default.
@@ -1539,8 +1800,7 @@
 		hw->autoneg_advertised = AUTONEG_ADVERTISE_SPEED_DEFAULT;
 	
 	DEBUGOUT("Reconfiguring auto-neg advertisement params\n");
-	ret_val = e1000_phy_setup_autoneg(hw);
-	if(ret_val < 0) {
+	if((ret_val = e1000_phy_setup_autoneg(hw))) {
 		DEBUGOUT("Error Setting up Auto-Negotiation\n");
 		return ret_val;
 	}
@@ -1549,23 +1809,19 @@
 	/* Restart auto-negotiation by setting the Auto Neg Enable bit and
 	 * the Auto Neg Restart bit in the PHY control register.
 	 */
-	if(e1000_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
-		DEBUGOUT("PHY Read Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data)))
+		return ret_val;
+
 	phy_data |= (MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG);
-	if(e1000_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
-		DEBUGOUT("PHY Write Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data)))
+		return ret_val;
 
 #if 0	
 	/* Does the user want to wait for Auto-Neg to complete here, or
 	 * check at a later time (for example, callback routine).
 	 */
 	if(hw->wait_autoneg_complete) {
-		ret_val = e1000_wait_autoneg(hw);
-		if(ret_val < 0) {
+		if((ret_val = e1000_wait_autoneg(hw))) {
 			DEBUGOUT("Error while waiting for autoneg to complete\n");
 			return ret_val;
 		}
@@ -1574,25 +1830,22 @@
 	/* If we do not wait for autonegotiation to complete I 
 	 * do not see a valid link status.
 	 */
-	ret_val = e1000_wait_autoneg(hw);
-	if(ret_val < 0) {
+	if((ret_val = e1000_wait_autoneg(hw))) {
 		DEBUGOUT("Error while waiting for autoneg to complete\n");
 		return ret_val;
 	}
 #endif
+	} /* !hw->phy_reset_disable */
 	
 	/* Check link status. Wait up to 100 microseconds for link to become
 	 * valid.
 	 */
 	for(i = 0; i < 10; i++) {
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+
 		if(phy_data & MII_SR_LINK_STATUS) {
 			/* We have link, so we need to finish the config process:
 			 *   1) Set up the MAC to the current PHY speed/duplex
@@ -1605,19 +1858,25 @@
 			if(hw->mac_type >= e1000_82544) {
 				e1000_config_collision_dist(hw);
 			} else {
-				ret_val = e1000_config_mac_to_phy(hw);
-				if(ret_val < 0) {
+				if((ret_val = e1000_config_mac_to_phy(hw))) {
 					DEBUGOUT("Error configuring MAC to PHY settings\n");
 					return ret_val;
 				}
 			}
-			ret_val = e1000_config_fc_after_link_up(hw);
-			if(ret_val < 0) {
+			if((ret_val = e1000_config_fc_after_link_up(hw))) {
 				DEBUGOUT("Error Configuring Flow Control\n");
 				return ret_val;
 			}
+#if 0
+			if(hw->phy_type == e1000_phy_igp) {
+				if((ret_val = e1000_config_dsp_after_link_change(hw, TRUE))) {
+					DEBUGOUT("Error Configuring DSP after link up\n");
+					return ret_val;
+				}
+			}
+#endif
 			DEBUGOUT("Valid link established!!!\n");
-			return 0;
+			return E1000_SUCCESS;
 		}
 		udelay(10);
 	}
@@ -1634,22 +1893,20 @@
 static int
 e1000_phy_setup_autoneg(struct e1000_hw *hw)
 {
+	int32_t ret_val;
 	uint16_t mii_autoneg_adv_reg;
 	uint16_t mii_1000t_ctrl_reg;
 
 	DEBUGFUNC("e1000_phy_setup_autoneg");
 	
 	/* Read the MII Auto-Neg Advertisement Register (Address 4). */
-	if(e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_autoneg_adv_reg) < 0) {
-		DEBUGOUT("PHY Read Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
+	                                 &mii_autoneg_adv_reg)))
+		return ret_val;
 
 	/* Read the MII 1000Base-T Control Register (Address 9). */
-	if(e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg) < 0) {
-		DEBUGOUT("PHY Read Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_read_phy_reg(hw, PHY_1000T_CTRL, &mii_1000t_ctrl_reg)))
+		return ret_val;
 
 	/* Need to parse both autoneg_advertised and fc and set up
 	 * the appropriate PHY registers.  First we will parse for
@@ -1755,18 +2012,16 @@
 		return -E1000_ERR_CONFIG;
 	}
 
-	if(e1000_write_phy_reg(hw, PHY_AUTONEG_ADV, mii_autoneg_adv_reg) < 0) {
-		DEBUGOUT("PHY Write Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_write_phy_reg(hw, PHY_AUTONEG_ADV,
+	                       mii_autoneg_adv_reg)))
+		return ret_val;
 
 	DEBUGOUT1("Auto-Neg Advertising %x\n", mii_autoneg_adv_reg);
 
-	if(e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg) < 0) {
-		DEBUGOUT("PHY Write Error\n");
-		return -E1000_ERR_PHY;
-	}
-	return 0;
+	if((ret_val = e1000_write_phy_reg(hw, PHY_1000T_CTRL, mii_1000t_ctrl_reg)))
+		return ret_val;
+
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -1804,6 +2059,7 @@
 e1000_config_mac_to_phy(struct e1000_hw *hw)
 {
 	uint32_t ctrl;
+	int32_t ret_val;
 	uint16_t phy_data;
 
 	DEBUGFUNC("e1000_config_mac_to_phy");
@@ -1819,10 +2075,10 @@
 	 * registers depending on negotiated values.
 	 */
 	if (hw->phy_type == e1000_phy_igp) {
-		if(e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, IGP01E1000_PHY_PORT_STATUS,
+		                                 &phy_data)))
+			return ret_val;
+
 		if(phy_data & IGP01E1000_PSSR_FULL_DUPLEX) ctrl |= E1000_CTRL_FD;
 		else ctrl &= ~E1000_CTRL_FD;
 
@@ -1838,10 +2094,10 @@
 			IGP01E1000_PSSR_SPEED_100MBPS)
 			ctrl |= E1000_CTRL_SPD_100;
 	} else {
-		if(e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, M88E1000_PHY_SPEC_STATUS,
+		                                 &phy_data)))
+			return ret_val;
+		
 		if(phy_data & M88E1000_PSSR_DPLX) ctrl |= E1000_CTRL_FD;
 		else ctrl &= ~E1000_CTRL_FD;
 
@@ -1857,7 +2113,7 @@
 	}
 	/* Write the configured values back to the Device Control Reg. */
 	E1000_WRITE_REG(hw, CTRL, ctrl);
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -1924,7 +2180,7 @@
 		ctrl &= (~E1000_CTRL_TFCE);
 	
 	E1000_WRITE_REG(hw, CTRL, ctrl);
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -1954,9 +2210,9 @@
 	 * so we had to force link.  In this case, we need to force the
 	 * configuration of the MAC to match the "fc" parameter.
 	 */
-	if((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) {
-		ret_val = e1000_force_mac_fc(hw);
-		if(ret_val < 0) {
+	if(((hw->media_type == e1000_media_type_fiber) && (hw->autoneg_failed)) ||
+	   ((hw->media_type == e1000_media_type_internal_serdes) && (hw->autoneg_failed))) { 
+		if((ret_val = e1000_force_mac_fc(hw))) {
 			DEBUGOUT("Error forcing flow control settings\n");
 			return ret_val;
 		}
@@ -1972,14 +2228,10 @@
 		 * has completed.  We read this twice because this reg has
 		 * some "sticky" (latched) bits.
 		 */
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
-			DEBUGOUT("PHY Read Error \n");
-			return -E1000_ERR_PHY;
-		}
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg) < 0) {
-			DEBUGOUT("PHY Read Error \n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &mii_status_reg)))
+			return ret_val;
 		
 		if(mii_status_reg & MII_SR_AUTONEG_COMPLETE) {
 			/* The AutoNeg process has completed, so we now need to
@@ -1988,14 +2240,12 @@
 			 * Register (Address 5) to determine how flow control was
 			 * negotiated.
 			 */
-			if(e1000_read_phy_reg(hw, PHY_AUTONEG_ADV, &mii_nway_adv_reg) < 0) {
-				DEBUGOUT("PHY Read Error\n");
-				return -E1000_ERR_PHY;
-			}
-			if(e1000_read_phy_reg(hw, PHY_LP_ABILITY, &mii_nway_lp_ability_reg) < 0) {
-				DEBUGOUT("PHY Read Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_read_phy_reg(hw, PHY_AUTONEG_ADV,
+			                                 &mii_nway_adv_reg)))
+				return ret_val;
+			if((ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
+			                                 &mii_nway_lp_ability_reg)))
+				return ret_val;
 
 			/* Two bits in the Auto Negotiation Advertisement Register
 			 * (Address 4) and two bits in the Auto Negotiation Base
@@ -2039,8 +2289,12 @@
 				 * ONLY. Hence, we must now check to see if we need to
 				 * turn OFF  the TRANSMISSION of PAUSE frames.
 				 */
+#if 0
 				if(hw->original_fc == e1000_fc_full) {
 					hw->fc = e1000_fc_full;
+#else
+				if(hw->fc == e1000_fc_full) {
+#endif
 					DEBUGOUT("Flow Control = FULL.\r\n");
 				} else {
 					hw->fc = e1000_fc_rx_pause;
@@ -2097,8 +2351,14 @@
 			 * be asked to delay transmission of packets than asking
 			 * our link partner to pause transmission of frames.
 			 */
+#if 0
 			else if(hw->original_fc == e1000_fc_none ||
 				hw->original_fc == e1000_fc_tx_pause) {
+#else
+			else if(hw->fc == e1000_fc_none)
+				DEBUGOUT("Flow Control = NONE.\r\n");
+			else if(hw->fc == e1000_fc_tx_pause) {
+#endif
 				hw->fc = e1000_fc_none;
 				DEBUGOUT("Flow Control = NONE.\r\n");
 			} else {
@@ -2118,8 +2378,7 @@
 			/* Now we call a subroutine to actually force the MAC
 			 * controller to use the correct flow control settings.
 			 */
-			ret_val = e1000_force_mac_fc(hw);
-			if(ret_val < 0) {
+			if((ret_val = e1000_force_mac_fc(hw))) {
 				DEBUGOUT("Error forcing flow control settings\n");
 				return ret_val;
 			}
@@ -2127,7 +2386,7 @@
 			DEBUGOUT("Copper PHY and Auto Neg has not completed.\r\n");
 		}
 	}
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -2144,20 +2403,20 @@
 	uint32_t ctrl;
 	uint32_t status;
 	uint32_t rctl;
-	uint32_t signal;
+	uint32_t signal = 0;
 	int32_t ret_val;
 	uint16_t phy_data;
 	uint16_t lp_capability;
 	
 	DEBUGFUNC("e1000_check_for_link");
 	
-	/* On adapters with a MAC newer that 82544, SW Defineable pin 1 will be 
+	/* On adapters with a MAC newer than 82544, SW Defineable pin 1 will be 
 	 * set when the optics detect a signal. On older adapters, it will be 
-	 * cleared when there is a signal
+	 * cleared when there is a signal.  This applies to fiber media only.
 	 */
-	if(hw->mac_type > e1000_82544) signal = E1000_CTRL_SWDPIN1;
-	else signal = 0;
-	
+	if(hw->media_type == e1000_media_type_fiber)
+		signal = (hw->mac_type > e1000_82544) ? E1000_CTRL_SWDPIN1 : 0;
+
 	ctrl = E1000_READ_REG(hw, CTRL);
 	status = E1000_READ_REG(hw, STATUS);
 	rxcw = E1000_READ_REG(hw, RXCW);
@@ -2168,23 +2427,25 @@
 	 * receive a Link Status Change interrupt or we have Rx Sequence
 	 * Errors.
 	 */
+#if 0
 	if((hw->media_type == e1000_media_type_copper) && hw->get_link_status) {
+#else
+	if(hw->media_type == e1000_media_type_copper) {
+#endif
 		/* First we want to see if the MII Status Register reports
 		 * link.  If so, then we want to get the current speed/duplex
 		 * of the PHY.
 		 * Read the register twice since the link bit is sticky.
 		 */
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
 		
 		if(phy_data & MII_SR_LINK_STATUS) {
+#if 0
 			hw->get_link_status = FALSE;
+#endif
 		} else {
 			/* No link detected */
 			return -E1000_ERR_NOLINK;
@@ -2201,8 +2462,7 @@
 		if(hw->mac_type >= e1000_82544)
 			e1000_config_collision_dist(hw);
 		else {
-			ret_val = e1000_config_mac_to_phy(hw);
-			if(ret_val < 0) {
+			if((ret_val = e1000_config_mac_to_phy(hw))) {
 				DEBUGOUT("Error configuring MAC to PHY settings\n");
 				return ret_val;
 			}
@@ -2212,8 +2472,7 @@
 		 * need to restore the desired flow control settings because we may
 		 * have had to re-autoneg with a different link partner.
 		 */
-		ret_val = e1000_config_fc_after_link_up(hw);
-		if(ret_val < 0) {
+		if((ret_val = e1000_config_fc_after_link_up(hw))) {
 			DEBUGOUT("Error configuring flow control\n");
 			return ret_val;
 		}
@@ -2228,10 +2487,9 @@
 		 * partner is TBI-based, and we turn on TBI Compatibility.
 		 */
 		if(hw->tbi_compatibility_en) {
-			if(e1000_read_phy_reg(hw, PHY_LP_ABILITY, &lp_capability) < 0) {
-				DEBUGOUT("PHY Read Error\n");
-				return -E1000_ERR_PHY;
-			}
+			if((ret_val = e1000_read_phy_reg(hw, PHY_LP_ABILITY,
+			                                 &lp_capability)))
+				return ret_val;
 			if(lp_capability & (NWAY_LPAR_10T_HD_CAPS |
                                 NWAY_LPAR_10T_FD_CAPS |
                                 NWAY_LPAR_100TX_HD_CAPS |
@@ -2269,9 +2527,10 @@
 	 * auto-negotiation time to complete, in case the cable was just plugged
 	 * in. The autoneg_failed flag does this.
 	 */
-	else if((hw->media_type == e1000_media_type_fiber) &&
+	else if((((hw->media_type == e1000_media_type_fiber) &&
+	        ((ctrl & E1000_CTRL_SWDPIN1) == signal)) ||
+	        (hw->media_type == e1000_media_type_internal_serdes)) &&
 		(!(status & E1000_STATUS_LU)) &&
-		((ctrl & E1000_CTRL_SWDPIN1) == signal) &&
 		(!(rxcw & E1000_RXCW_C))) {
 		if(hw->autoneg_failed == 0) {
 			hw->autoneg_failed = 1;
@@ -2288,8 +2547,7 @@
 		E1000_WRITE_REG(hw, CTRL, ctrl);
 		
 		/* Configure Flow Control after forcing link up. */
-		ret_val = e1000_config_fc_after_link_up(hw);
-		if(ret_val < 0) {
+		if((ret_val = e1000_config_fc_after_link_up(hw))) {
 			DEBUGOUT("Error configuring flow control\n");
 			return ret_val;
 		}
@@ -2299,14 +2557,34 @@
 	 * Device Control register in an attempt to auto-negotiate with our link
 	 * partner.
 	 */
-	else if((hw->media_type == e1000_media_type_fiber) &&
+	else if(((hw->media_type == e1000_media_type_fiber)  ||
+	         (hw->media_type == e1000_media_type_internal_serdes)) &&
 		(ctrl & E1000_CTRL_SLU) &&
 		(rxcw & E1000_RXCW_C)) {
 		DEBUGOUT("RXing /C/, enable AutoNeg and stop forcing link.\r\n");
 		E1000_WRITE_REG(hw, TXCW, hw->txcw);
 		E1000_WRITE_REG(hw, CTRL, (ctrl & ~E1000_CTRL_SLU));
 	}
-	return 0;
+#if 0
+	/* If we force link for non-auto-negotiation switch, check link status
+	 * based on MAC synchronization for internal serdes media type.
+	 */
+	else if((hw->media_type == e1000_media_type_internal_serdes) &&
+			!(E1000_TXCW_ANE & E1000_READ_REG(hw, TXCW))) {
+		/* SYNCH bit and IV bit are sticky. */
+		udelay(10);
+		if(E1000_RXCW_SYNCH & E1000_READ_REG(hw, RXCW)) {
+			if(!(rxcw & E1000_RXCW_IV)) {
+				hw->serdes_link_down = FALSE;
+				DEBUGOUT("SERDES: Link is up.\n");
+			}
+		} else {
+			hw->serdes_link_down = TRUE;
+			DEBUGOUT("SERDES: Link is down.\n");
+		}
+	}
+#endif
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -2360,6 +2638,7 @@
 static int
 e1000_wait_autoneg(struct e1000_hw *hw)
 {
+	int32_t ret_val;
 	uint16_t i;
 	uint16_t phy_data;
 	
@@ -2371,17 +2650,13 @@
 		/* Read the MII Status Register and wait for Auto-Neg
 		 * Complete bit to be set.
 		 */
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
-		if(e1000_read_phy_reg(hw, PHY_STATUS, &phy_data) < 0) {
-			DEBUGOUT("PHY Read Error\n");
-			return -E1000_ERR_PHY;
-		}
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
+		if((ret_val = e1000_read_phy_reg(hw, PHY_STATUS, &phy_data)))
+			return ret_val;
 		if(phy_data & MII_SR_AUTONEG_COMPLETE) {
 			DEBUGOUT("Auto-Neg complete.\n");
-			return 0;
+			return E1000_SUCCESS;
 		}
 		mdelay(100);
 	}
@@ -2400,11 +2675,11 @@
                     uint32_t *ctrl)
 {
 	/* Raise the clock input to the Management Data Clock (by setting the MDC
-	 * bit), and then delay 2 microseconds.
+	 * bit), and then delay 10 microseconds.
 	 */
 	E1000_WRITE_REG(hw, CTRL, (*ctrl | E1000_CTRL_MDC));
 	E1000_WRITE_FLUSH(hw);
-	udelay(2);
+	udelay(10);
 }
 
 /******************************************************************************
@@ -2418,11 +2693,11 @@
                     uint32_t *ctrl)
 {
 	/* Lower the clock input to the Management Data Clock (by clearing the MDC
-	 * bit), and then delay 2 microseconds.
+	 * bit), and then delay 10 microseconds.
 	 */
 	E1000_WRITE_REG(hw, CTRL, (*ctrl & ~E1000_CTRL_MDC));
 	E1000_WRITE_FLUSH(hw);
-	udelay(2);
+	udelay(10);
 }
 
 /******************************************************************************
@@ -2466,7 +2741,7 @@
 		E1000_WRITE_REG(hw, CTRL, ctrl);
 		E1000_WRITE_FLUSH(hw);
 		
-		udelay(2);
+		udelay(10);
 
 		e1000_raise_mdi_clk(hw, &ctrl);
 		e1000_lower_mdi_clk(hw, &ctrl);
@@ -2528,7 +2803,8 @@
 }
 
 /*****************************************************************************
-* Reads the value from a PHY register
+* Reads the value from a PHY register, if the value is on a specific non zero
+* page, sets the page first.
 *
 * hw - Struct containing variables accessed by shared code
 * reg_addr - address of the PHY register to read
@@ -2538,11 +2814,33 @@
                    uint32_t reg_addr,
                    uint16_t *phy_data)
 {
+	uint32_t ret_val;
+
+	DEBUGFUNC("e1000_read_phy_reg");
+
+	if(hw->phy_type == e1000_phy_igp &&
+	   (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
+		if((ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
+		                                     (uint16_t)reg_addr)))
+			return ret_val;
+	}
+
+	ret_val = e1000_read_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
+	                                phy_data);
+
+	return ret_val;
+}
+
+static int
+e1000_read_phy_reg_ex(struct e1000_hw *hw,
+                      uint32_t reg_addr,
+                      uint16_t *phy_data)
+{
 	uint32_t i;
 	uint32_t mdic = 0;
 	const uint32_t phy_addr = 1;
 
-	DEBUGFUNC("e1000_read_phy_reg");
+	DEBUGFUNC("e1000_read_phy_reg_ex");
 	
 	if(reg_addr > MAX_PHY_REG_ADDRESS) {
 		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
@@ -2562,7 +2860,7 @@
 
 		/* Poll the ready bit to see if the MDI read completed */
 		for(i = 0; i < 64; i++) {
-			udelay(10);
+			udelay(50);
 			mdic = E1000_READ_REG(hw, MDIC);
 			if(mdic & E1000_MDIC_READY) break;
 		}
@@ -2604,7 +2902,7 @@
 		 */
 		*phy_data = e1000_shift_in_mdi_bits(hw);
 	}
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -2619,11 +2917,33 @@
                     uint32_t reg_addr,
                     uint16_t phy_data)
 {
+	uint32_t ret_val;
+
+	DEBUGFUNC("e1000_write_phy_reg");
+
+	if(hw->phy_type == e1000_phy_igp &&
+	   (reg_addr > MAX_PHY_MULTI_PAGE_REG)) {
+		if((ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT,
+		                                     (uint16_t)reg_addr)))
+			return ret_val;
+	}
+
+	ret_val = e1000_write_phy_reg_ex(hw, IGP01E1000_PHY_PAGE_SELECT & reg_addr,
+	                                 phy_data);
+
+	return ret_val;
+}
+
+static int
+e1000_write_phy_reg_ex(struct e1000_hw *hw,
+                       uint32_t reg_addr,
+                       uint16_t phy_data)
+{
 	uint32_t i;
 	uint32_t mdic = 0;
 	const uint32_t phy_addr = 1;
 	
-	DEBUGFUNC("e1000_write_phy_reg");
+	DEBUGFUNC("e1000_write_phy_reg_ex");
 	
 	if(reg_addr > MAX_PHY_REG_ADDRESS) {
 		DEBUGOUT1("PHY Address %d is out of range\n", reg_addr);
@@ -2643,8 +2963,8 @@
 		E1000_WRITE_REG(hw, MDIC, mdic);
 		
 		/* Poll the ready bit to see if the MDI read completed */
-		for(i = 0; i < 64; i++) {
-			udelay(10);
+		for(i = 0; i < 640; i++) {
+			udelay(5);
 			mdic = E1000_READ_REG(hw, MDIC);
 			if(mdic & E1000_MDIC_READY) break;
 		}
@@ -2674,7 +2994,7 @@
 		e1000_shift_out_mdi_bits(hw, mdic, 32);
 	}
 
-	return 0;
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -2716,13 +3036,6 @@
 		E1000_WRITE_FLUSH(hw);
 	}
 	udelay(150);
-
-	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547)) {
-		if(e1000_write_phy_reg(hw, IGP01E1000_PHY_PAGE_SELECT, 0x0000) < 0) {
-			DEBUGOUT("PHY Write Error\n");
-			return;
-		}
-	}
 }
 
 /******************************************************************************
@@ -2735,24 +3048,26 @@
 static int 
 e1000_phy_reset(struct e1000_hw *hw)
 {
+	int32_t ret_val;
 	uint16_t phy_data;
 
 	DEBUGFUNC("e1000_phy_reset");
-	
-	if(e1000_read_phy_reg(hw, PHY_CTRL, &phy_data) < 0) {
-		DEBUGOUT("PHY Read Error\n");
-		return -E1000_ERR_PHY;
-	}
-	phy_data |= MII_CR_RESET;
-	if(e1000_write_phy_reg(hw, PHY_CTRL, phy_data) < 0) {
-		DEBUGOUT("PHY Write Error\n");
-		return -E1000_ERR_PHY;
-	}
-	udelay(1);
-	if (hw->phy_type == e1000_phy_igp) {
+
+	if(hw->mac_type != e1000_82541_rev_2) {
+		if((ret_val = e1000_read_phy_reg(hw, PHY_CTRL, &phy_data)))
+			return ret_val;
+		
+		phy_data |= MII_CR_RESET;
+		if((ret_val = e1000_write_phy_reg(hw, PHY_CTRL, phy_data)))
+			return ret_val;
+		
+		udelay(1);
+	} else e1000_phy_hw_reset(hw);
+
+	if(hw->phy_type == e1000_phy_igp)
 		e1000_phy_init_script(hw);
-	}
-	return 0;
+
+	return E1000_SUCCESS;
 }
 
 /******************************************************************************
@@ -2763,23 +3078,21 @@
 static int
 e1000_detect_gig_phy(struct e1000_hw *hw)
 {
+	int32_t phy_init_status, ret_val;
 	uint16_t phy_id_high, phy_id_low;
 	boolean_t match = FALSE;
-	int32_t phy_init_status;
 
 	DEBUGFUNC("e1000_detect_gig_phy");
 	
 	/* Read the PHY ID Registers to identify which PHY is onboard. */
-	if(e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high) < 0) {
-		DEBUGOUT("PHY Read Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_read_phy_reg(hw, PHY_ID1, &phy_id_high)))
+		return ret_val;
+
 	hw->phy_id = (uint32_t) (phy_id_high << 16);
 	udelay(20);
-	if(e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low) < 0) {
-		DEBUGOUT("PHY Read Error\n");
-		return -E1000_ERR_PHY;
-	}
+	if((ret_val = e1000_read_phy_reg(hw, PHY_ID2, &phy_id_low)))
+		return ret_val;
+	
 	hw->phy_id |= (uint32_t) (phy_id_low & PHY_REVISION_MASK);
 #ifdef LINUX_DRIVER
 	hw->phy_revision = (uint32_t) phy_id_low & ~PHY_REVISION_MASK;
@@ -2794,11 +3107,15 @@
 		break;
 	case e1000_82540:
 	case e1000_82545:
+	case e1000_82545_rev_3:
 	case e1000_82546:
+	case e1000_82546_rev_3:
 		if(hw->phy_id == M88E1011_I_PHY_ID) match = TRUE;
 		break;
 	case e1000_82541:
+	case e1000_82541_rev_2:
 	case e1000_82547:
+	case e1000_82547_rev_2:
 		if(hw->phy_id == IGP01E1000_I_PHY_ID) match = TRUE;
 		break;
 	default:
@@ -2809,7 +3126,7 @@
 
 	if ((match) && (phy_init_status == E1000_SUCCESS)) {
 		DEBUGOUT1("PHY ID 0x%X detected\n", hw->phy_id);
-		return 0;
+		return E1000_SUCCESS;
 	}
 	DEBUGOUT1("Invalid PHY ID 0x%X\n", hw->phy_id);
 	return -E1000_ERR_PHY;
@@ -2843,7 +3160,9 @@
 		break;
 	case e1000_82540:
 	case e1000_82545:
+	case e1000_82545_rev_3:
 	case e1000_82546:
+	case e1000_82546_rev_3:
 		eeprom->type = e1000_eeprom_microwire;
 		eeprom->opcode_bits = 3;
 		eeprom->delay_usec = 50;
@@ -2856,12 +3175,11 @@
 		}
 		break;
 	case e1000_82541:
+	case e1000_82541_rev_2:
 	case e1000_82547:
-	default:
+	case e1000_82547_rev_2:
 		if (eecd & E1000_EECD_TYPE) {
 			eeprom->type = e1000_eeprom_spi;
-			eeprom->opcode_bits = 8;
-			eeprom->delay_usec = 1;
 			if (eecd & E1000_EECD_ADDR_BITS) {
 				eeprom->page_size = 32;
 				eeprom->address_bits = 16;
@@ -2882,9 +3200,21 @@
 			}
 		}
 		break;
+	default:
+		eeprom->type = e1000_eeprom_spi;
+		if (eecd & E1000_EECD_ADDR_BITS) {
+			eeprom->page_size = 32;
+			eeprom->address_bits = 16;
+		} else {
+			eeprom->page_size = 8;
+			eeprom->address_bits = 8;
+		}
+		break;
 	}
 
 	if (eeprom->type == e1000_eeprom_spi) {
+		eeprom->opcode_bits = 8;
+		eeprom->delay_usec = 1;
 		eeprom->word_size = 64;
 		if (e1000_read_eeprom(hw, EEPROM_CFG, 1, &eeprom_size) == 0) {
 			eeprom_size &= EEPROM_SIZE_MASK;
@@ -2910,7 +3240,6 @@
 				break;
 			case EEPROM_SIZE_128B:
 			default:
-				eeprom->word_size = 64;
 				break;
 			}
 		}
@@ -2924,7 +3253,6 @@
 static int
 e1000_reset(struct e1000_hw *hw)
 {
-	int ret_val;
 	uint32_t pba;
 	/* Repartition Pba for greater than 9k mtu
 	 * To take effect CTRL.RST is required.
@@ -2937,15 +3265,19 @@
 	}
 	E1000_WRITE_REG(hw, PBA, pba);
 
+	/* flow control settings */
+#if 0
+	hw->fc_high_water = FC_DEFAULT_HI_THRESH;
+	hw->fc_low_water = FC_DEFAULT_LO_THRESH;
+	hw->fc_pause_time = FC_DEFAULT_TX_TIMER;
+	hw->fc_send_xon = 1;
 	hw->fc = hw->original_fc;
+#endif
+	
 	e1000_reset_hw(hw);
 	if(hw->mac_type >= e1000_82544)
 		E1000_WRITE_REG(hw, WUC, 0);
-	ret_val = e1000_init_hw(hw);
-	if (ret_val < 0) {
-		return ret_val;
-	}
-	return ret_val;
+	return e1000_init_hw(hw);
 }
 
 /**
@@ -2966,9 +3298,11 @@
 	pci_read_config_word(pdev, PCI_VENDOR_ID, &hw->vendor_id);
 	pci_read_config_word(pdev, PCI_DEVICE_ID, &hw->device_id);
 	pci_read_config_byte(pdev, PCI_REVISION, &hw->revision_id);
+#if 0
 	pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID,
                              &hw->subsystem_vendor_id);
 	pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &hw->subsystem_id);
+#endif
 
 	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
 
@@ -2984,43 +3318,34 @@
 
 	e1000_init_eeprom_params(hw);
 
-	/* flow control settings */
-
-	hw->fc_high_water = FC_DEFAULT_HI_THRESH;
-	hw->fc_low_water = FC_DEFAULT_LO_THRESH;
-	hw->fc_pause_time = FC_DEFAULT_TX_TIMER;
-	hw->fc_send_xon = 1;
-
-	if((hw->mac_type == e1000_82541) || (hw->mac_type == e1000_82547))
+#if 0
+	if((hw->mac_type == e1000_82541) ||
+	   (hw->mac_type == e1000_82547) ||
+	   (hw->mac_type == e1000_82541_rev_2) ||
+	   (hw->mac_type == e1000_82547_rev_2))
 		hw->phy_init_script = 1;
+#endif
 
-	/* Media type - copper or fiber */
-
-	if(hw->mac_type >= e1000_82543) {
-		uint32_t status = E1000_READ_REG(hw, STATUS);
-
-		if(status & E1000_STATUS_TBIMODE)
-			hw->media_type = e1000_media_type_fiber;
-		else
-			hw->media_type = e1000_media_type_copper;
-	} else {
-		hw->media_type = e1000_media_type_fiber;
-	}
+	e1000_set_media_type(hw);
 
+#if 0
 	if(hw->mac_type < e1000_82543)
 		hw->report_tx_early = 0;
 	else
 		hw->report_tx_early = 1;
 
+	hw->wait_autoneg_complete = FALSE;
+#endif
 	hw->tbi_compatibility_en = TRUE;
 #if 0
-	hw->wait_autoneg_complete = FALSE;
 	hw->adaptive_ifs = TRUE;
 
 	/* Copper options */
+
 	if(hw->media_type == e1000_media_type_copper) {
 		hw->mdix = AUTO_ALL_MODES;
 		hw->disable_polarity_correction = FALSE;
+		hw->master_slave = E1000_MASTER_SLAVE;
 	}
 #endif
 	return E1000_SUCCESS;
@@ -3116,7 +3441,7 @@
 	/* nic->packet should contain data on return */
 	/* nic->packetlen should contain length of data */
 	struct e1000_rx_desc *rd;
-	
+
 	rd = rx_base + rx_last;
 	if (!rd->status & E1000_RXD_STAT_DD)
 		return 0;
@@ -3197,6 +3522,11 @@
 	iounmap(hw.hw_addr);
 }
 
+#define IORESOURCE_IO	0x00000100     /* Resource type */
+#define BAR_0		0
+#define BAR_1		1
+#define BAR_5		5
+
 /**************************************************************************
 PROBE - Look for an adapter, this routine's visible to the outside
 You should omit the last argument struct pci_device * for a non-PCI NIC
@@ -3205,7 +3535,7 @@
 {
 	struct nic *nic = (struct nic *)dev;
 	unsigned long mmio_start, mmio_len;
-	int ret_val;
+	int ret_val, i;
 
 	if (p == 0)
 		return 0;
@@ -3216,16 +3546,27 @@
 #if 1
 	/* Are these variables needed? */
 	hw.fc                    = e1000_fc_none;
+#if 0
 	hw.original_fc           = e1000_fc_none;
+#endif
 	hw.autoneg_failed        = 0;
+#if 0
 	hw.get_link_status       = TRUE;
 #endif
+#endif
 
 	mmio_start = pci_bar_start(p, PCI_BASE_ADDRESS_0);
 	mmio_len   = pci_bar_size(p,  PCI_BASE_ADDRESS_0);
 	hw.hw_addr = ioremap(mmio_start, mmio_len);
 
-	hw.mac_type = e1000_undefined;
+	for(i = BAR_1; i <= BAR_5; i++) {
+		if(pci_bar_size(p, i) == 0)
+			continue;                
+		if(pci_find_capability(p, i) & IORESOURCE_IO) {
+			hw.io_base = pci_bar_start(p, i);
+			break;
+                }        
+	}
 	adjust_pci_device(p);
 
 	/* From Matt Hortman <mbhortman@acpthinclient.com> */
@@ -3295,9 +3636,19 @@
 PCI_ROM(0x8086, 0x1019, "e1000-82547ei",	     "Intel EtherExpressPro1000 82547EI"),
 PCI_ROM(0x8086, 0x101d, "e1000-82546eb-quad-copper", "Intel EtherExpressPro1000 82546EB Quad Copper"),
 PCI_ROM(0x8086, 0x101e, "e1000-82540ep-lp",	     "Intel EtherExpressPro1000 82540EP LP"),
+PCI_ROM(0x8086, 0x1026, "e1000-82545gm-copper",	     "Intel EtherExpressPro1000 82545GM Copper"),
+PCI_ROM(0x8086, 0x1027, "e1000-82545gm-fiber",	     "Intel EtherExpressPro1000 82545GM Fiber"),
+PCI_ROM(0x8086, 0x1028, "e1000-82545gm-serdes",	     "Intel EtherExpressPro1000 82545GM SERDES"),
+PCI_ROM(0x8086, 0x1075, "e1000-82547gi",	     "Intel EtherExpressPro1000 82547GI"),
+PCI_ROM(0x8086, 0x1076, "e1000-82541gi",	     "Intel EtherExpressPro1000 82541GI"),
+PCI_ROM(0x8086, 0x1077, "e1000-82541gi-mobile",	     "Intel EtherExpressPro1000 82541GI Mobile"),
+PCI_ROM(0x8086, 0x1078, "e1000-82541er",	     "Intel EtherExpressPro1000 82541ER"),
+PCI_ROM(0x8086, 0x1079, "e1000-82546gb-copper",	     "Intel EtherExpressPro1000 82546GB Copper"),
+PCI_ROM(0x8086, 0x107a, "e1000-82546gb-fiber",	     "Intel EtherExpressPro1000 82546GB Fiber"),
+PCI_ROM(0x8086, 0x107b, "e1000-82546gb-serdes",	     "Intel EtherExpressPro1000 82546GB SERDES"),
 };
 
-struct pci_driver e1000_driver = {
+struct pci_driver e1000_driver = {
 	.type     = NIC_DRIVER,
 	.name     = "E1000",
 	.probe    = e1000_probe,
diff -Naurd a/netboot/e1000_hw.h b/netboot/e1000_hw.h
--- a/netboot/e1000_hw.h	2006-02-27 17:18:29.000000000 +0100
+++ b/netboot/e1000_hw.h	2004-04-24 04:28:11.000000000 +0200
@@ -47,9 +47,13 @@
     e1000_82544,
     e1000_82540,
     e1000_82545,
+    e1000_82545_rev_3,
     e1000_82546,
+    e1000_82546_rev_3,
     e1000_82541,
+    e1000_82541_rev_2,
     e1000_82547,
+    e1000_82547_rev_2,
     e1000_num_macs
 } e1000_mac_type;
 
@@ -64,6 +68,7 @@
 typedef enum {
 	e1000_media_type_copper = 0,
 	e1000_media_type_fiber = 1,
+	e1000_media_type_internal_serdes = 2,
 	e1000_num_media_types
 } e1000_media_type;
 
@@ -87,7 +92,8 @@
 typedef enum {
 	e1000_bus_type_unknown = 0,
 	e1000_bus_type_pci,
-	e1000_bus_type_pcix
+	e1000_bus_type_pcix,
+	e1000_bus_type_reserved
 } e1000_bus_type;
 
 /* PCI bus speeds */
@@ -105,7 +111,8 @@
 typedef enum {
 	e1000_bus_width_unknown = 0,
 	e1000_bus_width_32,
-	e1000_bus_width_64
+	e1000_bus_width_64,
+	e1000_bus_width_reserved
 } e1000_bus_width;
 
 /* PHY status info structure and supporting enums */
@@ -183,15 +190,31 @@
     e1000_phy_undefined = 0xFF
 } e1000_phy_type;
 
+typedef enum {
+    e1000_ms_hw_default = 0,
+    e1000_ms_force_master,
+    e1000_ms_force_slave,
+    e1000_ms_auto
+} e1000_ms_type;
+
+typedef enum {
+    e1000_ffe_config_enabled = 0,
+    e1000_ffe_config_active,
+    e1000_ffe_config_blocked
+} e1000_ffe_config;
+
+typedef enum {
+    e1000_dsp_config_disabled = 0,
+    e1000_dsp_config_enabled,
+    e1000_dsp_config_activated,
+    e1000_dsp_config_undefined = 0xFF
+} e1000_dsp_config;
+
 struct e1000_phy_info {
-#if 0
 	e1000_cable_length cable_length;
-#endif
 	e1000_10bt_ext_dist_enable extended_10bt_distance;
 	e1000_rev_polarity cable_polarity;
-#if 0
 	e1000_downshift downshift;
-#endif
 	e1000_polarity_reversal polarity_correction;
 	e1000_auto_x_mode mdix_mode;
 	e1000_1000t_rx_status local_rx;
@@ -245,13 +268,22 @@
 #define E1000_DEV_ID_82540EP_LP          0x101E
 #define E1000_DEV_ID_82545EM_COPPER      0x100F
 #define E1000_DEV_ID_82545EM_FIBER       0x1011
+#define E1000_DEV_ID_82545GM_COPPER      0x1026
+#define E1000_DEV_ID_82545GM_FIBER       0x1027
+#define E1000_DEV_ID_82545GM_SERDES      0x1028
 #define E1000_DEV_ID_82546EB_COPPER      0x1010
 #define E1000_DEV_ID_82546EB_FIBER       0x1012
 #define E1000_DEV_ID_82546EB_QUAD_COPPER 0x101D
 #define E1000_DEV_ID_82541EI             0x1013
-#define E1000_DEV_ID_82541EP             0x1018
+#define E1000_DEV_ID_82541EI_MOBILE      0x1018
+#define E1000_DEV_ID_82541ER             0x1078
+#define E1000_DEV_ID_82547GI             0x1075
+#define E1000_DEV_ID_82541GI             0x1076
+#define E1000_DEV_ID_82541GI_MOBILE      0x1077
+#define E1000_DEV_ID_82546GB_COPPER      0x1079
+#define E1000_DEV_ID_82546GB_FIBER       0x107A
+#define E1000_DEV_ID_82546GB_SERDES      0x107B
 #define E1000_DEV_ID_82547EI             0x1019
-#define NUM_DEV_IDS 20
 
 #define NODE_ADDRESS_SIZE 6
 #define ETH_LENGTH_OF_ADDRESS 6
@@ -317,7 +349,7 @@
     E1000_IMS_RXSEQ  |    \
     E1000_IMS_LSC)
 
-/* The number of high/low register pairs in the RAR. The RAR (Receive Address
+/* Number of high/low register pairs in the RAR. The RAR (Receive Address
  * Registers) holds the directed and multicast addresses that we monitor. We
  * reserve one of these spots for our directed address, allowing us room for
  * E1000_RAR_ENTRIES - 1 multicast addresses. 
@@ -471,7 +503,7 @@
     volatile uint32_t high;     /* receive address high */
 };
 
-/* The number of entries in the Multicast Table Array (MTA). */
+/* Number of entries in the Multicast Table Array (MTA). */
 #define E1000_NUM_MTA_REGISTERS 128
 
 /* IPv4 Address Table Entry */
@@ -531,6 +563,7 @@
  * A - register array
  */
 #define E1000_CTRL     0x00000  /* Device Control - RW */
+#define E1000_CTRL_DUP 0x00004  /* Device Control Duplicate (Shadow) - RW */
 #define E1000_STATUS   0x00008  /* Device Status - RO */
 #define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
 #define E1000_EERD     0x00014  /* EEPROM Read - RW */
@@ -859,7 +892,9 @@
 	uint8_t *hw_addr;
 	e1000_mac_type   mac_type;
 	e1000_phy_type phy_type;
+#if 0
 	uint32_t phy_init_script;
+#endif
 	e1000_media_type media_type;
 	e1000_fc_type    fc;
 #if 0
@@ -869,14 +904,19 @@
 #endif
 	struct e1000_eeprom_info eeprom;
 #if 0
-	uint32_t io_base;
+	e1000_ms_type master_slave;
+	e1000_ms_type original_master_slave;
+	e1000_ffe_config ffe_config_state;
 #endif
+	uint32_t io_base;
 	uint32_t phy_id;
 #ifdef LINUX_DRIVER
 	uint32_t phy_revision;
 #endif
 	uint32_t phy_addr;
+#if 0
 	uint32_t original_fc;
+#endif
 	uint32_t txcw;
 	uint32_t autoneg_failed;
 #if 0
@@ -889,13 +929,14 @@
 	uint32_t ledctl_default;
 	uint32_t ledctl_mode1;
 	uint32_t ledctl_mode2;
+	uint16_t phy_spd_default;
 #endif
 	uint16_t autoneg_advertised;
 	uint16_t pci_cmd_word;
+#if 0
 	uint16_t fc_high_water;
 	uint16_t fc_low_water;
 	uint16_t fc_pause_time;
-#if 0
 	uint16_t current_ifs_val;
 	uint16_t ifs_min_val;
 	uint16_t ifs_max_val;
@@ -904,8 +945,10 @@
 #endif
 	uint16_t device_id;
 	uint16_t vendor_id;
+#if 0
 	uint16_t subsystem_id;
 	uint16_t subsystem_vendor_id;
+#endif
 	uint8_t revision_id;
 #if 0
 	uint8_t autoneg;
@@ -919,13 +962,17 @@
 	uint8_t perm_mac_addr[NODE_ADDRESS_SIZE];
 	boolean_t disable_polarity_correction;
 	boolean_t speed_downgraded;
-#endif
+	e1000_dsp_config dsp_config_state;
 	boolean_t get_link_status;
+	boolean_t serdes_link_down;
+#endif
 	boolean_t tbi_compatibility_en;
 	boolean_t tbi_compatibility_on;
+#if 0
+	boolean_t phy_reset_disable;
 	boolean_t fc_send_xon;
+	boolean_t fc_strict_ieee;
 	boolean_t report_tx_early;
-#if 0
 	boolean_t adaptive_ifs;
 	boolean_t ifs_params_forced;
 	boolean_t in_ifs_mode;
@@ -1374,12 +1421,14 @@
 #define EEPROM_SIZE_128B        0x0000
 #define EEPROM_SIZE_MASK        0x1C00
 
-
 /* EEPROM Word Offsets */
 #define EEPROM_COMPAT              0x0003
 #define EEPROM_ID_LED_SETTINGS     0x0004
+#define EEPROM_SERDES_AMPLITUDE       0x0006 /* For SERDES output amplitude adjustment. */
 #define EEPROM_INIT_CONTROL1_REG   0x000A
 #define EEPROM_INIT_CONTROL2_REG   0x000F
+#define EEPROM_INIT_CONTROL3_PORT_B   0x0014
+#define EEPROM_INIT_CONTROL3_PORT_A   0x0024
 #define EEPROM_CFG                 0x0012
 #define EEPROM_FLASH_VERSION       0x0032
 #define EEPROM_CHECKSUM_REG        0x003F
@@ -1406,6 +1455,9 @@
 #define IGP_LED3_MODE           0x07000000
 
 
+/* Mask bits for SERDES amplitude adjustment in Word 6 of the EEPROM */
+#define EEPROM_SERDES_AMPLITUDE_MASK  0x000F
+
 /* Mask bits for fields in Word 0x0a of the EEPROM */
 #define EEPROM_WORD0A_ILOS   0x0010
 #define EEPROM_WORD0A_SWDPIO 0x01E0
@@ -1427,6 +1479,8 @@
 #define EEPROM_NODE_ADDRESS_BYTE_0 0
 #define EEPROM_PBA_BYTE_1          8
 
+#define EEPROM_RESERVED_WORD          0xFFFF
+
 /* EEPROM Map Sizes (Byte Counts) */
 #define PBA_SIZE 4
 
@@ -1438,7 +1492,7 @@
 #define E1000_HDX_COLLISION_DISTANCE    E1000_COLLISION_DISTANCE
 #define E1000_COLD_SHIFT                12
 
-/* The number of Transmit and Receive Descriptors must be a multiple of 8 */
+/* Number of Transmit and Receive Descriptors must be a multiple of 8 */
 #define REQ_TX_DESCRIPTOR_MULTIPLE  8
 #define REQ_RX_DESCRIPTOR_MULTIPLE  8
 
@@ -1505,35 +1559,30 @@
 #define PCIX_STATUS_HI_MMRBC_2K      0x2
 
 
-/* The number of bits that we need to shift right to move the "pause"
- * bits from the EEPROM (bits 13:12) to the "pause" (bits 8:7) field
- * in the TXCW register 
+/* Number of bits required to shift right the "pause" bits from the
+ * EEPROM (bits 13:12) to the "pause" (bits 8:7) field in the TXCW register.
  */
 #define PAUSE_SHIFT 5
 
-/* The number of bits that we need to shift left to move the "SWDPIO"
- * bits from the EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field
- * in the CTRL register 
+/* Number of bits required to shift left the "SWDPIO" bits from the
+ * EEPROM (bits 8:5) to the "SWDPIO" (bits 25:22) field in the CTRL register.
  */
 #define SWDPIO_SHIFT 17
 
-/* The number of bits that we need to shift left to move the "SWDPIO_EXT"
- * bits from the EEPROM word F (bits 7:4) to the bits 11:8 of The
- * Extended CTRL register.
- * in the CTRL register 
+/* Number of bits required to shift left the "SWDPIO_EXT" bits from the
+ * EEPROM word F (bits 7:4) to the bits 11:8 of The Extended CTRL register.
  */
 #define SWDPIO__EXT_SHIFT 4
 
-/* The number of bits that we need to shift left to move the "ILOS"
- * bit from the EEPROM (bit 4) to the "ILOS" (bit 7) field
- * in the CTRL register 
+/* Number of bits required to shift left the "ILOS" bit from the EEPROM
+ * (bit 4) to the "ILOS" (bit 7) field in the CTRL register.
  */
 #define ILOS_SHIFT  3
 
 
 #define RECEIVE_BUFFER_ALIGN_SIZE  (256)
 
-/* The number of milliseconds we wait for auto-negotiation to complete */
+/* Number of milliseconds we wait for auto-negotiation to complete */
 #define LINK_UP_TIMEOUT             500
 
 #define E1000_TX_BUFFER_SIZE ((uint32_t)1514)
@@ -1616,7 +1665,16 @@
 #define M88E1000_EXT_PHY_SPEC_CTRL 0x14  /* Extended PHY Specific Control */
 #define M88E1000_RX_ERR_CNTR       0x15  /* Receive Error Counter */
 
+#define M88E1000_PHY_EXT_CTRL      0x1A  /* PHY extend control register */
+#define M88E1000_PHY_PAGE_SELECT   0x1D  /* Reg 29 for page number setting */
+#define M88E1000_PHY_GEN_CONTROL   0x1E  /* Its meaning depends on reg 29 */
+#define M88E1000_PHY_VCO_REG_BIT8  0x100 /* Bits 8 & 11 are adjusted for */
+#define M88E1000_PHY_VCO_REG_BIT11 0x800    /* improved BER performance */
+
 #define IGP01E1000_IEEE_REGS_PAGE  0x0000
+#define IGP01E1000_IEEE_RESTART_AUTONEG 0x3300
+#define IGP01E1000_IEEE_FORCE_GIGA      0x0140
+
 /* IGP01E1000 Specific Registers */
 #define IGP01E1000_PHY_PORT_CONFIG 0x10 /* PHY Specific Port Config Register */
 #define IGP01E1000_PHY_PORT_STATUS 0x11 /* PHY Specific Status Register */
@@ -1632,17 +1690,35 @@
 #define IGP01E1000_PHY_AGC_C        0x1472
 #define IGP01E1000_PHY_AGC_D        0x1872
 
-/* Number of AGC registers */
-#define IGP01E1000_PHY_AGC_NUM     4
+/* IGP01E1000 DSP Reset Register */
+#define IGP01E1000_PHY_DSP_RESET   0x1F33
+#define IGP01E1000_PHY_DSP_SET     0x1F71
+#define IGP01E1000_PHY_DSP_FFE     0x1F35
+
+#define IGP01E1000_PHY_CHANNEL_NUM    4
+#define IGP01E1000_PHY_AGC_PARAM_A    0x1171
+#define IGP01E1000_PHY_AGC_PARAM_B    0x1271
+#define IGP01E1000_PHY_AGC_PARAM_C    0x1471
+#define IGP01E1000_PHY_AGC_PARAM_D    0x1871
+
+#define IGP01E1000_PHY_EDAC_MU_INDEX        0xC000
+#define IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS 0x8000
+
+#define IGP01E1000_PHY_ANALOG_TX_STATE      0x2890
+#define IGP01E1000_PHY_ANALOG_CLASS_A       0x2000
+#define IGP01E1000_PHY_FORCE_ANALOG_ENABLE  0x0004
+#define IGP01E1000_PHY_DSP_FFE_CM_CP        0x0069
 
+#define IGP01E1000_PHY_DSP_FFE_DEFAULT      0x002A
 /* IGP01E1000 PCS Initialization register - stores the polarity status when
  * speed = 1000 Mbps. */
 #define IGP01E1000_PHY_PCS_INIT_REG  0x00B4
+#define IGP01E1000_PHY_PCS_CTRL_REG  0x00B5
 
 #define IGP01E1000_ANALOG_REGS_PAGE  0x20C0
   
 #define MAX_PHY_REG_ADDRESS 0x1F        /* 5 bit address bus (0-0x1F) */
-
+#define MAX_PHY_MULTI_PAGE_REG  0xF     /*Registers that are equal on all pages*/
 /* PHY Control Register */
 #define MII_CR_SPEED_SELECT_MSB 0x0040  /* bits 6,13: 10=1000, 01=100, 00=10 */
 #define MII_CR_COLL_TEST_ENABLE 0x0080  /* Collision test enable */
@@ -1758,6 +1834,9 @@
 #define SR_1000T_MS_CONFIG_FAULT  0x8000 /* Master/Slave config fault */
 #define SR_1000T_REMOTE_RX_STATUS_SHIFT 12
 #define SR_1000T_LOCAL_RX_STATUS_SHIFT  13
+#define SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT    5
+#define FFE_IDLE_ERR_COUNT_TIMEOUT_20            20
+#define FFE_IDLE_ERR_COUNT_TIMEOUT_100           100
 
 /* Extended Status Register */
 #define IEEE_ESR_1000T_HD_CAPS 0x1000 /* 1000T HD capable */
@@ -1849,7 +1928,6 @@
 #define M88E1000_EPSCR_TX_CLK_25      0x0070 /* 25  MHz TX_CLK */
 #define M88E1000_EPSCR_TX_CLK_0       0x0000 /* NO  TX_CLK */
 
-
 /* IGP01E1000 Specific Port Config Register - R/W */
 #define IGP01E1000_PSCFR_AUTO_MDIX_PAR_DETECT  0x0010
 #define IGP01E1000_PSCFR_PRE_EN                0x0020
@@ -1900,6 +1978,11 @@
 #define IGP01E1000_MSE_CHANNEL_B        0x0F00
 #define IGP01E1000_MSE_CHANNEL_A        0xF000
 
+/* IGP01E1000 DSP reset macros */
+#define DSP_RESET_ENABLE     0x0
+#define DSP_RESET_DISABLE    0x2
+#define E1000_MAX_DSP_RESETS 10
+
 /* IGP01E1000 AGC Registers */
 
 #define IGP01E1000_AGC_LENGTH_SHIFT 7         /* Coarse - 13:11, Fine - 10:7 */
@@ -1918,11 +2001,12 @@
 #define IGP01E1000_GMII_FLEX_SPD               0x10 /* Enable flexible speed
                                                      * on Link-Up */
 #define IGP01E1000_GMII_SPD                    0x20 /* Enable SPD */
+
 /* IGP01E1000 Analog Register */
-#define IGP01E1000_ANALOG_SPARE_FUSE_STATUS         0x0011
-#define IGP01E1000_ANALOG_FUSE_STATUS               0x0010
-#define IGP01E1000_ANALOG_FUSE_CONTROL              0x001C
-#define IGP01E1000_ANALOG_FUSE_BYPASS               0x001E
+#define IGP01E1000_ANALOG_SPARE_FUSE_STATUS         0x20D1
+#define IGP01E1000_ANALOG_FUSE_STATUS               0x20D0
+#define IGP01E1000_ANALOG_FUSE_CONTROL              0x20DC
+#define IGP01E1000_ANALOG_FUSE_BYPASS               0x20DE
 
 #define IGP01E1000_ANALOG_FUSE_POLY_MASK            0xF000
 #define IGP01E1000_ANALOG_FUSE_FINE_MASK            0x0F80
@@ -1968,5 +2052,7 @@
 #define ADVERTISE_1000_HALF 0x0010
 #define ADVERTISE_1000_FULL 0x0020
 #define AUTONEG_ADVERTISE_SPEED_DEFAULT 0x002F  /* Everything but 1000-Half */
+#define AUTONEG_ADVERTISE_10_100_ALL    0x000F	/* All 10/100 speeds*/
+#define AUTONEG_ADVERTISE_10_ALL        0x0003	/* 10Mbps Full & Half speeds*/
 
 #endif /* _E1000_HW_H_ */

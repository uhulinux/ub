diff -Naurd a/calc.c b/calc.c
--- a/calc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/calc.c	2013-07-26 16:10:02.000000000 +0200
@@ -0,0 +1,687 @@
+#define HAVE_CALCULATOR
+#include <string.h>
+/*#define TEST*/
+
+
+#ifdef TEST
+#include <errno.h>
+char *itoa(int value, char *string, int radix)
+{
+  char tmp[33];
+  char *tp = tmp;
+  int i;
+  unsigned v;
+  int sign;
+  char *sp;
+  if (radix > 36 || radix <= 1)
+  {
+    errno = EDOM;
+    return 0;
+  }
+  sign = (radix == 10 && value < 0);
+  if (sign)
+    v = -value;
+  else
+    v = (unsigned)value;
+  while (v || tp == tmp)
+  {
+    i = v % radix;
+    v = v / radix;
+    if (i < 10)
+      *tp++ = i+'0';
+    else
+      *tp++ = i + 'a' - 10;
+  }
+  if (string == 0)
+    string = (char *)malloc((tp-tmp)+sign+1);
+  sp = string;
+  if (sign)
+    *sp++ = '-';
+  while (tp > tmp)
+    *sp++ = *--tp;
+  *sp = 0;
+  return string;
+}
+#endif
+/*****************************************************************************
+
+ Advanced parser. It supports all the functions found in ML's parser and also
+ definition of variables, functions and loops.
+ Created by Burton Radons <loth@pacificcoast.net>.
+
+*****************************************************************************/
+
+#include <ctype.h>
+#include <math.h>
+#include <setjmp.h>
+#include <stdio.h>
+#include <stdlib.h>
+#define Uses_string
+
+#ifdef HAVE_CALCULATOR
+
+#define isprenum(STR) (STR == '.' || (STR >= '0' && STR <= '9'))
+#define isprevar(STR) (STR == '_' || (STR >= 'a' && STR <= 'z') || (STR >= 'A' && STR <= 'Z'))
+#define isintvar(STR) (isprevar (STR) || (STR >= '0' && STR <= '9'))
+#define isexpr(STR)   (!isintvar (STR))
+
+#define resize(PTR, LEN) ((PTR) = realloc (PTR, sizeof (*(PTR)) * (LEN)))
+#define matchlen(NAME) ((int) (end - top) == (len = strlen (NAME)) && !strncasecmp (top, NAME, len))
+#define opsdo(NAME, LEN, EXPR) if (matchops (NAME, LEN)) EXPR
+#define findtop() for (top = str; isintvar (*str); str ++); end = str;
+#define matchops(NAME, LEN) (!strncmp (ops, NAME, LEN) && skipops (LEN))
+
+#define ltype long long
+#define lprint "ll"
+
+#define ftype long double
+#define fprint "L"
+
+static char *str = NULL;
+static char ops [16];
+static ftype arg [16];
+static int cfun = -1;
+static jmp_buf jmp;
+static char *ret;
+static int pradix;
+
+static char form[] = "%.10"fprint"g";
+#define DEFFUN1 "min(a,b)=a<b?a:b; max(a,b)=a>b?a:b"
+#define DEFFUN2 "sgn(x) = x<0?-1:(1-(0==x))"
+#define DEFFUN3 "root(x,y)= y**(1/x)"
+#define DEFFUN4 "PI=4*atan(1); E=exp(1)"
+#define DEFFUN5 "PHI=(sqrt(5)+1)/2"
+#define DEFFUN6 "DEG=180/(4*atan(1))"
+#define DEFFUN7 "rad(x) = x?(x*(4*atan(1)))/180:0"
+#define DEFFUN8 "lg(x,y)=(x!=1)?log(y)/log(x):1/0"
+#define DEFFUN9 "int(x) =x<0?ceil(x):floor(x)"
+#define DEFFU10 "frac(x)=x%1; div(a,b)=int(a/b)"
+#define DEFFU11 "fact(x)=x>0?x*fact(x-1):1"
+#define DEFFU12 "binom(a,b)=fact(a)/(fact(b)*fact(a-b))"
+#define DEFFU13 "sec(x)=1/cos(x), csec(x)=1/sin(x)"
+#define DEFFU14 "ctg(x)=cos(x)/sin(x)"
+#define DEFFU15 "cth(x)=(exp(2*x)+1)/(exp(2*x)-1)"
+#define DEFFU16 "acth(x)=0.5*log((x+1)/(x-1))"
+#define DEFFU17 "ln(x)=log(x); iif(a,b,c)=(a!=0)?b:c"
+#define DEFFU18 "GAMMA=.57721566490153286060"
+#define DEFFU19 "RAD =0.01745329251994329576"
+#define DEFFU20 "maxint=18446744073709551615."
+/*#define DEFFU20 "maxint=0x7fffffff; minint=-maxint"*/
+#define CDEF_NUM 20
+#define CHLP_NUM 24
+#define PREC_NUM 17
+
+char *calchlp[CHLP_NUM] =
+{
+"Operators:                   Functions:",
+"(in decreasing precedence)    abs,int,frac,min,max,sgn,ceil,floor,round,mod,div",
+"                              sin,cos,tan,sinh,cosh,tanh,asin,acos,atan",
+"   ~ unary not                atn2,asinh,acosh,atanh,sec,csec,ctg,cth,acth",
+"   - unary minus              lg,ln,log,log10,exp,pow,sqrt,root,cbrt,hypot",
+"-------                       pi,e,phi,gamma,deg,rad,gcd,lcm,fact,binom,prec",
+"  ** power                    bin,oct,dec,hex - Radix conversion.",
+"-------",
+"   * multiplication          Previous: '=',  Separator: ';'",
+"   / division                Help: 'help',  Quit: 'exit'",
+"   % modulo",
+"-------                      Examples: (defined)",
+"   + plus                     "DEFFUN1,
+"   - binary minus             "DEFFUN2,
+"-------                       "DEFFUN3,
+"  << shift left               "DEFFUN4,
+"  >> shift right              "DEFFUN5,
+"-------                       "DEFFUN6,
+"   & logical and              "DEFFUN7,
+"-------                       "DEFFUN8,
+"   ^ logical xor              "DEFFUN9,
+"-------                       "DEFFU10,
+"   | logical or               "DEFFU11,
+""
+};
+
+char *calcdef[CDEF_NUM+1] = { DEFFUN1, DEFFUN2, DEFFUN3, DEFFUN4, DEFFUN5,
+  DEFFUN6, DEFFUN7, DEFFUN8, DEFFUN9, DEFFU10, DEFFU11, DEFFU12, DEFFU13,
+  DEFFU14, DEFFU15, DEFFU16, DEFFU17, DEFFU18, DEFFU19, DEFFU20 };
+
+typedef ftype (*bfuntype) (ftype a);
+#define easy(NAME) static ftype fun_##NAME (ftype a) { return NAME (a); }
+easy (sin); easy (cos); easy (tan); easy (sinh); easy (cosh); easy (tanh);
+easy (asin); easy (acos); easy (atan); easy (log); easy (log10); easy (exp);
+easy (abs); easy (sqrt); easy (ceil); easy (floor);
+easy (acosh); easy (asinh); easy (atanh); easy (cbrt);
+#undef easy
+#define easy(NAME, RADIX) static ftype fun_##NAME (ftype a) { pradix = RADIX; return a; }
+easy (bin, 2); easy (oct, 8); easy (dec, 10); easy (hex, 16);
+#undef easy
+
+typedef ftype (*bfu2type) (ftype a, ftype b);
+#define easy(NAME) static ftype fun_##NAME(ftype a,ftype b) {return NAME(a,b);}
+easy(pow); easy(atan2); easy(hypot);
+#undef easy
+
+static ftype fun_prec(ftype a)
+{
+  unsigned short dec;
+  char *fstr = form;
+  dec = (unsigned short) a;
+  if (dec<PREC_NUM)
+  {
+    fstr += 2;
+    sprintf(fstr, "%02d", dec);
+    strcat(form, fprint"g");
+    return 0.;
+  }
+  return (-1.);
+}
+
+static long int lko(long int a, long int b)
+{
+  if (a==b) return a;
+  if (a<b) return lko(a,b-a);
+  return lko(a-b,b);
+}
+
+static ftype fun_gcd(ftype aa, ftype bb)
+{
+  long int a,b;
+  if (aa!=(aa-fmod(aa,1)) || bb!=(bb-fmod(bb,1)))
+    return 0.;
+  a = (int) abs(aa);
+  b = (int) abs(bb);
+  return (ftype) lko(a,b);
+}
+
+static ftype fun_lcm(ftype aa, ftype bb)
+{
+  long int a,b;
+  if (aa!=(aa-fmod(aa,1)) || bb!=(bb-fmod(bb,1)))
+    return 0.;
+  a = (int) abs(aa);
+  b = (int) abs(bb);
+  return ((a*b)/lko(a,b));
+}
+
+static ftype fun_mod(ftype a, ftype b)
+{
+  return fmod(a,b);
+}
+
+static ftype fun_round(ftype a, ftype b)
+{
+  int dec = (int)b;
+  return floor(a*pow(10.,dec)+.5)/pow(10.,dec);
+}
+
+static char *bfunn [] =
+  { "sin", "cos", "tan", "sinh", "cosh", "tanh", "asin", "acos",
+    "atan", "log", "log10", "exp", "abs", "sqrt", "ceil", "floor",
+    "bin", "oct", "dec", "hex", "acosh", "asinh", "atanh", "cbrt",
+    "prec", "pow", "mod", "round", "atan2", "hypot", "gcd", "lcm" };
+static bfuntype bfunp [] =
+  { fun_sin, fun_cos, fun_tan, fun_sinh, fun_cosh, fun_tanh, fun_asin,
+    fun_acos, fun_atan, fun_log, fun_log10, fun_exp, fun_abs, fun_sqrt,
+    fun_ceil, fun_floor, fun_bin, fun_oct, fun_dec, fun_hex, fun_acosh,
+    fun_asinh, fun_atanh, fun_cbrt, fun_prec,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+static bfu2type bfun2 [] =
+  { fun_pow, fun_mod, fun_round, fun_atan2, fun_hypot, fun_gcd, fun_lcm };
+#define bnfun (int) (sizeof (bfunn) / sizeof (*bfunn))
+#define bnfu2 (int) (7 - bnfun)
+
+static char **funn = NULL;
+static char ***funa = NULL; /* Arguments name-list for temporary binding */
+static char **func = NULL; /* Function contents */
+static int nfun = 0;
+
+static char **varn = NULL;
+static ftype *varv = NULL;
+static int nvar = 0;
+
+static ftype expr (void);
+
+static void error (char *str)
+{
+   strcpy (ret, str);
+   longjmp (jmp, 1);
+}
+
+static char *My_strndup (char *ptr, int len)
+{
+   char *dat = malloc (len + 1);
+   memmove (dat, ptr, len);
+   dat [len] = '\0';
+   return dat;
+}
+
+static void skipspace (void)
+{
+   // The cast is a workaround for a bug in Solaris 9 for SPARC
+   while (isspace ((int)*str))
+      str ++;
+}
+
+static int skipops (int cnt)
+{
+   while (cnt --)
+   {
+      skipspace ();
+      str ++;
+   }
+   return 1;
+}
+
+static char *readops (void)
+{
+   char *top = str;
+   char *ptr = ops;
+   while (1)
+   {
+      skipspace ();
+      if (*str == '\0' || isintvar (*str))
+         break;
+      *ptr ++ = *str ++;
+   }
+   *ptr = '\0';
+   str = top;
+   return ops;
+}
+
+static ftype *findvar (char *top, char *end)
+{
+   int c, len;
+   if (cfun != -1)
+   {
+      for (c = 0; funa [cfun] [c] != NULL; c ++)
+         if (!strncasecmp (funa [cfun] [c], top, (int) (end - top)))
+            return &arg [c];
+   }
+   for (c = 0; c < nvar; c ++)
+      if (matchlen (varn [c]))
+         break;
+   if (c >= nvar)
+   {
+      resize (varn, c + 1);
+      resize (varv, c + 1);
+      varn [c] = My_strndup (top, (int) (end - top));
+      varv [c] = 0;
+      nvar ++;
+   }
+   return &varv [c];
+}
+
+static ftype readnum (void)
+{
+   ftype a [16];
+   int c, d, len;
+   char *top, *end;
+   ftype val = 0;
+   ftype val2= 0;
+   
+   skipspace ();
+   if (isprenum (*str))
+   {
+      if (*str == '0')
+      {
+         if (*++ str == 'x')
+            return strtol (str + 1, &str, 16);
+         else if (*str == 'b')
+            return strtol (str + 1, &str, 2);
+         else if (*str != '.')
+            return strtol (str, &str, 8);
+      }
+      val = strtod (str, &str);
+      if (*str == 'x')
+      {
+         if (val < 1 || val > 36)
+            error ("Radix out of range (from 2 to 36)\n");
+         val = strtol (str + 1, &str, (int) val);
+      }
+      return val;
+   }
+   else if (isexpr (*str))
+   {
+      readops ();
+           opsdo ("++", 2, { findtop (); return ++ *findvar (top, end); })
+      else opsdo ("--", 2, { findtop (); return -- *findvar (top, end); })
+      else opsdo ("-", 1, return -readnum ());
+      else opsdo ("+", 1, return readnum ());
+      else opsdo ("~", 1, return ~(ltype) readnum ());
+      else opsdo ("!", 1, return !readnum ());
+      else if (matchops ("(", 1))
+      {
+         ftype val = expr ();
+         while (*str == ',')
+            str ++, val = expr ();
+         readops ();
+         if (!matchops (")", 1))
+            error ("Unbalanced or illegal expression");
+         return val;
+      }
+   }
+   else if (isprevar (*str))
+   {
+      findtop ();
+      for (c = 0; c < bnfun; c ++)
+         if (matchlen (bfunn [c]))
+         {
+            readops ();
+            if (!matchops ("(", 1))
+               error ("Expected (");
+            val = expr ();
+            readops ();
+            if (bfunp[c] != NULL)
+            {
+              if (!matchops (")", 1))
+                 error ("Too many arguments");
+              return bfunp [c] (val);
+            }
+            else
+            {
+              if (!matchops (",", 1))
+                 error ("Expected ,");
+              val2 = expr ();
+              readops ();
+              if (!matchops (")", 1))
+                 error ("Too many arguments");
+              return bfun2[c+bnfu2](val, val2);
+            }
+         }
+
+      readops ();
+      if (matchops ("(", 1))
+      {
+         char *ostr;
+         int ocfun;
+         ftype val;
+
+         for (c = 0; str [c] != '('; c ++)
+            if (str [c] == ')')
+            {
+               str += c;
+               readops ();
+               str -= c;
+               if (ops [1] == '=' && ops [2] != '=')
+               {
+                  for (c = 0; c < nfun; c ++)
+                     if (matchlen (funn [c]))
+                        goto redef;
+                  goto newdef;
+               }
+               break;
+            }
+         for (c = 0; c < nfun; c ++)
+            if (matchlen (funn [c]))
+            {
+               for (d = 0; funa [c] [d] != NULL; d ++)
+               {
+                  a [d] = arg [d];
+                  arg [d] = expr ();
+                  readops ();
+                  if (!matchops (funa [c] [d + 1] != NULL ? "," : ")", 1))
+                     error ("Too few or too many arguments");
+               }
+               if (d == 0)
+               {
+                  readops ();
+                  if (!matchops (")", 1))
+                     error ("Expected )");
+               }
+               ostr = str;   str = func [c];
+               ocfun = cfun; cfun = c;
+               val = expr ();
+               while (*str == ',')
+                  str ++, val = expr ();
+               str = ostr;   cfun = ocfun;
+               while (d --)
+                  arg [d] = a [d];
+               return val;
+            }
+
+      newdef:
+         resize (funn, c + 1);
+         resize (funa, c + 1);
+         resize (func, c + 1);
+      redef:
+         funn [c] = My_strndup (top, (int) (end - top));
+         funa [c] = NULL;
+
+         readops (); d = 0;
+         if (!matchops (")", 1))
+         while (1)
+         {
+            for (top = str; isintvar (*str); str ++);
+            resize (funa [c], d + 1);
+            funa [c] [d] = My_strndup (top, (int) (str - top));
+            readops ();
+            d ++;
+            if (matchops (")", 1))
+               break;
+            else if (!matchops (",", 1))
+               error ("Broken command");
+         }
+
+         readops ();
+         if (!matchops ("=", 1))
+            error ("Expected =");
+         resize (funa [c], d + 1);
+         funa [c] [d] = NULL;
+         func [c] = strdup (str);
+         if (c >= nfun)
+            nfun ++;
+         str += strlen (str) - 1;
+         return 0;
+      }
+      else
+      {
+         ftype *vp = findvar (top, end);
+              opsdo ("=", 1, return *vp = expr ());
+         else opsdo ("+=", 2, return *vp += expr ());
+         else opsdo ("-=", 2, return *vp -= expr ());
+         else opsdo ("*=", 2, return *vp *= expr ());
+         else opsdo ("/=", 2, return *vp /= expr ());
+         else opsdo ("%=", 2, return *vp = fmod (*vp, expr ()));
+         else opsdo ("&=", 2, return *vp = (ltype) (*vp) & (ltype) expr ());
+         else opsdo ("^=", 2, return *vp = (ltype) (*vp) ^ (ltype) expr ());
+         else opsdo ("!=", 2, return *vp = (ltype) (*vp) | (ltype) expr ());
+         else opsdo ("<<=", 3, return *vp = (ltype) (*vp) << (ltype) expr ());
+         else opsdo (">>=", 3, return *vp = (ltype) (*vp) >> (ltype) expr ());
+         else opsdo ("++", 2, return (*vp) ++);
+         else opsdo ("--", 2, return (*vp) --);
+         else return *vp;
+      }
+   }
+   error ("Retarded command");
+   return 0;
+}
+
+static ftype term (int lvl)
+{
+   ftype val;
+   if (lvl -- < 0)
+      return readnum ();
+   val = term (lvl);
+   while (1)
+   {
+      readops ();
+      switch (lvl + 1)
+      {
+         case 0:
+            opsdo ("**", 2, val = pow (val, term (lvl)));
+            else
+               return val;
+            break;
+         case 1:
+                 opsdo ("*", 1, val *= term (lvl));
+            else opsdo ("/", 1, val /= term (lvl));
+            else opsdo ("%", 1, val = fmod (val, term (lvl)));
+            else return val;
+            break;
+         case 2:
+                 opsdo ("+", 1, val += term (lvl));
+            else opsdo ("-", 1, val -= term (lvl));
+            else return val;
+            break;
+         case 3:
+                 opsdo ("<<", 2, val = (ltype) val << (ltype) term (lvl));
+            else opsdo (">>", 2, val = (ltype) val >> (ltype) term (lvl));
+            else return val;
+            break;
+         case 4:
+                 opsdo ("<",  1, val = val <  term (lvl));
+            else opsdo ("<=", 2, val = val <= term (lvl));
+            else opsdo (">",  1, val = val >  term (lvl));
+            else opsdo (">=", 2, val = val >= term (lvl));
+            else return val;
+            break;
+         case 5:
+                 opsdo ("==", 2, val = val == term (lvl));
+            else opsdo ("!=", 2, val = val != term (lvl));
+            else return val;
+            break;
+         case 6:
+                 if (!strncmp (ops, "&&", 2)) return val;
+            else opsdo ("&", 1, val = (ltype) val & (ltype) term (lvl));
+            else return val;
+            break;
+         case 7:
+                 opsdo ("^", 1, val = (ltype) val ^ (ltype) term (lvl));
+            else return val;
+            break;
+         case 8:
+                 if (!strncmp (ops, "||", 2)) return val;
+            else opsdo ("|", 1, val = (ltype) val | (ltype) term (lvl));
+            else return val;
+            break;
+         case 9:
+                 opsdo ("&&", 2, val = val && term (lvl));
+            else return val;
+            break;
+         case 10:
+                 opsdo ("||", 2, val = val || term (lvl));
+            else return val;
+            break;
+         case 11:
+            if (matchops ("?", 1))
+            {
+               int c;
+               if (val)
+               {
+                  val = expr ();
+                  skipspace ();
+                  if (*str ++ != ':')
+                     error ("Expected :");
+                  for (c = 0; *str != '\0' && c >= 0; str ++)
+                     if (*str == '(') c ++;
+                     else if (*str == ')') c --;
+               }
+               else
+               {
+                  for (c = 0; *str != '\0' && c >= 0; str ++)
+                     if (*str == '?') c ++;
+                     else if (*str == ':') c --;
+                  if (str [-1] != ':')
+                     error ("Expected :");
+                  val = expr ();
+               }
+            }
+            else return val;
+      }
+   }
+}
+
+static ftype expr (void)
+{
+   return term (11);
+}
+
+static char ret_buffer[140];
+
+/* Evaluate str, printing the result to ret, return 0 on failure */
+int eval (char *_str, char **_ret)
+{
+   ftype val;
+   int c;
+   
+   pradix = 10;
+   str = _str;
+   *_ret = ret_buffer;
+   ret = ret_buffer;
+   if (setjmp (jmp))
+      return 1;
+   val = expr ();
+   while (*str == ',')
+      str ++, val = expr ();
+   if (*str != '\0' && *str != '\n')
+      error ("Broken command");
+   if (pradix == 10)
+      sprintf (ret, form, val);
+   else if (pradix == 16)
+      sprintf (ret, "0x%" lprint "X", (ltype) val);
+   else if (pradix == 8)
+      sprintf (ret, "0%" lprint "o", (ltype) val);
+   else if (pradix == 2)
+   {
+      if (val < 0)
+      {
+#ifdef TEST
+        itoa((ltype) val, ret, 2);
+        return 0;
+#else
+        error ("Negative value");
+#endif
+      }
+      ltype bin = val;
+      *ret ++ = '0';
+      *ret ++ = 'b';
+      if (bin > 0)
+         for (c = 0; bin >> c; c ++);
+      else
+         c = 64; /* Negative integers use all the bits ;-) SET */
+      if (c == 0)
+         *ret ++ = '0';
+      ret += c;
+      *ret -- = '\0';
+      for (; c--; bin >>= 1)
+         *ret -- = (bin & 1) + '0';
+   }
+   return 0;
+}
+
+void evalini()
+{
+  char *idx, *res;
+  short i;
+  char buf[133];
+  for (i=0; i<CDEF_NUM; i++)
+  {
+    strcpy((char *)buf, (char *)calcdef[i]);
+    idx = strstr(buf, ';');
+    while (idx != NULL)
+    {
+      idx[0] = '\0';
+      eval((char *)buf, &res);
+      idx++;
+      strcpy((char *)buf, (char *)idx);
+      idx = strstr(buf, ';');
+    }
+    eval((char *)buf, &res);
+  }
+}
+
+#ifdef TEST
+int main (int argc, char *argv [])
+{
+   char buf [256], *res, *s;
+   int c;
+   evalini();
+   printf ("Write expression, get answer.\n");
+   while (fgets (buf, 256, stdin) == buf)
+   {
+      eval (buf, &res);
+      printf ("   = %s\n", res);
+   }
+   return 0;
+}
+#endif /* TEST */
+
+#endif // HAVE_CALCULATOR
diff -Naurd a/comm1.c b/comm1.c
--- a/comm1.c	2013-07-26 16:09:13.000000000 +0200
+++ b/comm1.c	2013-07-26 16:10:02.000000000 +0200
@@ -365,6 +365,152 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+short Format(CHARTYPE *,short,bool);
+
+/* NULL pointer type. */
+//#if !defined (NULL)
+//#  if defined (__STDC__)
+//#    define NULL ((void *) 0)
+//#  else
+//#    define NULL 0x0
+//#  endif /* !__STDC__ */
+//#endif /* !NULL */
+
+#ifndef to_upper
+#  define to_upper(c) (islower(c) ? toupper(c) : (c))
+#  define to_lower(c) (isupper(c) ? tolower(c) : (c))
+#endif
+
+#define ISOCTAL(c)	((c) >= '0' && (c) <= '7')
+#define OCTVALUE(c)	((c) - '0')
+
+//#ifndef isxdigit
+//#  define isxdigit(c)	(isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
+//#endif
+
+#define HEXVALUE(c) \
+  ((c) >= 'a' && (c) <= 'f' ? (c)-'a'+10 : (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
+
+/* Convert STRING by expanding the escape sequences specified by the
+   ANSI C standard.  If SAWC is non-null, recognize `\c' and use that
+   as a string terminator.  If we see \c, set *SAWC to 1 before
+   returning.  LEN is the length of STRING.  FOR_ECHO is a flag that
+   means, if non-zero, that we're translating a string for `echo -e',
+   and therefore should not treat a single quote as a character that
+   may be escaped with a backslash. */
+char *
+ansicstr (string, len/*, for_echo, sawc, rlen*/)
+     char *string;
+     int len/*, for_echo, *sawc, *rlen*/;
+{
+  int c, temp;
+  char *ret, *r, *s;
+
+  if (string == 0 || *string == '\0')
+    return ((char *)NULL);
+
+  ret = (char *) malloc(len + 1);
+  for (r = ret, s = string; s && *s; )
+    {
+      c = *s++;
+      if (c != '\\' || *s == '\0')
+        *r++ = c;
+      else
+	{
+	  switch (c = *s++)
+	    {
+#if defined (__STDC__)
+	    case 'a': c = '\a'; break;
+	    case 'v': c = '\v'; break;
+#else
+	    case 'a': c = '\007'; break;
+	    case 'v': c = (int) 0x0B; break;
+#endif
+	    case 'b': c = '\b'; break;
+	    case 'e': case 'E':		/* ESC -- non-ANSI */
+	      c = '\033'; break;
+	    case 'f': c = '\f'; break;
+	    case 'n': c = '\n'; break;
+	    case 'r': c = '\r'; break;
+	    case 't': c = '\t'; break;
+	    case '0': case '1': case '2': case '3':
+	    case '4': case '5': case '6': case '7':
+	      for (temp = 2, c -= '0'; ISOCTAL (*s) && temp--; s++)
+	        c = (c * 8) + OCTVALUE (*s);
+	      break;
+	    case 'x':			/* Hex digit -- non-ANSI */
+	      for (temp = 3, c = 0; isxdigit (*s) && temp--; s++)
+	        c = (c * 16) + HEXVALUE (*s);
+	      /* \x followed by non-hex digits is passed through unchanged */
+	      if (temp == 3)
+		{
+		  *r++ = '\\';
+		  c = 'x';
+		}
+	      break;
+	    case '\\':
+	      break;
+	    case '\'':
+/*
+	      if (for_echo)
+		*r++ = '\\';
+*/
+	      break;
+	    case 'c':
+/*
+	      if (sawc)
+		{
+		  *sawc = 1;
+		  *r = '\0';
+		  if (rlen)
+		    *rlen = r - ret;
+		  return ret;
+		}
+*/
+	    default:  *r++ = '\\'; break;
+	    }
+	  *r++ = c;
+	}
+    }
+  *r = '\0';
+/*
+  if (rlen)
+    *rlen = r - ret;
+*/
+  return ret;
+}
+
+/*man-start*********************************************************************
+COMMAND
+     ansicstr - expand ANSI C escape sequences
+
+SYNTAX
+     ANSICstr [target]
+
+DESCRIPTION
+     Convert current line by expanding the escape sequences
+     specified by the ANSI C standard.
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Ansicstr(CHARTYPE *params)
+#else
+short Ansicstr(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   Ansicstr");
+  rc = Format((DEFCHAR *)params,F_UNESC,TRUE);
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      backward - scroll backward by number of screens or lines
@@ -513,6 +659,591 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*****************************************************************
+ * SYSVbanner.c
+ * This is a PD version of the SYS V banner program (at least I think 
+ * it is compatible to SYS V) which I wrote to use with the clock 
+ * program written by:
+ **     DCF, Inc.
+ **     14623 North 49th Place
+ **     Scottsdale, AZ 85254
+ * and published in the net comp.sources.misc newsgroup in early July 
+ * since the BSD banner program works quite differently.
+ * There is no copyright or responsibility accepted for the use
+ * of this software.
+ * Brian Wallis, brw@jim.odr.oz, 4 July 1988
+ *****************************************************************/
+/* Changes by David Frey, david@eos.lugs.ch, 3 February 1997:
+ * 1. protoized and indented, 2. changed @ character to # 
+ */
+char *glyphs[] =
+{
+  "         ###  ### ###  # #   ##### ###   #  ##     ###  ",
+  "         ###  ### ###  # #  #  #  ## #  #  #  #    ###  ",
+  "         ###   #   # ########  #   ### #    ##      #   ",
+  "          #            # #   #####    #    ###     #    ",
+  "                     #######   #  #  # ####   # #       ",
+  "         ###           # #  #  #  # #  # ##    #        ",
+  "         ###           # #   ##### #   ### #### #       ",
+
+  "   ##    ##                                            #",
+  "  #        #   #   #    #                             # ",
+  " #          #   # #     #                            #  ",
+  " #          # ### ### #####   ###   #####           #   ",
+  " #          #   # #     #     ###           ###    #    ",
+  "  #        #   #   #    #      #            ###   #     ",
+  "   ##    ##                   #             ###  #      ",
+
+  "  ###     #    #####  ##### #      ####### ##### #######",
+  " #   #   ##   #     ##     ##    # #      #     ##    # ",
+  "# #   # # #         #      ##    # #      #          #  ",
+  "#  #  #   #    #####  ##### ####### ##### ######    #   ",
+  "#   # #   #   #            #     #       ##     #  #    ",
+  " #   #    #   #      #     #     # #     ##     #  #    ",
+  "  ###   ##### ####### #####      #  #####  #####   #    ",
+
+  " #####  #####    #     ###      #           #     ##### ",
+  "#     ##     #  # #    ###     #             #   #     #",
+  "#     ##     #   #            #     #####     #        #",
+  " #####  ######         ###   #                 #     ## ",
+  "#     #      #   #     ###    #     #####     #     #   ",
+  "#     ##     #  # #     #      #             #          ",
+  " #####  #####    #     #        #           #       #   ",
+
+  " #####    #   ######  ##### ###### ############## ##### ",
+  "#     #  # #  #     ##     ##     ##      #      #     #",
+  "# ### # #   # #     ##      #     ##      #      #      ",
+  "# # # ##     ####### #      #     ######  #####  #  ####",
+  "# #### ########     ##      #     ##      #      #     #",
+  "#     ##     ##     ##     ##     ##      #      #     #",
+  " ##### #     #######  ##### ###### ########       ##### ",
+
+  "#     #  #*#        ##    # #      #     ##     ########",
+  "#     #   #         ##   #  #      ##   ####    ##     #",
+  "#     #   #         ##  #   #      # # # ## #   ##     #",
+  "#######   #         ####    #      #  #  ##  #  ##     #",
+  "#     #   #   #     ##  #   #      #     ##   # ##     #",
+  "#     #   #   #     ##   #  #      #     ##    ###     #",
+  "#     #  ###   ##### #    # ########     ##     ########",
+
+  "######  ##### ######  ##### ########     ##     ##     #",
+  "#     ##     ##     ##     #   #   #     ##     ##  #  #",
+  "#     ##     ##     ##         #   #     ##     ##  #  #",
+  "###### #     #######  #####    #   #     ##     ##  #  #",
+  "#      #   # ##   #        #   #   #     # #   # #  #  #",
+  "#      #    # #    # #     #   #   #     #  # #  #  #  #",
+  "#       #### ##     # #####    #    #####    #    ## ## ",
+
+  "#     ##     ######## ##### #       #####    #          ",
+  " #   #  #   #      #  #      #          #   # #         ",
+  "  # #    # #      #   #       #         #  #   #        ",
+  "   #      #      #    #        #        #               ",
+  "  # #     #     #     #         #       #               ",
+  " #   #    #    #      #          #      #               ",
+  "#     #   #   ####### #####       # #####        #######",
+
+  "  ###                                                   ",
+  "  ###     ##   #####   ####  #####  ###### ######  #### ",
+  "   #     #  #  #    # #    # #    # #      #      #    #",
+  "    #   #    # #####  #      #    # #####  #####  #     ",
+  "        ###### #    # #      #    # #      #      #  ###",
+  "        #    # #    # #    # #    # #      #      #    #",
+  "        #    # #####   ####  #####  ###### #       #### ",
+
+  "                                                        ",
+  " #    #    #        # #    # #      #    # #    #  #### ",
+  " #    #    #        # #   #  #      ##  ## ##   # #    #",
+  " ######    #        # ####   #      # ## # # #  # #    #",
+  " #    #    #        # #  #   #      #    # #  # # #    #",
+  " #    #    #   #    # #   #  #      #    # #   ## #    #",
+  " #    #    #    ####  #    # ###### #    # #    #  #### ",
+
+  "                                                        ",
+  " #####   ####  #####   ####   ##### #    # #    # #    #",
+  " #    # #    # #    # #         #   #    # #    # #    #",
+  " #    # #    # #    #  ####     #   #    # #    # #    #",
+  " #####  #  # # #####       #    #   #    # #    # # ## #",
+  " #      #   #  #   #  #    #    #   #    #  #  #  ##  ##",
+  " #       ### # #    #  ####     #    ####    ##   #    #",
+
+  "                       ###     #     ###   ##    # # # #",
+  " #    #  #   # ###### #        #        # #  #  # # # # ",
+  "  #  #    # #      #  #        #        #     ## # # # #",
+  "   ##      #      #  ##                 ##        # # # ",
+  "   ##      #     #    #        #        #        # # # #",
+  "  #  #     #    #     #        #        #         # # # ",
+  " #    #    #   ######  ###     #     ###         # # # #"};
+
+int Vbanner(char *str)
+{
+  int a, b, c, len, ind;
+  char line[80];
+  len = strlen(str);
+  if (len > 10)
+    len = 10;
+  for (a = 0; a < 7; a++)
+  {
+    for (b = 0; b < len; b++)
+    {
+      if ((ind = str[b] - ' ') < 0)
+        ind = 0;
+      for (c = 0; c < 7; c++)
+      {
+         line[b * 8 + c] = glyphs[(ind / 8 * 7) + a][(ind % 8 * 7) + c];
+      }
+      line[b * 8 + 7] = ' ';
+    }
+    for (b = len * 8 - 1; b >= 0; b--)
+    {
+      if (line[b] != ' ')
+        break;
+      line[b] = '\0';
+    }
+    //puts(line);
+    Add("");
+    Replace(line);
+  }
+  //puts("");
+  Add("");
+  return 0;
+}
+
+/*
+ * The ultimative banner.
+ * Written in 1987 by Wolfgang Ocker, reccoware systems, Puchheim
+ * It's *not* fast, but nice ...
+ * Tested on OS-9/68000, SunOS
+ */
+void bannusage()
+{
+  display_error(0,"Syntax: banner [-v|-[c|d|i|s]|-h] {string} ",TRUE);
+}
+
+unsigned char charset[] = {
+  0, 0, 0, 0, 0, 0, 0, 0,
+  126, 129, 165, 129, 189, 153, 129, 126,
+  126, 255, 219, 255, 195, 231, 255, 126,
+  108, 254, 254, 254, 124, 56, 16, 0,
+  16, 56, 124, 254, 124, 56, 16, 0,
+  56, 124, 56, 254, 254, 124, 56, 124,
+  16, 16, 56, 124, 254, 124, 56, 124,
+  0, 0, 24, 60, 60, 24, 0, 0,
+  255, 255, 231, 195, 195, 231, 255, 255,
+  0, 60, 102, 66, 66, 102, 60, 0,
+  255, 195, 153, 189, 189, 153, 195, 255,
+  15, 7, 15, 125, 204, 204, 204, 120,
+  60, 102, 102, 102, 60, 24, 126, 24,
+  63, 51, 63, 48, 48, 112, 240, 224,
+  127, 99, 127, 99, 99, 103, 230, 192,
+  153, 90, 60, 231, 231, 60, 90, 153,
+  128, 224, 248, 254, 248, 224, 128, 0,
+  2, 14, 62, 254, 62, 14, 2, 0,
+  24, 60, 126, 24, 24, 126, 60, 24,
+  102, 102, 102, 102, 102, 0, 102, 0,
+  127, 219, 219, 123, 27, 27, 27, 0,
+  62, 99, 56, 108, 108, 56, 204, 120,
+  0, 0, 0, 0, 126, 126, 126, 0,
+  24, 60, 126, 24, 126, 60, 24, 255,
+  24, 60, 126, 24, 24, 24, 24, 0,
+  24, 24, 24, 24, 126, 60, 24, 0,
+  0, 24, 12, 254, 12, 24, 0, 0,
+  0, 48, 96, 254, 96, 48, 0, 0,
+  0, 0, 192, 192, 192, 254, 0, 0,
+  0, 36, 102, 255, 102, 36, 0, 0,
+  0, 24, 60, 126, 255, 255, 0, 0,
+  0, 255, 255, 126, 60, 24, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  48, 120, 120, 48, 48, 0, 48, 0,
+  108, 108, 108, 0, 0, 0, 0, 0,
+  108, 108, 254, 108, 254, 108, 108, 0,
+  48, 124, 192, 120, 12, 248, 48, 0,
+  0, 198, 204, 24, 48, 102, 198, 0,
+  56, 108, 56, 118, 220, 204, 118, 0,
+  96, 96, 192, 0, 0, 0, 0, 0,
+  24, 48, 96, 96, 96, 48, 24, 0,
+  96, 48, 24, 24, 24, 48, 96, 0,
+  0, 102, 60, 255, 60, 102, 0, 0,
+  0, 48, 48, 252, 48, 48, 0, 0,
+  0, 0, 0, 0, 0, 48, 48, 96,
+  0, 0, 0, 252, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 48, 48, 0,
+  6, 12, 24, 48, 96, 192, 128, 0,
+  124, 198, 206, 222, 246, 230, 124, 0,
+  48, 112, 48, 48, 48, 48, 252, 0,
+  120, 204, 12, 56, 96, 204, 252, 0,
+  120, 204, 12, 56, 12, 204, 120, 0,
+  28, 60, 108, 204, 254, 12, 30, 0,
+  252, 192, 248, 12, 12, 204, 120, 0,
+  56, 96, 192, 248, 204, 204, 120, 0,
+  252, 204, 12, 24, 48, 48, 48, 0,
+  120, 204, 204, 120, 204, 204, 120, 0,
+  120, 204, 204, 124, 12, 24, 112, 0,
+  0, 48, 48, 0, 0, 48, 48, 0,
+  0, 48, 48, 0, 0, 48, 48, 96,
+  24, 48, 96, 192, 96, 48, 24, 0,
+  0, 0, 252, 0, 0, 252, 0, 0,
+  96, 48, 24, 12, 24, 48, 96, 0,
+  120, 204, 12, 24, 48, 0, 48, 0,
+  124, 198, 222, 222, 222, 192, 120, 0,
+  48, 120, 204, 204, 252, 204, 204, 0,
+  252, 102, 102, 124, 102, 102, 252, 0,
+  60, 102, 192, 192, 192, 102, 60, 0,
+  248, 108, 102, 102, 102, 108, 248, 0,
+  254, 98, 104, 120, 104, 98, 254, 0,
+  254, 98, 104, 120, 104, 96, 240, 0,
+  60, 102, 192, 192, 206, 102, 62, 0,
+  204, 204, 204, 252, 204, 204, 204, 0,
+  120, 48, 48, 48, 48, 48, 120, 0,
+  30, 12, 12, 12, 204, 204, 120, 0,
+  230, 102, 108, 120, 108, 102, 230, 0,
+  240, 96, 96, 96, 98, 102, 254, 0,
+  198, 238, 254, 254, 214, 198, 198, 0,
+  198, 230, 246, 222, 206, 198, 198, 0,
+  56, 108, 198, 198, 198, 108, 56, 0,
+  252, 102, 102, 124, 96, 96, 240, 0,
+  120, 204, 204, 204, 220, 120, 28, 0,
+  252, 102, 102, 124, 108, 102, 230, 0,
+  120, 204, 224, 112, 28, 204, 120, 0,
+  252, 180, 48, 48, 48, 48, 120, 0,
+  204, 204, 204, 204, 204, 204, 252, 0,
+  204, 204, 204, 204, 204, 120, 48, 0,
+  198, 198, 198, 214, 254, 238, 198, 0,
+  198, 198, 108, 56, 56, 108, 198, 0,
+  204, 204, 204, 120, 48, 48, 120, 0,
+  254, 198, 140, 24, 50, 102, 254, 0,
+  120, 96, 96, 96, 96, 96, 120, 0,
+  192, 96, 48, 24, 12, 6, 2, 0,
+  120, 24, 24, 24, 24, 24, 120, 0,
+  16, 56, 108, 198, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 255,
+  48, 48, 24, 0, 0, 0, 0, 0,
+  0, 0, 120, 12, 124, 204, 118, 0,
+  224, 96, 96, 124, 102, 102, 220, 0,
+  0, 0, 120, 204, 192, 204, 120, 0,
+  28, 12, 12, 124, 204, 204, 118, 0,
+  0, 0, 120, 204, 252, 192, 120, 0,
+  56, 108, 96, 240, 96, 96, 240, 0,
+  0, 0, 118, 204, 204, 124, 12, 248,
+  224, 96, 108, 118, 102, 102, 230, 0,
+  48, 0, 112, 48, 48, 48, 120, 0,
+  12, 0, 12, 12, 12, 204, 204, 120,
+  224, 96, 102, 108, 120, 108, 230, 0,
+  112, 48, 48, 48, 48, 48, 120, 0,
+  0, 0, 204, 254, 254, 214, 198, 0,
+  0, 0, 248, 204, 204, 204, 204, 0,
+  0, 0, 120, 204, 204, 204, 120, 0,
+  0, 0, 220, 102, 102, 124, 96, 240,
+  0, 0, 118, 204, 204, 124, 12, 30,
+  0, 0, 220, 118, 102, 96, 240, 0,
+  0, 0, 124, 192, 120, 12, 248, 0,
+  16, 48, 124, 48, 48, 52, 24, 0,
+  0, 0, 204, 204, 204, 204, 118, 0,
+  0, 0, 204, 204, 204, 120, 48, 0,
+  0, 0, 198, 214, 254, 254, 108, 0,
+  0, 0, 198, 108, 56, 108, 198, 0,
+  0, 0, 204, 204, 204, 124, 12, 248,
+  0, 0, 252, 152, 48, 100, 252, 0,
+  28, 48, 48, 224, 48, 48, 28, 0,
+  24, 24, 24, 0, 24, 24, 24, 0,
+  224, 48, 48, 28, 48, 48, 224, 0,
+  118, 220, 0, 0, 0, 0, 0, 0,
+  0, 16, 56, 108, 198, 198, 254, 0,
+  120, 204, 192, 204, 120, 24, 12, 120,
+  0, 204, 0, 204, 204, 204, 126, 0,
+  28, 0, 120, 204, 252, 192, 120, 0,
+  126, 195, 60, 6, 62, 102, 63, 0,
+  204, 0, 120, 12, 124, 204, 126, 0,
+  224, 0, 120, 12, 124, 204, 126, 0,
+  48, 48, 120, 12, 124, 204, 126, 0,
+  0, 0, 120, 192, 192, 120, 12, 56,
+  126, 195, 60, 102, 126, 96, 60, 0,
+  204, 0, 120, 204, 252, 192, 120, 0,
+  224, 0, 120, 204, 252, 192, 120, 0,
+  204, 0, 112, 48, 48, 48, 120, 0,
+  124, 198, 56, 24, 24, 24, 60, 0,
+  224, 0, 112, 48, 48, 48, 120, 0,
+  198, 56, 108, 198, 254, 198, 198, 0,
+  48, 48, 0, 120, 204, 252, 204, 0,
+  28, 0, 252, 96, 120, 96, 252, 0,
+  0, 0, 127, 12, 127, 204, 127, 0,
+  62, 108, 204, 254, 204, 204, 206, 0,
+  120, 204, 0, 120, 204, 204, 120, 0,
+  0, 204, 0, 120, 204, 204, 120, 0,
+  0, 224, 0, 120, 204, 204, 120, 0,
+  120, 204, 0, 204, 204, 204, 126, 0,
+  0, 224, 0, 204, 204, 204, 126, 0,
+  0, 204, 0, 204, 204, 124, 12, 248,
+  195, 24, 60, 102, 102, 60, 24, 0,
+  204, 0, 204, 204, 204, 204, 120, 0,
+  24, 24, 126, 192, 192, 126, 24, 24,
+  56, 108, 100, 240, 96, 230, 252, 0,
+  204, 204, 120, 252, 48, 252, 48, 48,
+  248, 204, 204, 250, 198, 207, 198, 199,
+  14, 27, 24, 60, 24, 24, 216, 112,
+  28, 0, 120, 12, 124, 204, 126, 0,
+  56, 0, 112, 48, 48, 48, 120, 0,
+  0, 28, 0, 120, 204, 204, 120, 0,
+  0, 28, 0, 204, 204, 204, 126, 0,
+  0, 248, 0, 248, 204, 204, 204, 0,
+  252, 0, 204, 236, 252, 220, 204, 0,
+  60, 108, 108, 62, 0, 126, 0, 0,
+  56, 108, 108, 56, 0, 124, 0, 0,
+  48, 0, 48, 96, 192, 204, 120, 0,
+  0, 0, 0, 252, 192, 192, 0, 0,
+  0, 0, 0, 252, 12, 12, 0, 0,
+  195, 198, 204, 222, 51, 102, 204, 15,
+  195, 198, 204, 219, 55, 111, 207, 3,
+  24, 24, 0, 24, 24, 24, 24, 0,
+  0, 51, 102, 204, 102, 51, 0, 0,
+  0, 204, 102, 51, 102, 204, 0, 0,
+  34, 136, 34, 136, 34, 136, 34, 136,
+  85, 170, 85, 170, 85, 170, 85, 170,
+  219, 119, 219, 238, 219, 119, 219, 238,
+  24, 24, 24, 24, 24, 24, 24, 24,
+  24, 24, 24, 24, 248, 24, 24, 24,
+  24, 24, 248, 24, 248, 24, 24, 24,
+  54, 54, 54, 54, 246, 54, 54, 54,
+  0, 0, 0, 0, 254, 54, 54, 54,
+  0, 0, 248, 24, 248, 24, 24, 24,
+  54, 54, 246, 6, 246, 54, 54, 54,
+  54, 54, 54, 54, 54, 54, 54, 54,
+  0, 0, 254, 6, 246, 54, 54, 54,
+  54, 54, 246, 6, 254, 0, 0, 0,
+  54, 54, 54, 54, 254, 0, 0, 0,
+  24, 24, 248, 24, 248, 0, 0, 0,
+  0, 0, 0, 0, 248, 24, 24, 24,
+  24, 24, 24, 24, 31, 0, 0, 0,
+  24, 24, 24, 24, 255, 0, 0, 0,
+  0, 0, 0, 0, 255, 24, 24, 24,
+  24, 24, 24, 24, 31, 24, 24, 24,
+  0, 0, 0, 0, 255, 0, 0, 0,
+  24, 24, 24, 24, 255, 24, 24, 24,
+  24, 24, 31, 24, 31, 24, 24, 24,
+  54, 54, 54, 54, 55, 54, 54, 54,
+  54, 54, 55, 48, 63, 0, 0, 0,
+  0, 0, 63, 48, 55, 54, 54, 54,
+  54, 54, 247, 0, 255, 0, 0, 0,
+  0, 0, 255, 0, 247, 54, 54, 54,
+  54, 54, 55, 48, 55, 54, 54, 54,
+  0, 0, 255, 0, 255, 0, 0, 0,
+  54, 54, 247, 0, 247, 54, 54, 54,
+  24, 24, 255, 0, 255, 0, 0, 0,
+  54, 54, 54, 54, 255, 0, 0, 0,
+  0, 0, 255, 0, 255, 24, 24, 24,
+  0, 0, 0, 0, 255, 54, 54, 54,
+  54, 54, 54, 54, 63, 0, 0, 0,
+  24, 24, 31, 24, 31, 0, 0, 0,
+  0, 0, 31, 24, 31, 24, 24, 24,
+  0, 0, 0, 0, 63, 54, 54, 54,
+  54, 54, 54, 54, 255, 54, 54, 54,
+  24, 24, 255, 24, 255, 24, 24, 24,
+  24, 24, 24, 24, 248, 0, 0, 0,
+  0, 0, 0, 0, 31, 24, 24, 24,
+  255, 255, 255, 255, 255, 255, 255, 255,
+  0, 0, 0, 0, 255, 255, 255, 255,
+  240, 240, 240, 240, 240, 240, 240, 240,
+  15, 15, 15, 15, 15, 15, 15, 15,
+  255, 255, 255, 255, 0, 0, 0, 0,
+  0, 0, 118, 220, 200, 220, 118, 0,
+  0, 120, 204, 248, 204, 248, 192, 192,
+  0, 252, 204, 192, 192, 192, 192, 0,
+  0, 254, 108, 108, 108, 108, 108, 0,
+  252, 204, 96, 48, 96, 204, 252, 0,
+  0, 0, 126, 216, 216, 216, 112, 0,
+  0, 102, 102, 102, 102, 124, 96, 192,
+  0, 118, 220, 24, 24, 24, 24, 0,
+  252, 48, 120, 204, 204, 120, 48, 252,
+  56, 108, 198, 254, 198, 108, 56, 0,
+  56, 108, 198, 198, 108, 108, 238, 0,
+  28, 48, 24, 124, 204, 204, 120, 0,
+  0, 0, 126, 219, 219, 126, 0, 0,
+  6, 12, 126, 219, 219, 126, 96, 192,
+  56, 96, 192, 248, 192, 96, 56, 0,
+  120, 204, 204, 204, 204, 204, 204, 0,
+  0, 252, 0, 252, 0, 252, 0, 0,
+  48, 48, 252, 48, 48, 0, 252, 0,
+  96, 48, 24, 48, 96, 0, 252, 0,
+  24, 48, 96, 48, 24, 0, 252, 0,
+  14, 27, 27, 24, 24, 24, 24, 24,
+  24, 24, 24, 24, 24, 216, 216, 112,
+  48, 48, 0, 252, 0, 48, 48, 0,
+  0, 118, 220, 0, 118, 220, 0, 0,
+  56, 108, 108, 56, 0, 0, 0, 0,
+  0, 0, 0, 24, 24, 0, 0, 0,
+  0, 0, 0, 0, 24, 0, 0, 0,
+  15, 12, 12, 12, 236, 108, 60, 28 };
+
+char bannline[256];
+short banncnt;
+
+outline(outchar, outbyte, dblsize, bannerchar, samechar)
+  char outchar, outbyte, bannerchar;
+  int  dblsize, samechar;
+{
+  int bc, j;
+  for (bc = 7; bc >= 0; bc--)
+    for (j = 0; j < (dblsize ? 2 : 1); j++)
+      if (outbyte & (0x01 << bc))
+///*        putchar((samechar) ? outchar : bannerchar);*/
+      {
+        if (samechar)
+          bannline[banncnt] = outchar;
+        else
+          bannline[banncnt] = bannerchar;
+        banncnt++;
+      }
+      else
+///*        putchar(' ');*/
+      {
+        bannline[banncnt] = ' ';
+        banncnt++;
+      }
+}
+
+int bannstr(string)
+  char *string;
+{
+  char          *str;
+  int           linenum, chnum, i, j, k, count;
+  unsigned char ch;
+  int           ch_off;
+  unsigned char *ch_addr;
+  unsigned char *font;
+  int           italic, dblsize, samechar, sysv;
+  char          bannerchar;
+
+  italic     = dblsize = samechar = sysv = FALSE;
+  bannerchar = '*';
+  font       = charset;
+  str        = string;
+  if (string[0] == '-')
+  {
+    for (j = 1; (string[j] != ' ') && (j < strlen(string)); j++)
+    {
+      switch(tolower(string[j]))
+      {
+        case '?':
+        case 'h':
+          bannusage();
+          return(1);
+        case 'i': 	/* italic printing */
+          italic = TRUE;
+          break;          
+        case 'd': 	/* double sized characters */
+          dblsize = TRUE;
+          break;
+        case 's': 	/* use character to build large char, e.g.*/
+          samechar = TRUE;
+          break;
+        case 'v': 	/* SYS V */
+          sysv = TRUE;
+          break;
+        case 'c': 	/* character for banner */
+          j += string[j+1] == '=' ? 2 : 1;
+          bannerchar = string[j];
+          break;
+        default:
+          bannusage();
+          display_error(0,"banner: unknown option", TRUE);
+          return(1);
+      }
+    }
+    j++;
+    str = &string[j];
+    if (sysv)
+    {
+      Vbanner(str);
+      while ((i = strlen(str)) > 10)
+      {
+        str += 10;
+        Vbanner(str);
+      }
+      return 0;
+    }
+  }
+  while (TRUE)
+  {
+    for (linenum = 0; linenum < 8; linenum++) 	/* 8 lines per char */
+    {
+      for (j = 0; j < (dblsize ? 2 : 1); j++)
+      {
+        banncnt = 0;
+///*      putchar('\n');*/
+        if (italic) 	/* shift for italics */
+          for (k = linenum; k < 7; k++)
+///*          fputs(dblsize ? "  " : " ", stdout);*/
+          {
+            if (dblsize)
+            {
+              bannline[banncnt] = ' ';
+              banncnt++;
+            }
+            bannline[banncnt] = ' ';
+            banncnt++;
+          }
+        for (chnum = 0; chnum < strlen(str); chnum++)
+        {
+          ch      = str[chnum];
+          ch_off  = (int) ch * 8;
+          ch_addr = font + ch_off + linenum;
+          outline(ch, *ch_addr, dblsize, bannerchar, samechar);
+          if (banncnt > (dblsize ? 240 : 248))
+            break;
+        }
+        bannline[banncnt] = '\0';
+        Add("");
+        Replace(bannline);
+      }
+    }
+    if (banncnt > 240)
+      str += (dblsize ? 16 : 32);
+    else
+      break;
+  }
+///*  putchar('\n');*/
+  return 0;
+}
+/*man-start*********************************************************************
+COMMAND
+     banner - insert banner to current line
+
+SYNTAX
+     BANNER [-v|-[c|d|i|s]] {string}
+
+DESCRIPTION
+     Options:
+       -c=<char> use character
+       -d        double size
+       -i        prints italic
+       -s        use same character
+       -v        use SYS V classic (split when length = 10)
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Banner(CHARTYPE *params)
+#else
+short Banner(params)
+CHARTYPE *params;
+#endif
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   Banner");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)params,FALSE);
+    bannusage();
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  rc = bannstr(params);
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      bottom - move to the bottom of the file
@@ -581,6 +1312,183 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     calc - interactive calculator
+
+SYNTAX
+     CALC
+
+SEE ALSO
+     <EVAL>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+extern void evalini();
+extern char *calchlp[];
+#ifdef HAVE_PROTO
+short Calc(CHARTYPE *params)
+#else
+short Calc(params)
+CHARTYPE *params;
+#endif
+{
+#define CHLP_NUM 24
+  WINDOW *fw=NULL, *dw=NULL, *cw=NULL, *lw=NULL;
+  short height=0,width=0,y=0,x=0;
+  CHARTYPE buf[133], last[133], clp[66];
+  CHARTYPE *idx=NULL, *res=NULL;
+  unsigned short i=0, j=0;
+  bool exit=FALSE;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm1.c:   Calc");
+  if (strcmp((DEFCHAR *)params,"") != 0)
+  {
+    display_error(1,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  height = terminal_lines/2;
+  width = terminal_cols/2;
+  y = height/2;
+  x = width/2;
+  fw = newwin(height,width,y,x);
+  if (fw == NULL)
+  {
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  wattrset(fw,set_colour(CURRENT_FILE->attr+ATTR_DIVIDER));
+  wclrtobot(fw);
+  box(fw,0,0);
+  wnoutrefresh(fw);
+  height -= 2;
+  width -= 2;
+  y++;
+  x++;
+  dw = newwin(height,width,y,x);
+  if (dw == NULL)
+  {
+    delwin(fw);
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  scrollok(dw,TRUE);
+  wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+  wclrtobot(dw);
+  wnoutrefresh(dw);
+  evalini();
+  i = 0;
+  wmove(dw,0,1);
+  waddstr(dw,"Type expression, 'help' or 'exit'.");
+//#ifdef DOS
+//  NoMouse = TRUE;
+//#endif
+  dialogw = TRUE;
+  while (!exit)
+  {
+    if (buf[0] == '=')
+      strcpy((DEFCHAR *)buf, (DEFCHAR *)last);
+    else
+    {
+      strcpy((DEFCHAR *)buf, "");
+      i++;
+    }
+    if (i==height)
+    {
+      scroll(dw);
+      i--;
+    }
+    wmove(dw,i,0);
+    wrefresh(dw);
+    lw = newwin(1,width,y+i,x);
+    if (lw != NULL)
+    {
+      cw = CURRENT_WINDOW_COMMAND;
+      CURRENT_WINDOW_COMMAND = lw;
+      wattrset(lw, set_colour(CURRENT_FILE->attr+ATTR_DIALOG));
+      rc = readv_cmdline(buf, lw, 1);
+      memcpy((DEFCHAR *)buf, (DEFCHAR *)cmd_rec, cmd_rec_len);
+      buf[cmd_rec_len] = '\0';
+      if (buf[0]=='\0' && last[0]=='\0')
+        strcpy(buf, "exit");
+      if (buf[0] != '=')
+        strcpy((DEFCHAR *)last, (DEFCHAR *)buf);
+      CURRENT_WINDOW_COMMAND = cw;
+      delwin(lw);
+    }
+    if (buf[0] == '=')
+      continue;
+    if (strcmp(buf, "exit")==0)
+    {
+      exit = TRUE;
+/*
+#if defined(PDC_CLIP_SUCCESS)
+      if ((char *)res != NULL)
+      {
+        strcpy((DEFCHAR *)clp, (DEFCHAR *)"PUT ");
+        strcpy(&clp[4], (DEFCHAR *)res);
+        Clipboard((DEFCHAR *)clp);
+      }
+#endif
+*/
+    }
+    if (strcmp(buf, "help")==0)
+    {
+      wclear(stdscr);
+      attrset(A_BOLD);
+      for (j=0; j<CHLP_NUM; j++)
+        mvaddstr(j,0,(DEFCHAR *)calchlp[j]);
+      attrset(A_NORMAL);
+      while ((j=my_getch(stdscr)) == 0);
+      refresh();
+      THERefresh((CHARTYPE *)"");
+      box(fw,0,0);
+      wnoutrefresh(fw);
+      redrawwin(dw);
+      continue;
+    }
+    idx = strstr(buf, ';');
+    while (idx != NULL)
+    {
+      idx[0] = '\0';
+      eval((DEFCHAR *)buf, &res);
+      idx++;
+      strcpy((DEFCHAR *)buf, (DEFCHAR *)idx);
+      idx = strstr(buf, ';');
+    }
+    eval((DEFCHAR *)buf, &res);
+    strcpy((DEFCHAR *)buf, (DEFCHAR *)last);
+    wmove(dw,i,0);
+    waddstr(dw, buf);
+    wmove(dw,i,0);
+    scroll(dw);
+    waddstr(dw, " =");
+    waddstr(dw, res);
+  }
+  dialogw = FALSE;
+//#ifdef DOS
+//  NoMouse = FALSE;
+//#endif
+  delwin(dw);
+  delwin(fw);
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  my_wclrtoeol(CURRENT_WINDOW_COMMAND);
+  memset(cmd_rec,' ',max_line_length);
+  cmd_rec_len = 0;
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  CURRENT_VIEW->cmdline_col = -1;
+  THERefresh((CHARTYPE *)"");
+  restore_THE();
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      cancel - quit from all unaltered files in the ring
@@ -759,6 +1667,12 @@
       TRACE_RETURN();
       return(RC_INVALID_OPERAND);
    }
+#ifdef GYMOD
+   if (display_screens>1 && number_of_files>1 && current_screen==0)
+   {
+     Nextwindow((CHARTYPE *)"");
+   }
+#endif //GYMOD
    CURRENT_VIEW = vd_first;
    while ( CURRENT_VIEW != (VIEW_DETAILS *)NULL )
    {
@@ -911,6 +1825,1048 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     center - center text in target area between current MARGINs
+
+SYNTAX
+     CEnter [target]
+
+SEE ALSO
+     <LEFTADJUST>, <RIGHTADJUST>, <JUSTIFY>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Center(CHARTYPE *params)
+#else
+short Center(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   center");
+ rc = Format(params,0,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
+#define ZEROLEN(string) (*string == '\0')
+#ifdef HAVE_PROTO
+void JustFill(char *s, int size)
+#else
+void JustFill(s, size)
+char *s;
+int size;
+#endif
+{
+ static int fromleft = 0;       /* alternate sides */
+ char *cp;
+ int blanks = size - strlen(s);
+ if (blanks < 0) return;
+ fromleft++;
+ if (strchr(s, ' ') == NULL) return;    /* cant justify single word line */
+ if (fromleft & 1)   /* insert from left */
+ {
+   while (blanks)
+   {
+     cp = s;    /* start at left edge */
+     while (blanks)
+     {
+       while (*cp != ' ' && !ZEROLEN(cp)) cp++; /* find a blank */
+       if (ZEROLEN(cp)) break;  /* need another pass */
+       memmove(cp+1, cp, strlen(cp)+1); /* insert a space */
+       while (*++cp == ' ');    /* skip past spaces */
+       blanks--;
+     }
+   }
+ }
+ else  /* insert from right */
+ {
+   while (blanks)
+   {
+     cp = s + strlen(s) - 1;    /* start at right edge */
+     while (blanks)
+     {
+       while (*cp != ' ' && cp >= s) cp--;      /* find a blank */
+       if (cp < s) break;       /* need another pass */
+       memmove(cp+1, cp, strlen(cp)+1); /* insert a space */
+       while (*--cp == ' ');    /* skip past spaces */
+       blanks--;
+     }
+   }
+ }
+}
+
+#ifdef HAVE_PROTO
+void lv1ws(char *str)
+#else
+void lv1ws(str)
+char *str;
+#endif
+{
+  char *ibuf, *obuf;
+  int i, cnt;
+  if (str)
+  {
+    ibuf = obuf = str;
+    i = cnt = 0;
+    while(*ibuf)
+    {
+      if(isspace(*ibuf) && cnt)
+         ibuf++;
+      else
+      {
+        if (!isspace(*ibuf))
+          cnt = 0;
+        else
+        {
+          *ibuf = ' ';
+          cnt = 1;
+        }
+        obuf[i++] = *ibuf++;
+      }
+    }
+    obuf[i] = '\0';
+  }
+}
+
+/*
+//#ifdef HAVE_PROTO
+//int rle_en(char *dest, char *src, int srclen)
+//#else
+//int rle_en(dest, src, srclen)
+//char *dest;
+//char *src;
+//int srclen;
+//#endif
+//{
+//  short i=0, j=0, k=0, n=0;
+//  char ch;
+//  while (i<srclen)
+//  {
+//    ch = src[i];
+//    k = 0;
+//    if (ch==1)
+//    {
+//      dest[n++] = ch;
+//      i++;
+//      k++;
+//      ch= 2;
+//    }
+//    while ((i<srclen) && (src[i]==ch))
+//    {
+//      k++;
+//      i++;
+//    }
+//    if ((k>3) && (k<0xFF))
+//    {
+//      dest[n++] = 1;
+//      dest[n++] = k;
+//      k = 1;
+//    }
+//    for (j=0; j<k; j++)
+//      dest[n++] = ch;
+//  }
+//  return n;
+//}
+//
+//#ifdef HAVE_PROTO
+//int rle_de(char *dest, char *src, int srclen)
+//#else
+//int rle_de(dest, src, srclen)
+//char *dest;
+//char *src;
+//int srclen;
+//#endif
+//{
+//  short i=0, j=0, k=0, n=0;
+//  char ch;
+//  while (i<srclen)
+//  {
+//    k = 1;
+//    ch = src[i];
+//    i++;
+//    if (ch==1)
+//    {
+//      ch = src[i];
+//      if (ch==2)
+//      {
+//        ch=1;
+//        i++;
+//      }
+//      else
+//      {
+//        k = ch;
+//        i++;
+//        ch = src[i];
+//        k--;
+//      }
+//    }
+//    for (j=0; j<k; j++)
+//      dest[n++] = ch;
+//  }
+//  return n;
+//}
+*/
+
+//*START_LZF*/
+#ifndef LZF_H
+#define LZF_H
+
+//* Written by Marc Lehmann <pcg@goof.com> (http://liblzf.plan9.de/).
+
+#define STANDALONE /* at the moment, this is ok. */
+
+#ifndef STANDALONE
+# include "lzf.h"
+#endif
+
+/*
+ * size of hashtable is (1 << HLOG) * sizeof (char *)
+ * decompression is independent of the hash table size
+ * the difference between 15 and 14 is very small
+ * for small blocks (and 14 is also faster).
+ * For a low-memory configuration, use HLOG == 13;
+ * For best compression, use 15 or 16.
+ */
+#ifndef HLOG
+# define HLOG 14
+#endif
+
+/*
+ * sacrifice some compression quality in favour of compression speed.
+ * (roughly 1-2% worse compression for large blocks and
+ * 9-10% for small, redundant, blocks and >>20% better speed in both cases)
+ * In short: enable this for binary data, disable this for text data.
+ */
+#ifndef ULTRA_FAST
+# define ULTRA_FAST 1
+#endif
+
+/*
+ * unconditionally aligning does not cost very much, so do it if unsure
+ */
+#ifndef STRICT_ALIGN
+# define STRICT_ALIGN !defined(__i386)
+#endif
+
+/*
+ * use string functions to copy memory.
+ * this is usually a loss, even with glibc's optimized memcpy
+ */
+#ifndef USE_MEMCPY
+# define USE_MEMCPY 0
+#endif
+
+/*
+ * you may choose to pre-set the hash table (might be faster on modern cpus
+ * and large (>>64k) blocks)
+ */
+#ifndef INIT_HTAB
+# define INIT_HTAB 0
+#endif
+
+/*
+ * avoid assigning values to errno variable? for some embedding purposes
+ * (linux kernel for example), this is neccessary. NOTE: this breaks
+ * the documentation in lzf.h.
+ */
+#ifndef AVOID_ERRNO
+# define AVOID_ERRNO 0
+#endif
+
+/*
+ * Wether to pass the LZF_STATE variable as argument, or allocate it
+ * on the stack. For small-stack environments, define this to 1.
+ * NOTE: this breaks the prototype in lzf.h.
+ */
+#ifndef LZF_STATE_ARG
+# define LZF_STATE_ARG 0
+#endif
+
+/*****************************************************************************/
+/* nothing should be changed below */
+
+typedef unsigned char u8;
+
+typedef const u8 *LZF_STATE[1 << (HLOG)];
+
+#if !STRICT_ALIGN
+/* for unaligned accesses we need a 16 bit datatype. */
+# include <limits.h>
+# if USHRT_MAX == 65535
+    typedef unsigned short u16;
+# elif UINT_MAX == 65535
+    typedef unsigned int u16;
+# else
+#  undef STRICT_ALIGN
+#  define STRICT_ALIGN 1
+# endif
+#endif
+
+#if USE_MEMCPY || INIT_HTAB
+# include <string.h>
+#endif
+
+#endif //LZF_H
+
+#define HSIZE (1 << (HLOG))
+
+/*
+ * don't play with this unless you benchmark!
+ * decompression is not dependent on the hash function
+ * the hashing function might seem strange, just believe me
+ * it works ;)
+ */
+#define FRST(p) (((p[0]) << 8) + p[1])
+#define NEXT(v,p) (((v) << 8) + p[2])
+#define IDX(h) ((((h ^ (h << 5)) >> (3*8 - HLOG)) + h*3) & (HSIZE - 1))
+/*
+ * IDX works because it is very similar to a multiplicative hash, e.g.
+ * (h * 57321 >> (3*8 - HLOG))
+ * the next one is also quite good, albeit slow ;)
+ * (int)(cos(h & 0xffffff) * 1e6)
+ */
+
+#if 0
+/* original lzv-like hash function */
+# define FRST(p) (p[0] << 5) ^ p[1]
+# define NEXT(v,p) ((v) << 5) ^ p[2]
+# define IDX(h) ((h) & (HSIZE - 1))
+#endif
+
+#define        MAX_LIT        (1 <<  5)
+#define        MAX_OFF        (1 << 13)
+#define        MAX_REF        ((1 <<  8) + (1 << 3))
+
+/*
+ * compressed format
+ *
+ * 000LLLLL <L+1>    ; literal
+ * LLLOOOOO oooooooo ; backref L
+ * 111OOOOO LLLLLLLL oooooooo ; backref L+7
+ *
+ */
+
+unsigned int
+lzf_compress (const void *const in_data, unsigned int in_len,
+	      void *out_data, unsigned int out_len
+#if LZF_STATE_ARG
+              , LZF_STATE *htab
+#endif
+              )
+{
+#if !LZF_STATE_ARG
+  LZF_STATE htab;
+#endif
+  const u8 **hslot;
+  const u8 *ip = (const u8 *)in_data;
+        u8 *op = (u8 *)out_data;
+  const u8 *in_end  = ip + in_len;
+        u8 *out_end = op + out_len;
+  const u8 *ref;
+
+  unsigned int hval = FRST (ip);
+  unsigned long off;
+           int lit = 0;
+
+#if INIT_HTAB
+# if USE_MEMCPY
+    memset (htab, 0, sizeof (htab));
+# else
+    for (hslot = htab; hslot < htab + HSIZE; hslot++)
+      *hslot++ = ip;
+# endif
+#endif
+
+  for (;;)
+    {
+      if (ip < in_end - 2)
+        {
+          hval = NEXT (hval, ip);
+          hslot = htab + IDX (hval);
+          ref = *hslot; *hslot = ip;
+
+          if (1
+#if INIT_HTAB && !USE_MEMCPY
+              && ref < ip /* the next test will actually take care of this, but this is faster */
+#endif
+              && (off = ip - ref - 1) < MAX_OFF
+              && ip + 4 < in_end
+              && ref > (u8 *)in_data
+#if STRICT_ALIGN
+              && ref[0] == ip[0]
+              && ref[1] == ip[1]
+              && ref[2] == ip[2]
+#else
+              && *(u16 *)ref == *(u16 *)ip
+              && ref[2] == ip[2]
+#endif
+            )
+            {
+              /* match found at *ref++ */
+              unsigned int len = 2;
+              unsigned int maxlen = in_end - ip - len;
+              maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;
+
+              do
+                len++;
+              while (len < maxlen && ref[len] == ip[len]);
+
+              if (op + lit + 1 + 3 >= out_end)
+                return 0;
+
+              if (lit)
+                {
+                  *op++ = lit - 1;
+                  lit = -lit;
+                  do
+                    *op++ = ip[lit];
+                  while (++lit);
+                }
+
+              len -= 2;
+              ip++;
+
+              if (len < 7)
+                {
+                  *op++ = (off >> 8) + (len << 5);
+                }
+              else
+                {
+                  *op++ = (off >> 8) + (  7 << 5);
+                  *op++ = len - 7;
+                }
+
+              *op++ = off;
+
+#if ULTRA_FAST
+              ip += len;
+              hval = FRST (ip);
+              hval = NEXT (hval, ip);
+              htab[IDX (hval)] = ip;
+              ip++;
+#else
+              do
+                {
+                  hval = NEXT (hval, ip);
+                  htab[IDX (hval)] = ip;
+                  ip++;
+                }
+              while (len--);
+#endif
+              continue;
+            }
+        }
+      else if (ip == in_end)
+        break;
+
+      /* one more literal byte we must copy */
+      lit++;
+      ip++;
+
+      if (lit == MAX_LIT)
+        {
+          if (op + 1 + MAX_LIT >= out_end)
+            return 0;
+
+          *op++ = MAX_LIT - 1;
+#if USE_MEMCPY
+          memcpy (op, ip - MAX_LIT, MAX_LIT);
+          op += MAX_LIT;
+          lit = 0;
+#else
+          lit = -lit;
+          do
+            *op++ = ip[lit];
+          while (++lit);
+#endif
+        }
+    }
+
+  if (lit)
+    {
+      if (op + lit + 1 >= out_end)
+	return 0;
+
+      *op++ = lit - 1;
+      lit = -lit;
+      do
+	*op++ = ip[lit];
+      while (++lit);
+    }
+
+  return op - (u8 *) out_data;
+}
+
+#if AVOID_ERRNO
+# define SET_ERRNO(n)
+#else
+# include <errno.h>
+# define SET_ERRNO(n) errno = (n)
+#endif
+
+unsigned int 
+lzf_decompress (const void *const in_data,  unsigned int in_len,
+                void             *out_data, unsigned int out_len)
+{
+  u8 const *ip = (const u8 *)in_data;
+  u8       *op = (u8 *)out_data;
+  u8 const *const in_end  = ip + in_len;
+  u8       *const out_end = op + out_len;
+
+  do
+    {
+      unsigned int ctrl = *ip++;
+
+      if (ctrl < (1 << 5)) /* literal run */
+        {
+          ctrl++;
+
+          if (op + ctrl > out_end)
+            {
+              SET_ERRNO (E2BIG);
+              return 0;
+            }
+
+#if USE_MEMCPY
+          memcpy (op, ip, ctrl);
+          op += ctrl;
+          ip += ctrl;
+#else
+          do
+            *op++ = *ip++;
+          while (--ctrl);
+#endif
+        }
+      else /* back reference */
+        {
+          unsigned int len = ctrl >> 5;
+
+          u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;
+
+          if (len == 7)
+            len += *ip++;
+          
+          ref -= *ip++;
+
+          if (op + len + 2 > out_end)
+            {
+              SET_ERRNO (E2BIG);
+              return 0;
+            }
+
+          if (ref < (u8 *)out_data)
+            {
+              SET_ERRNO (EINVAL);
+              return 0;
+            }
+
+          *op++ = *ref++;
+          *op++ = *ref++;
+
+          do
+            *op++ = *ref++;
+          while (--len);
+        }
+    }
+  while (op < out_end && ip < in_end);
+
+  return op - (u8 *)out_data;
+}
+
+#define MAX_COMPR_LEN  32700
+
+int comprstr(char *out, char *in, int len)
+{
+  int i, j, k;
+  i = lzf_compress(in, len, out, MAX_COMPR_LEN);
+  for (j=0; j<i; j++)
+  {
+    if (out[j] == '\0'
+    || out[j] == 0x0A
+    || out[j] == 0x0D
+    || out[j] == 0x7F)
+    {
+      i++;
+      for (k=i; k>(j+1); k--)
+        out[k] = out[k-1];
+      switch(out[j])
+      {
+        case 0:
+          out[j] = 0x7F;
+          out[j+1] = 1;
+          break;
+        case 0x0A:
+          out[j] = 0x7F;
+          out[j+1] = 2;
+          break;
+        case 0x0D:
+          out[j] = 0x7F;
+          out[j+1] = 3;
+          break;
+        default:
+          out[j+1] = 4;
+          break;
+      }
+    }
+  }
+  return i;
+}
+
+int decomprstr(char *out, char *in, int len)
+{
+  int i, j, k;
+  i = len;
+  for (j=0; j<i; j++)
+  for (j=0; j<i; j++)
+  {
+    if (in[j] == 0x7F)
+    {
+      switch(in[j+1])
+      {
+        case 1:
+          in[j] = 0;
+          break;
+        case 2:
+          in[j] = 0x0A;
+          break;
+        case 3:
+          in[j] = 0x0D;
+          break;
+        default:
+          break;
+      }
+      for (k=j+1; k<i; k++)
+        in[k] = in[k+1];
+    }
+  }
+  i = lzf_decompress(in, i, out, MAX_COMPR_LEN);
+  return i;
+}
+
+//*END_LZF*/
+
+#ifdef HAVE_PROTO
+short Format(CHARTYPE *params, short frm, bool aalt)
+#else
+short Format(params, frm, aalt)
+CHARTYPE *params;
+short frm;
+bool aalt;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ LINETYPE num_lines=0L,true_line=0L,num_actual_lines=0L,i=0L,num_file_lines=0L;
+ short direction=0;
+ LINE *curr=NULL;
+ LENGTHTYPE start_col=0,end_col=0;
+ CHARTYPE *tmpstr=NULL;
+ TARGET target;
+ short target_type=TARGET_NORMAL|TARGET_BLOCK_CURRENT|TARGET_ALL;
+ bool lines_based_on_scope=TRUE;
+ bool adjust_alt=FALSE;
+ bool incomm;
+ bool rewrite=TRUE;
+ int leftborder, rightborder;
+ register int j;
+ int k,l;
+ char k0, k1, k2;
+ CHARTYPE *ptr=NULL;
+ char tmplst[12]="";
+ #define KEYLEN 17
+ char key[KEYLEN]="_*gYmOd_EnCrYpT*_";
+ short rc=RC_OK;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm1.c:   format");
+ incomm = (bool)(CURRENT_VIEW->current_window == WINDOW_COMMAND);
+ if (strcmp("",(DEFCHAR *)params) == 0)
+    params = (CHARTYPE *)"+1";
+ leftborder = CURRENT_VIEW->margin_left;
+ rightborder= CURRENT_VIEW->margin_right;
+ initialise_target(&target);
+ if ((rc = validate_target(params,&target,target_type,get_true_line(TRUE),TRUE,TRUE)) != RC_OK)
+ {
+    free_target(&target);
+    TRACE_RETURN();
+    return(rc);
+ }
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ /*
+  * Determine in which direction we are working.
+  */
+ if (target.num_lines < 0L)
+ {
+    direction = DIRECTION_BACKWARD;
+    num_lines = target.num_lines * (-1L);
+ }
+ else
+ {
+    direction = DIRECTION_FORWARD;
+    num_lines = target.num_lines;
+ }
+ true_line = target.true_line;
+ /*
+  * If the target is BLOCK set the left and right margins to be the
+  * margins of the BOX BLOCK, otherwise use ZONE settings.
+  */
+ start_col = CURRENT_VIEW->zone_start-1;
+ end_col = CURRENT_VIEW->zone_end-1;
+ if (target.rt[0].target_type == TARGET_BLOCK_CURRENT)
+ {
+    num_lines = MARK_VIEW->mark_end_line-MARK_VIEW->mark_start_line+1L;
+    true_line = MARK_VIEW->mark_start_line;
+    direction = DIRECTION_FORWARD;
+    lines_based_on_scope = FALSE;
+//  if (MARK_VIEW->mark_type != M_LINE)
+//  {
+//     start_col = MARK_VIEW->mark_start_col-1;
+//     end_col   = MARK_VIEW->mark_end_col-1;
+//  }
+    if (MARK_VIEW->mark_type == M_BOX)
+    {
+       leftborder = MARK_VIEW->mark_start_col;
+       rightborder= MARK_VIEW->mark_end_col;
+    }
+ }
+ /*
+  * Find the current LINE pointer for the true_line.
+  * This is the first line to format.
+  */
+ curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+ /*
+  * Change the case for the target lines and columns...
+  */
+ for (i=0L,num_actual_lines=0L;;i++)
+ {
+    if (lines_based_on_scope)
+    {
+       if (num_actual_lines == num_lines)
+          break;
+    }
+    else
+    {
+       if (num_lines == i)
+          break;
+    }
+    rc = processable_line(CURRENT_VIEW,true_line+(LINETYPE)(i*direction),curr);
+    switch(rc)
+    {
+       case LINE_SHADOW:
+          break;
+/*     case LINE_TOF_EOF: MH12 */
+       case LINE_TOF:
+       case LINE_EOF:
+          num_actual_lines++;
+          break;
+       default:
+          if ((tmpstr = (CHARTYPE *)(*the_malloc)(max_line_length)) == NULL)
+          {
+            display_error(30,(CHARTYPE *)"",FALSE);
+            TRACE_RETURN();
+            return(RC_OUT_OF_MEMORY);
+          }
+          tmpstr[0] = 0;
+          if (frm>F_UNESC)
+          {
+            for (j=0; j<curr->length; j++)
+            {
+              if (curr->line[j] == 0)
+                curr->line[j] = ' ';
+            }
+          }
+/*          add_to_recovery_list(curr->line,curr->length);*/
+//        if ( MARK_VIEW
+//        &&  ( MARK_VIEW->mark_type == M_STREAM || MARK_VIEW->mark_type == M_CUA ) )
+//        {
+//           int mystart=0,myend=curr->length-1;
+//           if (true_line + i == MARK_VIEW->mark_start_line)
+//              mystart = start_col;
+//           if (true_line + i == MARK_VIEW->mark_end_line)
+//              myend = end_col;
+//        }
+          switch(frm)
+          {
+             case F_CENTER:
+                k = rightborder - leftborder;
+                l = curr->length;
+                j = 0;
+                while (isspace(curr->line[j]))
+                {
+                  j++;
+                }
+                l -= j;
+                if ((k > 0) && (l <= k))
+                {
+                  k = (int)((k-l)/2) + leftborder;
+                  for (j=1; j<=k; j++)
+                  {
+/*                    strcat(tmpstr,(CHARTYPE *)" ");*/
+                    tmpstr[j-1] = ' ';
+                    tmpstr[j] = 0;
+                  }
+                }
+                strcat(tmpstr,curr->line+(curr->length-l));
+                break;
+             case F_LEFT:
+             case F_UNJUST:
+                for (j=1; j<leftborder; j++)
+                {
+                  tmpstr[j-1] = ' ';
+                  tmpstr[j] = 0;
+                }
+                j = 0;
+                while (isspace(curr->line[j])
+                       && (j<min(curr->length,end_col+1)))
+                {
+                  j++;
+                }
+                strcat(tmpstr,curr->line+j);
+                if (frm==F_UNJUST)
+                {
+                  while (tmpstr[j]!=0)
+                  {
+                    if (isspace(tmpstr[j]))
+                    {
+                      while (isspace(tmpstr[j+1]))
+                      {
+                        strcpy(tmpstr+j,tmpstr+j+1);
+                      }
+                    }
+                    j++;
+                  }
+                }
+                break;
+             case F_RIGHT:
+                k = rightborder - curr->length;
+                if (k > 0)
+                {
+                  for (j=0; j<k; j++)
+                  {
+                    tmpstr[j] = ' ';
+                    tmpstr[j+1] = 0;
+                  }
+                }
+                strcat(tmpstr,curr->line);
+                break;
+             case F_TRUNC:
+                strcpy(tmpstr,curr->line);
+                j = curr->length-1;
+                // while ((j>=0) && isspace(tmpstr[j]))
+                while ((j>=0) && (tmpstr[j]==' ' || tmpstr[j]=='\t'))
+                {
+                  tmpstr[j] = 0;
+                  j--;
+                }
+                break;
+             case F_JUST:
+                k = rightborder - leftborder;
+                l = curr->length;
+                if (l == 0)
+                {
+                  strcpy(tmpstr,curr->line);
+                  break;
+                }
+                j = 0;
+                while (isspace(curr->line[j++])) ;
+                l -= j;
+                if ((k > 0) && (l <= k))
+                {
+                  for (j=1; j<leftborder; j++)
+                  {
+                    tmpstr[j-1] = ' ';
+                    tmpstr[j] = 0;
+                  }
+                  j = 0;
+                  while (isspace(curr->line[j])
+                         && (j<min(curr->length,end_col+1)))
+                  {
+                    j++;
+                  }
+                  strcat(tmpstr,curr->line+j);
+                  JustFill(tmpstr+leftborder,k);
+                }
+                else
+                  strcpy(tmpstr,curr->line);
+                break;
+             case F_1SPC:
+                strcpy(tmpstr,curr->line);
+                lv1ws(tmpstr);
+                break;
+             case F_TOBIN:
+             case F_TODEC:
+             case F_TOHEX:
+                if (frm==F_TOBIN)
+                  l = 2;
+                else if (frm==F_TODEC)
+                  l = 10;
+                else
+                  l = 16;
+                for (j=0; j<curr->length; j++)
+                {
+                  if ((strlen(tmpstr)+13) > max_line_length)
+                  {
+                    strcpy(tmpstr,curr->line);
+                    break;
+                  }
+                  itoa_dj(curr->line[j], tmplst, l);
+                  strcat(tmplst, ", ");
+                  if (l==2)
+                    strcat(tmpstr, "0b");
+                  if (l==16)
+                    strcat(tmpstr, "0x");
+                  strcat(tmpstr, tmplst);
+                }
+                break;
+             case F_TOCHR:
+                ptr = curr->line;
+                if (isdigit(ptr[0]) &&
+                    ((isdigit(ptr[1]) || ptr[1]==',')
+                     || (ptr[0]=='0' && (ptr[1]=='x' || ptr[1]=='b'))))
+                {
+                  do
+                  {
+                    while ((ptr<(curr->line+curr->length)) && (ptr[0]==' '))
+                      ptr++;
+                    // j = atoi(ptr);
+                    if (ptr[1]=='b')
+                    {
+                      ptr += 2;
+                      j = strtol(ptr, NULL, 2);
+                    }
+                    else
+                      j = strtol(ptr, NULL, 0);
+                    tmplst[0] = (char)j;
+                    tmplst[1] = 0;
+                    strcat(tmpstr, tmplst);
+                    while ((ptr<(curr->line+curr->length)) && (ptr[0]!=','))
+                      ptr++;
+                    if (ptr[0]==',')
+                      ptr++;
+                  } while (ptr<(curr->line+curr->length));
+                }
+                else
+                  strcpy(tmpstr,curr->line);
+                break;
+             case F_UNESC:
+                tmpstr = ansicstr(curr->line, curr->length);
+                break;
+             case F_CRYPT:
+                rewrite = FALSE;
+                k=1;
+                for (j=0; j<curr->length; j++)
+                {
+                  k1 = curr->line[j];
+                  if (k1>0x1F)
+                  {
+                    k2 = key[k-1] + (j%k)+i;
+                    k2 &= 0x1F; //31.
+                    k0 = (char) (k1 ^ k2);
+                    curr->line[j] = k0;
+                  }
+                  if (k < KEYLEN) k++;
+                  else k=1;
+                }
+                pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+                build_screen(current_screen);
+                display_screen(current_screen);
+                break;
+/*
+//           case F_RLE:
+//              if (strlen(curr->line) < curr->length)
+//                rewrite = FALSE;
+//              else
+//              {
+//                j = rle_en(tmpstr,curr->line,curr->length);
+//                tmpstr[j] = '\0';
+//                rewrite = TRUE;
+//              }
+//              break;
+//           case F_RLD:
+//              if (strlen(curr->line) < curr->length)
+//                rewrite = FALSE;
+//              else
+//              {
+//                j = rle_de(tmpstr,curr->line,curr->length);
+//                tmpstr[j] = '\0';
+//                rewrite = TRUE;
+//              }
+//              break;
+*/
+             case F_LZE:
+                if (curr->line[0] == 0x7F
+                || strlen(curr->line) < curr->length
+                || curr->length < 0xf)
+                  rewrite = FALSE;
+                else
+                {
+                  j = comprstr(&tmpstr[1], curr->line, curr->length+1);
+                  tmpstr[0] = 0x7F;
+                  tmpstr[j-1] = '\0';
+                  rewrite = TRUE;
+                }
+                break;
+             case F_LZD:
+                if (curr->line[0] != 0x7F
+                || strlen(curr->line) < curr->length)
+                  rewrite = FALSE;
+                else
+                {
+                  curr->length--;
+                  j = decomprstr(tmpstr, &curr->line[1], curr->length);
+                  tmpstr[j] = '\0';
+                  rewrite = TRUE;
+                }
+                break;
+             default:
+                break;
+          }
+          THEcursor_goto(true_line+(LINETYPE)(i*direction),1);
+          if (rewrite==TRUE)
+            Replace(tmpstr);
+          (*the_free)(tmpstr);
+          if (rc && aalt)
+          {
+             adjust_alt = TRUE;
+             curr->flags.changed_flag = TRUE;
+          }
+          num_actual_lines++;
+          break;
+    }
+    /*
+     * Proceed to the next record, even if the current record not in scope.
+     */
+    if (direction == DIRECTION_FORWARD)
+       curr = curr->next;
+    else
+       curr = curr->prev;
+    num_file_lines += (LINETYPE)direction;
+    if (curr == NULL)
+       break;
+ }
+ /*
+  * Increment the alteration counts if any lines changed...
+  */
+ if (adjust_alt)
+    increment_alt(CURRENT_FILE);
+ /*
+  * Display the new screen...
+  */
+ THEcursor_goto(true_line,1);
+ if (incomm)
+    THEcursor_cmdline(current_screen, CURRENT_VIEW, 1 );
+ pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+ resolve_current_and_focus_lines(current_screen,CURRENT_VIEW,true_line,num_file_lines,direction,TRUE,FALSE);
+ TRACE_RETURN();
+ return(RC_OK);
+}
+
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      cfirst - move column pointer to beginning of zone
@@ -1215,6 +3171,7 @@
    TRACE_RETURN();
    return(rc);
 }
+
 /*man-start*********************************************************************
 COMMAND
      clocate - move the column pointer
@@ -2041,6 +3998,153 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     crypt - encryption
+
+SYNTAX
+     CRYPT [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Crypt(CHARTYPE *params)
+#else
+short Crypt(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   crypt");
+ rc = Format(params,F_CRYPT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     savecrypt
+
+SYNTAX
+     SAVECRYPT
+
+SEE ALSO
+     <LOADCRYPT>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short SCrypt(CHARTYPE *params)
+#else
+short SCrypt(params)
+CHARTYPE *params;
+#endif
+{
+ char fn[MAX_FILE_NAME+1];
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   scrypt");
+ if (strcmp((DEFCHAR *)params,"") != 0)
+ {
+   display_error(2,(CHARTYPE *)params,FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ Format((DEFCHAR *)"all",F_CRYPT,TRUE);
+ strcpy(fn,CURRENT_FILE->fname);
+ strcat(fn,(DEFCHAR *)".cry");
+ rc = Ssave((DEFCHAR *)fn);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     loadcrypt
+
+SYNTAX
+     LOADCRYPT file
+
+SEE ALSO
+     <SAVECRYPT>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short LCrypt(CHARTYPE *params)
+#else
+short LCrypt(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   lcrypt");
+ if (strcmp((DEFCHAR *)params,"") == 0)
+ {
+   display_error(3,(CHARTYPE *)params,FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (access(params, R_OK))
+ {
+   display_error(9,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_FILE_NOT_FOUND);
+ }
+ EditFile(params, FALSE);
+ rc = Format((DEFCHAR *)"all",F_CRYPT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     lzencode
+
+SYNTAX
+     LZEencode target
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short LZE(CHARTYPE *params)
+#else
+short LZE(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   lze");
+ rc = Format((DEFCHAR *)params,F_LZE,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     lzdecode
+
+SYNTAX
+     LZDecode target
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short LZD(CHARTYPE *params)
+#else
+short LZD(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm1.c:   lzd");
+ rc = Format((DEFCHAR *)params,F_LZD,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      cursor - move cursor to specified position
diff -Naurd a/comm2.c b/comm2.c
--- a/comm2.c	2013-07-26 16:09:13.000000000 +0200
+++ b/comm2.c	2013-07-26 16:10:02.000000000 +0200
@@ -737,6 +737,160 @@
    return(rc);
 }
 
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     ebcdic - convert the target from ASCII to EBCDIC
+
+SYNTAX
+     EBCDIC [target]
+
+SEE ALSO
+     <TOASCII>, <TOHEX>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Ebcdic(CHARTYPE *params)
+#else
+short Ebcdic(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+   LINETYPE num_lines=0L,true_line=0L,num_actual_lines=0L,i=0L,num_file_lines=0L;
+   short  direction=0;
+   LINE *curr=NULL;
+   LENGTHTYPE start_col=0,end_col=0;
+   short rc=RC_OK;
+   TARGET target;
+   short target_type=TARGET_NORMAL|TARGET_BLOCK_CURRENT|TARGET_ALL;
+   bool lines_based_on_scope=TRUE;
+   bool adjust_alt=FALSE;
+/*--------------------------- processing ------------------------------*/
+   TRACE_FUNCTION("comm2.c:   Ebcdic");
+   if (strcmp("",(DEFCHAR *)params) == 0)
+      params = (CHARTYPE *)"+1";
+   initialise_target(&target);
+   if ((rc = validate_target(params,&target,target_type,get_true_line(TRUE),TRUE,TRUE)) != RC_OK)
+   {
+      free_target(&target);
+      TRACE_RETURN();
+      return(rc);
+   }
+   post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+   /*
+    * Determine in which direction we are working.
+    */
+   if (target.num_lines < 0L)
+   {
+      direction = DIRECTION_BACKWARD;
+      num_lines = target.num_lines * (-1L);
+   }
+   else
+   {
+      direction = DIRECTION_FORWARD;
+      num_lines = target.num_lines;
+   }
+   true_line = target.true_line;
+   /*
+    * If the target is BLOCK set the left and right margins to be the
+    * margins of the BOX BLOCK, otherwise use ZONE settings.
+    */
+   start_col = CURRENT_VIEW->zone_start-1;
+   end_col = CURRENT_VIEW->zone_end-1;
+   if (target.rt[0].target_type == TARGET_BLOCK_CURRENT)
+   {
+      num_lines = MARK_VIEW->mark_end_line-MARK_VIEW->mark_start_line+1L;
+      true_line = MARK_VIEW->mark_start_line;
+      direction = DIRECTION_FORWARD;
+      lines_based_on_scope = FALSE;
+      if (MARK_VIEW->mark_type != M_LINE)
+      {
+         start_col = MARK_VIEW->mark_start_col-1;
+         end_col   = MARK_VIEW->mark_end_col-1;
+      }
+   }
+   /*
+    * Find the current LINE pointer for the true_line.
+    * This is the first line to change.
+    */
+   curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+   /*
+    * Change the case for the target lines and columns...
+    */
+   for (i=0L,num_actual_lines=0L;;i++)
+   {
+      if (lines_based_on_scope)
+      {
+         if (num_actual_lines == num_lines)
+            break;
+      }
+      else
+      {
+         if (num_lines == i)
+            break;
+      }
+      rc = processable_line(CURRENT_VIEW,true_line+(LINETYPE)(i*direction),curr);
+      switch(rc)
+      {
+         case LINE_SHADOW:
+            break;
+/*       case LINE_TOF_EOF: MH12 */
+         case LINE_TOF:
+         case LINE_EOF:
+            num_actual_lines++;
+            break;
+         default:
+            add_to_recovery_list(curr->line,curr->length);
+            if ( MARK_VIEW
+            &&  ( MARK_VIEW->mark_type == M_STREAM || MARK_VIEW->mark_type == M_CUA ) )
+            {
+               int mystart=0,myend=curr->length-1;
+               if (true_line + i == MARK_VIEW->mark_start_line)
+                  mystart = start_col;
+               if (true_line + i == MARK_VIEW->mark_end_line)
+                  myend = end_col;
+               asc2ebc(curr->line,curr->length,mystart,myend);
+            }
+            else
+               asc2ebc(curr->line,curr->length,start_col,end_col);
+            if (rc)
+            {
+               adjust_alt = TRUE;
+               curr->flags.changed_flag = TRUE;
+            }
+            num_actual_lines++;
+            break;
+      }
+      /*
+       * Proceed to the next record, even if the current record not in scope.
+       */
+      if (direction == DIRECTION_FORWARD)
+         curr = curr->next;
+      else
+         curr = curr->prev;
+      num_file_lines += (LINETYPE)direction;
+      if (curr == NULL)
+         break;
+   }
+   /*
+    * Increment the alteration counts if any lines changed...
+    */
+   if (adjust_alt)
+      increment_alt(CURRENT_FILE);
+   /*
+    * Display the new screen...
+    */
+   pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+   resolve_current_and_focus_lines(current_screen,CURRENT_VIEW,true_line,num_file_lines,direction,TRUE,FALSE);
+   TRACE_RETURN();
+   return(RC_OK);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      edit - edit another file or switch to next file
@@ -1062,6 +1216,82 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     eval - store value to editv variable
+
+SYNTAX
+     EVAL variable expression
+
+DESCRIPTION
+     evaluate and set EVALERR variable 0 or 1 when error
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <CALC>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+extern void evalini();
+#ifdef HAVE_PROTO
+short Eval(CHARTYPE *params)
+#else
+short Eval(params)
+CHARTYPE *params;
+#endif
+{
+  char buf[MAX_COMMAND_LENGTH];
+  CHARTYPE *beg, *idx, *res;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm2.c:   Eval");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  evalini();
+  strcpy((DEFCHAR *)buf, params);
+  beg = strstr(buf, ' ');
+  if (beg != NULL)
+  {
+    beg++;
+    idx = strstr(beg, ';');
+    while (idx != NULL)
+    {
+      idx[0] = '\0';
+      eval((DEFCHAR *)beg, &res);
+      idx++;
+      strcpy((DEFCHAR *)beg, (DEFCHAR *)idx);
+      idx = strstr(beg, ';');
+    }
+    eval((DEFCHAR *)beg, &res);
+    if (res[0] > '@')
+      idx[0] = '\0';
+    else
+      strcpy((DEFCHAR *)beg, res);
+  }
+  else
+  {
+    display_error(3,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (isalpha(res[0]))
+    execute_editv(EDITV_SETL,FALSE,(DEFCHAR *)"evalerr 1");
+  else
+    execute_editv(EDITV_SETL,FALSE,(DEFCHAR *)"evalerr 0");
+  rc = execute_editv(EDITV_SETL,FALSE,(DEFCHAR *)buf);
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      expand - expand tab characters to spaces
@@ -1542,6 +1772,331 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     flow - Wordwrap and justify text in all paragraphs in target area
+
+SYNTAX
+     FLOW [target|-]
+
+DESCRIPTION
+     If no target is specified, format a paragraph.
+     '-' specifies <UNJUST>.
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Flow(CHARTYPE *params)
+#else
+short Flow(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ LINETYPE num_lines=0L,true_line=0L,num_actual_lines=0L,i=0L,num_file_lines=0L;
+ short  direction=0;
+ LINE *curr=NULL;
+ LENGTHTYPE start_col=0,end_col=0;
+ short rc=RC_OK;
+ TARGET target;
+ short target_type=TARGET_NORMAL|TARGET_BLOCK_CURRENT|TARGET_ALL;
+ bool lines_based_on_scope=TRUE;
+/* bool adjust_alt=FALSE;*/
+ bool incomm, nojust;
+ short save_mleft=0;
+ register unsigned int j;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm2.c:   Flow");
+ incomm = (bool)(CURRENT_VIEW->current_window == WINDOW_COMMAND);
+ if (strcmp("",(DEFCHAR *)params) == 0)
+   params = (CHARTYPE *)"blank";
+ if (strcmp("-",(DEFCHAR *)params) == 0)
+ {
+   params = (CHARTYPE *)"blank";
+   nojust = TRUE;
+ }
+ else
+   nojust = FALSE;
+ initialise_target(&target);
+ if ((rc = validate_target(params,&target,target_type,get_true_line(TRUE),TRUE,TRUE)) != RC_OK)
+ {
+    free_target(&target);
+    TRACE_RETURN();
+    return(rc);
+ }
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ /*
+  * Determine in which direction we are working.
+  */
+ if (target.num_lines < 0L)
+ {
+    display_error(0,(CHARTYPE *)"Invalid direction",FALSE);
+    free_target(&target);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+/*    direction = DIRECTION_BACKWARD;*/
+/*    num_lines = target.num_lines * (-1L);*/
+ }
+ else
+ {
+    direction = DIRECTION_FORWARD;
+    num_lines = target.num_lines;
+ }
+ true_line = target.true_line;
+ /*
+  * If the target is BLOCK set the left and right margins to be the
+  * margins of the BOX BLOCK, otherwise use ZONE settings.
+  */
+ start_col = CURRENT_VIEW->zone_start-1;
+ end_col = CURRENT_VIEW->zone_end-1;
+ if (target.rt[0].target_type == TARGET_BLOCK_CURRENT)
+ {
+    num_lines = MARK_VIEW->mark_end_line-MARK_VIEW->mark_start_line+1L;
+    true_line = MARK_VIEW->mark_start_line;
+    direction = DIRECTION_FORWARD;
+    lines_based_on_scope = FALSE;
+ }
+ /*
+  * Find the current LINE pointer for the true_line.
+  * This is the first line to change.
+  */
+ curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+ /*
+  * Process target lines
+  */
+ for (i=0L,num_actual_lines=0L;;i++)
+ {
+    if (lines_based_on_scope)
+    {
+       if (num_actual_lines == num_lines)
+          break;
+    }
+    else
+    {
+       if (num_lines == i)
+          break;
+    }
+    rc = processable_line(CURRENT_VIEW,true_line+(LINETYPE)(i*direction),curr);
+    switch(rc)
+    {
+       case LINE_SHADOW:
+          break;
+/*       case LINE_TOF_EOF: MH12 */
+       case LINE_TOF:
+       case LINE_EOF:
+          num_actual_lines++;
+          break;
+       default:
+          if (curr->length == 0)
+            break;
+          save_mleft = CURRENT_VIEW->margin_left;
+          if ((i==0) || (curr->prev->length==0))
+          {
+            if (CURRENT_VIEW->margin_indent_offset_status)
+              CURRENT_VIEW->margin_left += CURRENT_VIEW->margin_indent;
+            else
+              CURRENT_VIEW->margin_left = CURRENT_VIEW->margin_indent;
+          }
+          THEcursor_goto(true_line+(LINETYPE)(i),1);
+          Format((DEFCHAR *)"",F_LEFT,FALSE);
+          j = curr->length-1;
+          while ((j>=0) && isspace(curr->line[j]))
+          {
+            curr->line[j] = 0;
+            j--;
+          }
+          j = CURRENT_VIEW->margin_right;
+          if (curr->length > j)
+          {
+            while (!isspace(curr->line[j-1])
+                   && (j>CURRENT_VIEW->margin_left))
+            {
+              j--;
+            }
+            CURRENT_VIEW->margin_left = save_mleft;
+            if (j<=CURRENT_VIEW->margin_left)
+            {
+              break;
+            }
+            THEcursor_goto(true_line+(LINETYPE)(i),j);
+            execute_split_join(SPLTJOIN_SPLIT,FALSE,TRUE);
+            num_lines++;
+            THEcursor_goto(true_line+(LINETYPE)(i+1),1);
+            Format((DEFCHAR *)"",F_LEFT,FALSE);
+            if ((curr->next->next->length > 0)
+                && strcmp(curr->next->next->line,BOTTOM_OF_FILE) != 0)
+            {
+              while ((curr->next->next->length>0)
+                     && (curr->next->length<CURRENT_VIEW->margin_right))
+              {
+                Sos_endchar((DEFCHAR *)"");
+                THEcursor_right(CURSOR_ESCREEN,FALSE);
+                execute_split_join(SPLTJOIN_JOIN,FALSE,TRUE);
+                j = curr->next->length;
+                if (j>0) {j--;}
+                while ((j>=0) && isspace(curr->next->line[j]))
+                {
+                  curr->next->line[j] = 0;
+                  j--;
+                }
+                num_lines--;
+              }
+            }
+            THEcursor_goto(true_line+(LINETYPE)(i),1);
+          }
+          if ((i==0) || (curr->prev->length==0))
+          {
+            if (CURRENT_VIEW->margin_indent_offset_status)
+              CURRENT_VIEW->margin_left += CURRENT_VIEW->margin_indent;
+            else
+              CURRENT_VIEW->margin_left = CURRENT_VIEW->margin_indent;
+          }
+          if (curr->next->length > 0)
+          {
+            if ((nojust==FALSE) && (curr->length > 0)
+                && (curr->length < CURRENT_VIEW->margin_right))
+            {
+              Format((DEFCHAR *)"",F_JUST,FALSE);
+            }
+          }
+          else
+          {
+            Format((DEFCHAR *)"",F_LEFT,FALSE);
+          }
+          CURRENT_VIEW->margin_left = save_mleft;
+/*          adjust_alt = TRUE;*/
+/*          curr->flags.changed_flag = TRUE;*/
+          num_actual_lines++;
+          break;
+    }
+    /*
+     * Proceed to the next record, even if the current record not in scope.
+     */
+/*    if (direction == DIRECTION_FORWARD)*/
+       curr = curr->next;
+/*    else*/
+/*       curr = curr->prev;*/
+    num_file_lines += (LINETYPE)direction;
+    if (curr == NULL)
+       break;
+ }
+ /*
+  * Increment the alteration counts if any lines changed...
+  */
+/* if (adjust_alt)*/
+/*    increment_alt(CURRENT_FILE);*/
+ /*
+  * Display the new screen...
+  */
+ THEcursor_goto(true_line+(LINETYPE)(num_lines+1),1);
+ execute_makecurr(current_screen,CURRENT_VIEW,CURRENT_VIEW->focus_line);
+ if (incomm)
+   THEcursor_cmdline(current_screen, CURRENT_VIEW, 1 );
+ pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+ resolve_current_and_focus_lines(current_screen,CURRENT_VIEW,true_line,num_file_lines,direction,TRUE,FALSE);
+ TRACE_RETURN();
+ return(RC_OK);
+}
+/*man-start*********************************************************************
+COMMAND
+     forcesave - save protected (readonly) file
+
+SYNTAX
+     FORCESAVE
+
+DESCRIPTION
+     The FORCESAVE command writes the current file to disk.
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Fsave(CHARTYPE *params)
+#else
+short Fsave(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ short rc=RC_OK;
+#ifdef DOSxxx
+ mode_t attr=0;
+#endif
+ CHARTYPE *write_fname=NULL;
+ short len_params=0;
+ bool writable=FALSE;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm2.c:   Fsave");
+ len_params = strlen((DEFCHAR *)params);
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ if (CURRENT_FILE->save_alt == 0 && strcmp(params,"") == 0)
+ {
+   TRACE_RETURN();
+   return(rc);
+ }
+ if ((write_fname = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+ {
+   display_error(30,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_OUT_OF_MEMORY);
+ }
+ if (len_params == 0)
+ {
+   strcpy((DEFCHAR *)write_fname,(DEFCHAR *)CURRENT_FILE->fpath);
+   strcat((DEFCHAR *)write_fname,(DEFCHAR *)CURRENT_FILE->fname);
+ }
+ else
+ {
+   the_free(write_fname);
+   display_error(1,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+#ifdef DOSxxx
+ attr = _chmod(write_fname, 0, attr);
+ _chmod(write_fname, 1, _A_NORMAL);
+ rc = save_file(CURRENT_FILE,params,TRUE,CURRENT_FILE->number_lines,1L,NULL,FALSE,0,max_line_length,TRUE,FALSE,FALSE);
+ _chmod(write_fname, 1, attr);
+#else
+ writable = (access(write_fname,W_OK)==0);
+ if (!writable)
+   chmod(write_fname, S_IWUSR|S_IRUSR);
+ rc = save_file(CURRENT_FILE,params,TRUE,CURRENT_FILE->number_lines,1L,NULL,FALSE,0,max_line_length,TRUE,FALSE,FALSE);
+ if (!writable)
+   chmod(write_fname, S_IRUSR);
+#endif
+ the_free(write_fname);
+ if (rc != RC_OK)
+ {
+   TRACE_RETURN();
+   return(rc);
+ }
+/*---------------------------------------------------------------------*/
+/* Only set the alteration count to zero if save was successful.       */
+/*---------------------------------------------------------------------*/
+ CURRENT_FILE->autosave_alt = CURRENT_FILE->save_alt = 0;
+/*---------------------------------------------------------------------*/
+/* If autosave is on at the time of SSaving, remove the .aus file...   */
+/*---------------------------------------------------------------------*/
+ if (CURRENT_FILE->autosave > 0)
+    rc = remove_aus_file(CURRENT_FILE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      forward - scroll forward by number of screens or lines
@@ -1690,6 +2245,194 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+#include <glob.h>
+#ifdef HAVE_PROTO
+short SearchFile(CHARTYPE *fname, CHARTYPE *str, bool x)
+#else
+short SearchFile(fname)
+CHARTYPE *fname, *str;
+bool x;
+#endif
+{
+#define MAX_FSTR 120
+ char c_hi[] = "ÁľÉÍÓÖ§ŐŕÚÜŰéë áäéĄí˘óöőŁúüű\x00";
+ char c_lo[] = "AAAEEIIIIOOOOOOOOUUUUUUUUAAAAEEIIOOOOOOOUUUUUU\x00";
+ short k = (int) &c_hi;
+ FILE *InFile;
+ char fstr[MAX_FSTR+2];
+ char c;
+ register short i;
+ short j, l;
+ short rc = -1;
+ j = strlen(str)-2;
+ if (j > MAX_FSTR)
+    j = MAX_FSTR;
+ strncpy(fstr, str, j+1);
+ if (!x)
+ {
+   for (i=1; i<(j+1); i++)
+   {
+     l = (int) strstr(c_hi,fstr[i]);
+     if (l != NULL)
+     {
+       l -= k;
+       fstr[i] = c_lo[l];
+     }
+     else
+       fstr[i] = toupper(fstr[i]);
+   }
+ }
+ if ( (InFile = fopen( fname, "rb")) != NULL )
+ {
+   i = 1;
+   while (!feof(InFile))
+   {
+     c = fgetc(InFile);
+     if (!x)
+     {
+       l = (int) strstr(c_hi,c);
+       if (l != NULL)
+       {
+         l -= k;
+         c = c_lo[l];
+       }
+       c = toupper(c);
+     }
+     if (c == fstr[i])
+     {
+       i++;
+       if (i > j)
+       {
+         rc = RC_OK;
+         break;
+       }
+     }
+     else
+       i = 1;
+   }
+   fclose( InFile );
+ }
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     fsearch - find str in files
+
+SYNTAX
+     FSEARCH [C] /string/ files
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short FSearch(CHARTYPE *params)
+#else
+short FSearch(params)
+CHARTYPE *params;
+#endif
+{
+ #define SEARCH_PARAMS 11
+ unsigned short num_params=0;
+ CHARTYPE *word[SEARCH_PARAMS+1];
+ CHARTYPE *wpars[SEARCH_PARAMS];
+ CHARTYPE strip[SEARCH_PARAMS];
+ CHARTYPE *fn=NULL;
+ CHARTYPE *beg=NULL;
+ CHARTYPE *end=NULL;
+ register short i,k;
+ short len;
+ short j=0;
+ glob_t glob_results;
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   FSearch");
+ beg = strpbrk(params,"/'\"|");
+ if (beg!=NULL)
+ {
+   end = strpbrk(beg+1,"/'\"|");
+   if (end!=NULL)
+   {
+/*     beg[0]=' ';*/
+/*     end[0]=' ';*/
+     beg++;
+     end--;
+     while (beg<end)
+     {
+       if (beg[0]==' ')
+         beg[0] = 0xFF;
+       beg++;
+     }
+   }
+ }
+ for (i=0;i<SEARCH_PARAMS;i++)
+   strip[i]=STRIP_BOTH;
+ num_params = param_split(params,word,SEARCH_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+ if (num_params < 2)
+ {
+   display_error(3,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (num_params >= SEARCH_PARAMS)
+ {
+   display_error(2,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (strlen(word[0]) == 1)
+   j = ((toupper(word[0][0])=='C')?1:0);
+ len = strlen(word[j]);
+ if (len < 3)
+ {
+   display_error(1,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ for (i=0; i<len; i++)
+ {
+   if (word[j][i]==0xFF)
+     word[j][i] = ' ';
+ }
+ word[j][len] = '\0';
+ for (i=0;i<=num_params;i++)
+ {
+   if ((wpars[i] = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+   {
+     display_error(30,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_OUT_OF_MEMORY);
+   }
+   strcpy(wpars[i],word[i]);
+ }
+ for (i=j+1; i<=num_params; i++)
+ {
+   glob(wpars[i], GLOB_NOCHECK, 0, &glob_results);
+   for (k=0; k<glob_results.gl_pathc; k++)
+   {
+     fn = glob_results.gl_pathv[k];
+     rc = SearchFile(fn,(CHARTYPE *)wpars[j],(bool)j);
+     if (rc == RC_OK)
+     {
+       display_error(0,fn,TRUE);
+       rc = EditFile((CHARTYPE *)fn,FALSE);
+       if (rc == RC_OK)
+       {
+         wpars[len+1] = '\0';
+         rc = execute_locate((CHARTYPE *)wpars[j], FALSE, THE_NOT_SEARCH_SEMANTICS, NULL);
+         if (rc != RC_OK)
+           (void)Qquit((CHARTYPE *)"");
+       }
+     }
+   }
+   globfree(&glob_results);
+ }
+ for (i=0;i<=num_params;i++)
+   (*the_free)(wpars[i]);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      fup - locate backwards the line which begins with the supplied string
@@ -1800,6 +2543,14 @@
       filename = tempfilename;
    else
    {
+#if defined(GYMOD) && defined(DOS)
+      WinClip = FALSE;
+      if (equal((CHARTYPE *)"wclip:",word[0],6))
+      {
+        strcpy(word[0],"clip:");
+        WinClip = TRUE;
+      }
+#endif //GYMOD
       if (equal((CHARTYPE *)"clip:",word[0],5))
       {
          clip = TRUE;
@@ -2104,6 +2855,197 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+extern bool HuSortCase;
+/*man-start*********************************************************************
+COMMAND
+     hlowercase - change to lowercase using high (Hun) characters
+
+SYNTAX
+     HLOWercase [target]
+
+DESCRIPTION
+     The HLOWERCASE command same as LOWERCASE,
+     with following conversions:
+
+     8F/143 - A0/160
+     90/144 - 82/130
+     8C/140 - A1/161
+     95/149 - A2/162
+     99/153 - 94/148
+     A7/167 - 93/147
+     97/151 - A3/163
+     9A/154 - 81/129
+     98/152 - 96/150
+     C1/193 - E1/225
+     C9/201 - E9/233
+     CD/205 - ED/237
+     D3/211 - F3/243
+     D6/214 - F6/246
+     D5/213 - F5/245
+     DA/218 - FA/250
+     DC/220 - FC/252
+     DB/219 - FB/251
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <LOWERCASE>, <HUPPERCASE>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short HLowercase(CHARTYPE *params)
+#else
+short HLowercase(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm2.c:  HLowercase");
+ HuSortCase = TRUE;
+ rc = execute_change_case(params,CASE_LOWER);
+ HuSortCase = FALSE;
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     huppercase - change to uppercase using high (Hun) characters
+
+SYNTAX
+     HUPPercase [target]
+
+DESCRIPTION
+     The HUPPERCASE command same as UPPERCASE,
+     with following conversions:
+
+     A0/160 - 8F/143
+     82/130 - 90/144
+     A1/161 - 8C/140
+     A2/162 - 95/149
+     94/148 - 99/153
+     93/147 - A7/167
+     A3/163 - 97/151
+     81/129 - 9A/154
+     96/150 - 98/152
+     E1/225 - C1/193
+     E9/233 - C9/201
+     ED/237 - CD/205
+     F3/243 - D3/211
+     F6/246 - D6/214
+     F5/245 - D5/213
+     FA/250 - DA/218
+     FC/252 - DC/220
+     FB/251 - DB/219
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <UPPERCASE>, <HLOWERCASE>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short HUppercase(CHARTYPE *params)
+#else
+short HUppercase(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm2.c:  HUppercase");
+ HuSortCase = TRUE;
+ rc = execute_change_case(params,CASE_UPPER);
+ HuSortCase = FALSE;
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     hsort - sort selected lines using high (Hun) characters
+
+SYNTAX
+     HSORT [O] target [[sort field 1] [...] [sort field 10]]
+
+DESCRIPTION
+     The HSORT command same as SORT command,
+     with following conversions:
+
+     8F/143 - A ; C1/193 - A
+     90/144 - E ; C9/201 - E
+     8C/140 - I ; EE/238 - I
+     8D/141 - I ; CD/205 - I
+     95/149 - O ; D3/211 - O
+     99/153 - O ; D6/214 - O
+     A7/167 - O ; D5/213 - O
+     97/151 - U ; DA/218 - U
+     9A/154 - U ; DC/220 - U
+     98/152 - U ; DB/219 - U
+     A0/160 - a ; E1/225 - a
+     84/132 - a ; E4/228 - a
+     82/130 - e ; E9/233 - e
+     A1/161 - i ; ED/237 - i
+     A2/162 - o ; F3/243 - o
+     94/148 - o ; F6/246 - o
+     93/147 - o ; F5/245 - o
+     A3/163 - u ; FA/250 - u
+     81/129 - u ; FC/252 - u
+     96/150 - u ; FB/251 - u
+
+     The first optional parameter 'O' sets the sensitive order.
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+SEE ALSO
+     <SORT>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+extern bool HuSortFlag;
+extern bool HuSortCase;
+#ifdef HAVE_PROTO
+short HSort(CHARTYPE *params)
+#else
+short HSort(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ short rc=RC_OK;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm2.c:   HSort");
+ if (params[0]=='o' || params[0]=='O')
+   {
+     HuSortCase = TRUE;
+     params[0] = ' ';
+   }
+ else
+   {
+     HuSortCase = FALSE;
+   }
+ post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+ HuSortFlag = TRUE;
+ rc = execute_sort(params);
+ HuSortFlag = FALSE;
+ pre_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL);
+ build_screen(current_screen);
+ display_screen(current_screen);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      input - insert the command line contents into the file
@@ -2283,3 +3225,33 @@
    TRACE_RETURN();
    return(rc);
 }
+
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     justify - justify text in target area to current MARGINs
+
+SYNTAX
+     JUSTify [target]
+
+SEE ALSO
+     <UNJUST>, <FLOW>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Justify(CHARTYPE *params)
+#else
+short Justify(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm2.c:   justify");
+ rc = Format(params,F_JUST,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
diff -Naurd a/comm3.c b/comm3.c
--- a/comm3.c	2013-07-26 16:09:13.000000000 +0200
+++ b/comm3.c	2013-07-26 16:10:02.000000000 +0200
@@ -64,6 +64,114 @@
      Complete.
 **man-end**********************************************************************/
 
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     lcompress - reduce leading spaces to tabs
+
+SYNTAX
+     LCOMPress [target]
+
+SEE ALSO
+     <LEXPAND>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+bool lefttabconv=FALSE;
+#ifdef HAVE_PROTO
+short Lcompress(CHARTYPE *params)
+#else
+short Lcompress(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Lcompress");
+  lefttabconv=TRUE;
+  rc = execute_expand_compress(params,FALSE,TRUE,TRUE,TRUE);
+  lefttabconv=FALSE;
+  TRACE_RETURN();
+  return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     ledit - edit files from specifyed listfile
+
+SYNTAX
+     LEDIT file
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#include <glob.h>
+#ifdef HAVE_PROTO
+short Ledit(CHARTYPE *params)
+#else
+short Ledit(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  CHARTYPE buf[MAX_FILE_NAME+1];
+  CHARTYPE **fnpar=NULL;
+  FILE *InFile;
+  int key=0;
+  register short i;
+  glob_t glob_results;
+  short rc=RC_OK;
+  TRACE_FUNCTION( "comm3.c:   Ledit" );
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if ( (InFile = fopen(params, "rb")) != NULL )
+  {
+    file_list_msg = FALSE;
+    while (!feof(InFile))
+    {
+      if (fgets(buf,MAX_FILE_NAME,InFile) != NULL)
+      {
+        short fnlen = strlen(buf);
+        if (buf[fnlen-2] < 32)
+            buf[fnlen-2] = 0;
+        if (buf[fnlen-1] < 32)
+            buf[fnlen-1] = 0;
+        glob(buf, GLOB_NOCHECK, 0, &glob_results);
+        for (i = 0; i<glob_results.gl_pathc; i++)
+        {
+          fnpar = (CHARTYPE *)glob_results.gl_pathv[i];
+          if (access((DEFCHAR *)fnpar,F_OK) != (-1))
+          {
+            Wedit((CHARTYPE *)fnpar);
+            display_error(0,(CHARTYPE *)fnpar,FALSE);
+            rc = RC_OK;
+          }
+          else
+          {
+            display_error(9,(CHARTYPE *)fnpar,FALSE);
+            key = my_getch(stdscr);
+          }
+        }
+        globfree(&glob_results);
+      }
+    }
+    fclose( InFile );
+    file_list_msg = TRUE;
+  }
+  else
+  {
+    display_error(9,(CHARTYPE *)params,FALSE);
+    rc = RC_FILE_NOT_FOUND;
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      left - scroll the screen to the left
@@ -152,6 +260,144 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     leftadjust - left-adjust text in target area: 1st non-blank to left margin
+
+SYNTAX
+     LEFTAdjust [target]
+
+SEE ALSO
+     <CENTER>, <RIGHTADJUST>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Leftad(CHARTYPE *params)
+#else
+short Leftad(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm3.c:   leftad");
+ rc = Format(params,F_LEFT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     lexpand - expand leading tab characters to spaces
+
+SYNTAX
+     LEXPand [target]
+
+SEE ALSO
+     <LCOMPRESS>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Lexpand(CHARTYPE *params)
+#else
+short Lexpand(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Lexpand");
+  lefttabconv=TRUE;
+  rc = execute_expand_compress(params,TRUE,TRUE,TRUE,TRUE);
+  lefttabconv=FALSE;
+  TRACE_RETURN();
+  return(rc);
+}
+
+/*man-start*********************************************************************
+COMMAND
+     linesep - split current line delimited by parameter
+
+SYNTAX
+     LINESEP [str]
+
+SEE ALSO
+     <SPLTTOK>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Linesep(CHARTYPE *params)
+#else
+short Linesep(params)
+CHARTYPE *params;
+#endif
+{
+  LINE *curr=NULL;
+  LINETYPE true_line=0L;
+  CHARTYPE *tok, *tmp, *str;
+  CHARTYPE *parpos;
+  char spac[]=" ";
+  short len=0;
+  TRACE_FUNCTION("comm3.c:   Linesep");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    parpos = spac;
+  }
+  else
+  {
+    parpos = params;
+    len = strlen(params);
+    if (len>1 && params[0]==params[len-1])
+    {
+      params[len-1] = 0;
+      parpos++;
+    }
+  }
+  true_line = CURRENT_VIEW->current_line;
+  if (VIEW_TOF(CURRENT_VIEW,true_line) || VIEW_BOF(CURRENT_VIEW,true_line))
+  {
+    display_error(38,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_ENVIRON);
+  }
+  post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+  curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+  len = strlen(curr->line);
+  if ((tmp = (CHARTYPE *)(*the_malloc)(len+1)) == NULL)
+  {
+    display_error(30,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  str = tmp;
+  strcpy(tmp,curr->line);
+  len = strlen(parpos);
+  tok = strstr(tmp,parpos);
+  if (tok)
+  {
+    do
+    {
+      tok = strstr(tmp,parpos);
+      if (tok)
+        tok[0] = '\0';
+      insert_new_line(current_screen,CURRENT_VIEW,(CHARTYPE *)"",0,1,get_true_line(TRUE),TRUE,FALSE,TRUE,CURRENT_VIEW->display_low,TRUE,FALSE);
+      advance_current_or_focus_line(1);
+      Replace((CHARTYPE *)tmp);
+      tmp = tok+len;
+    } while (tok);
+  }
+  advance_current_or_focus_line(1);
+  (*the_free)(str);
+  TRACE_RETURN();
+  return(RC_OK);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      locate - search for a target
@@ -928,6 +1174,1032 @@
    TRACE_RETURN();
    return(RC_OK);
 }
+#ifdef GYMOD
+#ifndef _MD5_H
+#define _MD5_H 1
+#if defined HAVE_LIMITS_H || _LIBC
+# include <limits.h>
+#endif
+/* The following contortions are an attempt to use the C preprocessor
+   to determine an unsigned integral type that is 32 bits wide.  An
+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but
+   doing that would require that the configure script compile and *run*
+   the resulting executable.  Locally running cross-compiled executables
+   is usually not possible.  */
+#ifdef _LIBC
+# include <sys/types.h>
+typedef u_int32_t md5_uint32;
+#else
+# if defined __STDC__ && __STDC__
+#  define UINT_MAX_32_BITS 4294967295U
+# else
+#  define UINT_MAX_32_BITS 0xFFFFFFFF
+# endif
+/* If UINT_MAX isn't defined, assume it's a 32-bit type.
+   This should be valid for all systems GNU cares about because
+   that doesn't include 16-bit systems, and only modern systems
+   (that certainly have <limits.h>) have 64+-bit integral types.  */
+# ifndef UINT_MAX
+#  define UINT_MAX UINT_MAX_32_BITS
+# endif
+# if UINT_MAX == UINT_MAX_32_BITS
+   typedef unsigned int md5_uint32;
+# else
+#  if USHRT_MAX == UINT_MAX_32_BITS
+    typedef unsigned short md5_uint32;
+#  else
+#   if ULONG_MAX == UINT_MAX_32_BITS
+     typedef unsigned long md5_uint32;
+#   else
+     /* The following line is intended to evoke an error.
+        Using #error is not portable enough.  */
+     "Cannot determine unsigned 32-bit data type."
+#   endif
+#  endif
+# endif
+#endif
+#undef __P
+#if defined (__STDC__) && __STDC__
+#define __P(x) x
+#else
+#define __P(x) ()
+#endif
+/* Structure to save state of computation between the single steps.  */
+struct md5_ctx
+{
+  md5_uint32 A;
+  md5_uint32 B;
+  md5_uint32 C;
+  md5_uint32 D;
+  md5_uint32 total[2];
+  md5_uint32 buflen;
+  char buffer[128];
+};
+#endif
+void md5_process_bytes(const void *, size_t, struct md5_ctx *);
+void md5_process_block(const void *, size_t, struct md5_ctx *);
+/* md5.c - Functions to compute MD5 message digest of files or memory blocks
+   according to the definition of MD5 in RFC 1321 from April 1992.
+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <sys/types.h>
+#if STDC_HEADERS || defined _LIBC
+# include <stdlib.h>
+# include <string.h>
+#else
+# ifndef HAVE_MEMCPY
+#  define memcpy(d, s, n) bcopy ((s), (d), (n))
+# endif
+#endif
+/*#include "md5.h"*/
+#ifdef _LIBC
+# include <endian.h>
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n)                                                        \
+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
+#else
+# define SWAP(n) (n)
+#endif
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+void
+md5_init_ctx (ctx)
+     struct md5_ctx *ctx;
+{
+  ctx->A = 0x67452301;
+  ctx->B = 0xefcdab89;
+  ctx->C = 0x98badcfe;
+  ctx->D = 0x10325476;
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+/* Put result from CTX in first 16 bytes following RESBUF.  The result
+   must be in little endian byte order.
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_read_ctx (ctx, resbuf)
+     const struct md5_ctx *ctx;
+     void *resbuf;
+{
+  ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);
+  ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);
+  ((md5_uint32 *) resbuf)[2] = SWAP (ctx->C);
+  ((md5_uint32 *) resbuf)[3] = SWAP (ctx->D);
+  return resbuf;
+}
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_finish_ctx (ctx, resbuf)
+     struct md5_ctx *ctx;
+     void *resbuf;
+{
+  /* Take yet unprocessed bytes into account.  */
+  md5_uint32 bytes = ctx->buflen;
+  size_t pad;
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
+  memcpy (&ctx->buffer[bytes], fillbuf, pad);
+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */
+  *(md5_uint32 *) &ctx->buffer[bytes + pad] = SWAP (ctx->total[0] << 3);
+  *(md5_uint32 *) &ctx->buffer[bytes + pad + 4] = SWAP ((ctx->total[1] << 3) |
+                                                        (ctx->total[0] >> 29));
+  /* Process last bytes.  */
+  md5_process_block (ctx->buffer, bytes + pad + 8, ctx);
+  return md5_read_ctx (ctx, resbuf);
+}
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+int
+md5_stream (stream, resblock)
+     FILE *stream;
+     void *resblock;
+{
+  /* Important: BLOCKSIZE must be a multiple of 64.  */
+#define BLOCKSIZE 4096
+  struct md5_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+         computation function processes the whole buffer so that with the
+         next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+      /* Read block.  Take care for partial reads.  */
+      do
+        {
+          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+          sum += n;
+        }
+      while (sum < BLOCKSIZE && n != 0);
+      if (n == 0 && ferror (stream))
+        return 1;
+      /* If end of file is reached, end the loop.  */
+      if (n == 0)
+        break;
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+                        BLOCKSIZE % 64 == 0
+       */
+      md5_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+  /* Add the last bytes if necessary.  */
+  if (sum > 0)
+    md5_process_bytes (buffer, sum, &ctx);
+  /* Construct result in desired memory.  */
+  md5_finish_ctx (&ctx, resblock);
+  return 0;
+}
+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+void *
+md5_buffer (buffer, len, resblock)
+     const char *buffer;
+     size_t len;
+     void *resblock;
+{
+  struct md5_ctx ctx;
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+  /* Process whole buffer but last len % 64 bytes.  */
+  md5_process_bytes (buffer, len, &ctx);
+  /* Put result in desired memory area.  */
+  return md5_finish_ctx (&ctx, resblock);
+}
+void
+md5_process_bytes (buffer, len, ctx)
+     const void *buffer;
+     size_t len;
+     struct md5_ctx *ctx;
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 128 - left_over > len ? len : 128 - left_over;
+      memcpy (&ctx->buffer[left_over], buffer, add);
+      ctx->buflen += add;
+      if (left_over + add > 64)
+        {
+          md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
+          /* The regions in the following copy operation cannot overlap.  */
+          memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
+                  (left_over + add) & 63);
+          ctx->buflen = (left_over + add) & 63;
+        }
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+  /* Process available complete blocks.  */
+  if (len > 64)
+    {
+      md5_process_block (buffer, len & ~63, ctx);
+      buffer = (const char *) buffer + (len & ~63);
+      len &= 63;
+    }
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      memcpy (ctx->buffer, buffer, len);
+      ctx->buflen = len;
+    }
+}
+/* These are the four functions used in the four steps of the MD5 algorithm
+   and defined in the RFC 1321.  The first function is a little bit optimized
+   (as found in Colin Plumbs public domain implementation).  */
+/* #define FF(b, c, d) ((b & c) | (~b & d)) */
+#define FF(b, c, d) (d ^ (b & (c ^ d)))
+#define FG(b, c, d) FF (d, b, c)
+#define FH(b, c, d) (b ^ c ^ d)
+#define FI(b, c, d) (c ^ (b | ~d))
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 64 == 0.  */
+void
+md5_process_block (buffer, len, ctx)
+     const void *buffer;
+     size_t len;
+     struct md5_ctx *ctx;
+{
+  md5_uint32 correct_words[16];
+  const md5_uint32 *words = buffer;
+  size_t nwords = len / sizeof (md5_uint32);
+  const md5_uint32 *endp = words + nwords;
+  md5_uint32 A = ctx->A;
+  md5_uint32 B = ctx->B;
+  md5_uint32 C = ctx->C;
+  md5_uint32 D = ctx->D;
+  /* First increment the byte count.  RFC 1321 specifies the possible
+     length of the file up to 2^64 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+  /* Process all bytes in the buffer with 64 bytes in each round of
+     the loop.  */
+  while (words < endp)
+    {
+      md5_uint32 *cwp = correct_words;
+      md5_uint32 A_save = A;
+      md5_uint32 B_save = B;
+      md5_uint32 C_save = C;
+      md5_uint32 D_save = D;
+      /* First round: using the given function, the context and a constant
+         the next context is computed.  Because the algorithms processing
+         unit is a 32-bit word and it is determined to work on words in
+         little endian byte order we perhaps have to change the byte order
+         before the computation.  To reduce the work for the next steps
+         we store the swapped words in the array CORRECT_WORDS.  */
+#define OP(a, b, c, d, s, T)                                            \
+      do                                                                \
+        {                                                               \
+          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \
+          ++words;                                                      \
+          CYCLIC (a, s);                                                \
+          a += b;                                                       \
+        }                                                               \
+      while (0)
+      /* It is unfortunate that C does not provide an operator for
+         cyclic rotation.  Hope the C compiler is smart enough.  */
+#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))
+      /* Before we start, one word to the strange constants.
+         They are defined in RFC 1321 as
+         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
+       */
+      /* Round 1.  */
+      OP (A, B, C, D,  7, 0xd76aa478);
+      OP (D, A, B, C, 12, 0xe8c7b756);
+      OP (C, D, A, B, 17, 0x242070db);
+      OP (B, C, D, A, 22, 0xc1bdceee);
+      OP (A, B, C, D,  7, 0xf57c0faf);
+      OP (D, A, B, C, 12, 0x4787c62a);
+      OP (C, D, A, B, 17, 0xa8304613);
+      OP (B, C, D, A, 22, 0xfd469501);
+      OP (A, B, C, D,  7, 0x698098d8);
+      OP (D, A, B, C, 12, 0x8b44f7af);
+      OP (C, D, A, B, 17, 0xffff5bb1);
+      OP (B, C, D, A, 22, 0x895cd7be);
+      OP (A, B, C, D,  7, 0x6b901122);
+      OP (D, A, B, C, 12, 0xfd987193);
+      OP (C, D, A, B, 17, 0xa679438e);
+      OP (B, C, D, A, 22, 0x49b40821);
+      /* For the second to fourth round we have the possibly swapped words
+         in CORRECT_WORDS.  Redefine the macro to take an additional first
+         argument specifying the function to use.  */
+#undef OP
+#define OP(f, a, b, c, d, k, s, T)                                      \
+      do                                                                \
+        {                                                               \
+          a += f (b, c, d) + correct_words[k] + T;                      \
+          CYCLIC (a, s);                                                \
+          a += b;                                                       \
+        }                                                               \
+      while (0)
+      /* Round 2.  */
+      OP (FG, A, B, C, D,  1,  5, 0xf61e2562);
+      OP (FG, D, A, B, C,  6,  9, 0xc040b340);
+      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
+      OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);
+      OP (FG, A, B, C, D,  5,  5, 0xd62f105d);
+      OP (FG, D, A, B, C, 10,  9, 0x02441453);
+      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
+      OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);
+      OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);
+      OP (FG, D, A, B, C, 14,  9, 0xc33707d6);
+      OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);
+      OP (FG, B, C, D, A,  8, 20, 0x455a14ed);
+      OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);
+      OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);
+      OP (FG, C, D, A, B,  7, 14, 0x676f02d9);
+      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);
+      /* Round 3.  */
+      OP (FH, A, B, C, D,  5,  4, 0xfffa3942);
+      OP (FH, D, A, B, C,  8, 11, 0x8771f681);
+      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
+      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
+      OP (FH, A, B, C, D,  1,  4, 0xa4beea44);
+      OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);
+      OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);
+      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
+      OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);
+      OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);
+      OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);
+      OP (FH, B, C, D, A,  6, 23, 0x04881d05);
+      OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);
+      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
+      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
+      OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);
+      /* Round 4.  */
+      OP (FI, A, B, C, D,  0,  6, 0xf4292244);
+      OP (FI, D, A, B, C,  7, 10, 0x432aff97);
+      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
+      OP (FI, B, C, D, A,  5, 21, 0xfc93a039);
+      OP (FI, A, B, C, D, 12,  6, 0x655b59c3);
+      OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);
+      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
+      OP (FI, B, C, D, A,  1, 21, 0x85845dd1);
+      OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);
+      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
+      OP (FI, C, D, A, B,  6, 15, 0xa3014314);
+      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
+      OP (FI, A, B, C, D,  4,  6, 0xf7537e82);
+      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
+      OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);
+      OP (FI, B, C, D, A,  9, 21, 0xeb86d391);
+      /* Add the starting values of the context.  */
+      A += A_save;
+      B += B_save;
+      C += C_save;
+      D += D_save;
+    }
+  /* Put checksum in context given as argument.  */
+  ctx->A = A;
+  ctx->B = B;
+  ctx->C = C;
+  ctx->D = D;
+}
+/* Most systems do not distinguish between external and internal
+   text representations.  */
+/* FIXME: This begs for an autoconf test.  */
+#if O_BINARY
+# define OPENOPTS(BINARY) ((BINARY) != 0 ? TEXT1TO1 : TEXTCNVT)
+# define TEXT1TO1 "rb"
+# define TEXTCNVT "r"
+#else
+# if defined VMS
+#  define OPENOPTS(BINARY) ((BINARY) != 0 ? TEXT1TO1 : TEXTCNVT)
+#  define TEXT1TO1 "rb", "ctx=stm"
+#  define TEXTCNVT "r", "ctx=stm"
+# else
+#  if UNIX || __UNIX__ || unix || __unix__ || _POSIX_VERSION
+#   define OPENOPTS(BINARY) "r"
+#  else
+    /* The following line is intended to evoke an error.
+       Using #error is not portable enough.  */
+    "Cannot determine system type."
+#  endif
+# endif
+#endif
+int md5_file (const char *filename, int binary, unsigned char *md5_result)
+{
+  FILE *fp;
+  int err;
+  /* OPENOPTS is a macro.  It varies with the system.
+     Some systems distinguish between internal and
+     external text representations.  */
+  fp = fopen (filename, OPENOPTS (binary));
+  if (fp == NULL)
+    {
+/*      error (0, errno, "%s", filename);*/
+      return 1;
+    }
+  err = md5_stream (fp, md5_result);
+  if (err)
+    {
+/*      error (0, errno, "%s", filename);*/
+      if (fp != stdin)
+        fclose (fp);
+      return 1;
+    }
+  if (fp != stdin && fclose (fp) == EOF)
+    {
+/*      error (0, errno, "%s", filename);*/
+      return 1;
+    }
+  return 0;
+}
+char md5str[MAX_FILE_NAME+35] = "\0";
+/*man-start*********************************************************************
+COMMAND
+     mdsum - compute MD5 checksum to the definition of MD5 in RFC 1321
+
+SYNTAX
+     MDSUM file [B|T]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short md5sum(CHARTYPE *params)
+#else
+short md5sum(params)
+CHARTYPE *params;
+#endif
+{
+  char fn[MAX_FILE_NAME+1];
+  short i=0, j=0;
+  char c;
+  unsigned char md5buffer[16];
+#if O_BINARY
+  /* Binary is default on MSDOS, so the actual file contents
+     are used in computation.  */
+  int binary = 1;
+#else
+  /* Text is default of the Plumb/Lankester format.  */
+  int binary = 0;
+#endif
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   md5sum");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  i = strlen(params)-2;
+  c = toupper(params[i+1]);
+  if ((c=='T' || c=='B') && params[i]==' ')
+  {
+    if (c=='T')
+      binary = 0;
+    else
+      binary = 1;
+    do
+    {
+      params[i] = '\0';
+      i--;
+    }
+    while (i>0 && params[i]==' ');
+  }
+  if (access(params, R_OK))
+  {
+    display_error(9,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_FILE_NOT_FOUND);
+  }
+  strcpy(fn, params);
+  if (md5_file(fn, binary, md5buffer) == 0)
+  {
+    for (i=0,j=0; i<16; ++i,j=2*i)
+      sprintf(md5str+j, "%02x", md5buffer[i]);
+    if (binary)
+      strcat(md5str, " *");
+    else
+      strcat(md5str, "  ");
+    strcat(md5str, basename(fn));
+  }
+  else
+  {
+    display_error(0,(CHARTYPE *)"Can't create MD5SUM",FALSE);
+    TRACE_RETURN();
+    return(-1);
+  }
+  strcpy(fn, params);
+  strcat(fn, (DEFCHAR *)".md5\0");
+  rc = EditFile(fn, FALSE );
+  (void)Add((DEFCHAR *)"");
+  (void)THEcursor_column();
+  (void)Text(md5str);
+  TRACE_RETURN();
+  return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     merge - combine two sets of lines, overlay 2nd on 1st at colno
+
+SYNTAX
+     MERGE target1 target2 [c]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Merge(CHARTYPE *params)
+#else
+short Merge(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+#define MERGE_PARAMS 3
+  CHARTYPE *word[MERGE_PARAMS+1];
+  CHARTYPE strip[MERGE_PARAMS];
+  unsigned short num_params=0;
+  int i=0,j=0;
+  LINETYPE start_line=0L, dest_line=0L;
+  LINE *curr=NULL;
+  TARGET target1;
+  short target_type1=TARGET_NORMAL;
+  short target_num_lines=0;
+  char numlines[9] = "";
+  char startlin[10]= ":";
+  char destlin[10] = ":";
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Merge");
+  strip[0]=STRIP_BOTH;
+  strip[1]=STRIP_BOTH;
+  strip[2]=STRIP_BOTH;
+  num_params = param_split(params,word,MERGE_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+  if (num_params == 0)
+  {
+     display_error(3,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_INVALID_OPERAND);
+  }
+  if (num_params > 3)
+  {
+     display_error(2,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_INVALID_OPERAND);
+  }
+  if (num_params > 1)
+  {
+    start_line = CURRENT_VIEW->current_line;
+    if (start_line == 0 || start_line > CURRENT_FILE->number_lines)
+    {
+      display_error(0,(CHARTYPE *)"Invalid current line",FALSE);
+      TRACE_RETURN();
+      return(RC_INVALID_OPERAND);
+    }
+    itoa_dj(start_line, startlin+1, 10);
+    if (num_params==3)
+    {
+      CURRENT_VIEW->current_column = atoi(word[2]);
+      if (CURRENT_VIEW->current_window != WINDOW_COMMAND)
+        THEcursor_column();
+    }
+    initialise_target(&target1);
+    if ((rc=validate_target(word[0],&target1,target_type1,get_true_line(TRUE),TRUE,TRUE))==RC_OK)
+    {
+      target_num_lines = abs(target1.num_lines);
+      start_line = target1.true_line;
+      itoa_dj(target_num_lines-1, numlines, 10);
+    }
+    rc = execute_locate((CHARTYPE *)word[1], TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+    if (rc != RC_OK)
+    {
+      target_num_lines = 0;
+    }
+    free_target(&target1);
+    if (target_num_lines > 0)
+    {
+      dest_line = CURRENT_VIEW->current_line;
+      itoa_dj(dest_line, destlin+1, 10);
+      curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,start_line,CURRENT_FILE->number_lines);
+      for (i=0; i<target_num_lines; i++)
+      {
+        rc = processable_line(CURRENT_VIEW,start_line+i,curr);
+        switch(rc)
+        {
+           case LINE_SHADOW:
+              break;
+           case LINE_TOF:
+           case LINE_EOF:
+              break;
+           default:
+              break;
+        }
+        rc = execute_locate((CHARTYPE *)destlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+        if (rc == RC_OK)
+        {
+          for (j=0; j<i; j++)
+          {
+            THENext((CHARTYPE *)"");
+          }
+          if (num_params==3)
+          {
+            CURRENT_VIEW->current_column = atoi(word[2]);
+          }
+          rc = column_command((CHARTYPE *)curr->line ,COLUMN_COVERLAY);
+        }
+        curr = curr->next;
+      } //for
+      (void)execute_locate((CHARTYPE *)startlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+      (void)DeleteLine((CHARTYPE *)word[0]);
+      (void)execute_locate((CHARTYPE *)word[1], TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+      if (start_line > CURRENT_VIEW->current_line)
+      {
+        THENext((CHARTYPE *)numlines);
+      }
+    }
+    else
+    {
+      display_error(17,(CHARTYPE *)"",FALSE);
+      TRACE_RETURN();
+      return(RC_TARGET_NOT_FOUND);
+    }
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     mimeb - base64 encode/decode
+
+SYNTAX
+     MIMEB e|d
+
+SEE ALSO
+     <MIMEQ>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#define MIM_DEF_LINE_SIZE 72
+#define MIM_TMP ("MIME.tmp")
+// Translation Table as described in RFC1113
+static const char cb64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+// Translation Table to decode
+static const char cd64[]="|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";
+// encode 3 8-bit binary bytes as 4 '6-bit' characters
+void encodeblock(unsigned char in[3], unsigned char out[4], int len)
+{
+  out[0] = cb64[ in[0] >> 2 ];
+  out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
+  out[2] = (unsigned char) (len > 1 ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=');
+  out[3] = (unsigned char) (len > 2 ? cb64[ in[2] & 0x3f ] : '=');
+}
+// base64 encode a stream adding padding and line breaks as per spec.
+void encode64(FILE *infile, FILE *outfile, int linesize)
+{
+  unsigned char in[3], out[4];
+  int i, len, blocksout = 0;
+  while( !feof( infile ) ) {
+      len = 0;
+      for( i = 0; i < 3; i++ ) {
+          in[i] = (unsigned char) getc( infile );
+          if( !feof( infile ) ) {
+              len++;
+          }
+          else {
+              in[i] = 0;
+          }
+      }
+      if( len ) {
+          encodeblock( in, out, len );
+          for( i = 0; i < 4; i++ ) {
+              putc( out[i], outfile );
+          }
+          blocksout++;
+      }
+      if( blocksout >= (linesize/4) || feof( infile ) ) {
+          if( blocksout ) {
+              fprintf( outfile, "\r\n" );
+          }
+          blocksout = 0;
+      }
+  }
+}
+// decode 4 '6-bit' characters into 3 8-bit binary bytes
+void decodeblock(unsigned char in[4], unsigned char out[3])
+{   
+  out[ 0 ] = (unsigned char ) (in[0] << 2 | in[1] >> 4);
+  out[ 1 ] = (unsigned char ) (in[1] << 4 | in[2] >> 2);
+  out[ 2 ] = (unsigned char ) (((in[2] << 6) & 0xc0) | in[3]);
+}
+// decode a base64 encoded stream discarding padding, line breaks and noise
+void decode64(FILE *infile, FILE *outfile)
+{
+  unsigned char in[4], out[3], v;
+  int i, len;
+
+  while( !feof( infile ) ) {
+      for( len = 0, i = 0; i < 4 && !feof( infile ); i++ ) {
+          v = 0;
+          while( !feof( infile ) && v == 0 ) {
+              v = (unsigned char) getc( infile );
+              v = (unsigned char) ((v < 43 || v > 122) ? 0 : cd64[ v - 43 ]);
+              if( v ) {
+                  v = (unsigned char) ((v == '$') ? 0 : v - 61);
+              }
+          }
+          if( !feof( infile ) ) {
+              len++;
+              if( v ) {
+                  in[ i ] = (unsigned char) (v - 1);
+              }
+          }
+          else {
+              in[i] = 0;
+          }
+      }
+      if( len ) {
+          decodeblock( in, out );
+          for( i = 0; i < len - 1; i++ ) {
+              putc( out[i], outfile );
+          }
+      }
+  }
+}
+// 'engine' that opens streams and calls encode/decode
+int b64(int opt, char *infilename, char *outfilename, int linesize)
+{
+  FILE *infile;
+  int retcode = 1;
+  if (!infilename)
+    infile = stdin;
+  else
+    infile = fopen(infilename, "rb");
+  if (infile)
+  {
+      FILE *outfile;
+      if(!outfilename) {
+          outfile = stdout;
+      }
+      else {
+          outfile = fopen(outfilename, "wb");
+      }
+      if (outfile)
+      {
+          if( opt == 'e' ) {
+              encode64( infile, outfile, linesize );
+          }
+          else {
+              decode64( infile, outfile );
+          }
+          if (ferror( infile ) || ferror( outfile )) {
+              retcode = 1;
+          }
+          else {
+               retcode = 0;
+          }
+          if( outfile != stdout ) {
+              if( fclose( outfile ) != 0 ) {
+                  retcode = 1;
+              }
+          }
+      }
+      if( infile != stdin ) {
+          fclose( infile );
+      }
+  }
+  return( retcode );
+}
+#ifdef HAVE_PROTO
+short Mimeb(CHARTYPE *params)
+#else
+short Mimeb(params)
+CHARTYPE *params;
+#endif
+{
+  CHARTYPE *actfname = CURRENT_FILE->fname;
+  char buf[MAX_FILE_NAME+1];
+  char mimfile[]=MIM_TMP;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Mimeb");
+  if (strcmp((DEFCHAR *)params,"e") != 0
+    && strcmp((DEFCHAR *)params,"d") != 0)
+  {
+    display_error(1,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (display_length == 0 && Ssave(actfname) != RC_OK)
+  {
+    display_error(0,(CHARTYPE *)"Can't process Base64.",FALSE);
+    TRACE_RETURN();
+    return(RC_IO_ERROR);
+  }
+  strcpy(buf, actfname);
+  rc = b64(params[0], actfname, mimfile, MIM_DEF_LINE_SIZE);
+  if (rc==0)
+  {
+    Qquit((DEFCHAR *)"");
+    rc = Xedit((CHARTYPE *)mimfile);
+    Filename((CHARTYPE *)buf);
+    remove(MIM_TMP);
+    increment_alt(CURRENT_FILE);
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     mimeq - quoted printable encode/decode
+
+SYNTAX
+     MIMEQ e|d
+
+SEE ALSO
+     <MIMEB>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+void encodeqp(FILE *infile, FILE *outfile, int linesize)
+{
+  unsigned char in;
+  int len = 1;
+  while (!feof(infile))
+  {
+    in = (unsigned char) getc(infile);
+    if (!feof(infile))
+      {
+      if (len >= linesize)
+      {
+        fprintf(outfile, "=\r\n");
+        len = 1;
+      }
+      if (((in>0x1F && in<0x80) && in!=0x3d)
+          || (in==0x0a || in==0x0d))
+      {
+        putc(in, outfile);
+        len++;
+        if (in==0x0a || in==0x0d)
+          len = 1;
+      }
+      else
+      {
+        if (len >= (linesize-3))
+        {
+          fprintf(outfile, "=\r\n");
+          len = 1;
+        }
+        fprintf(outfile, "=%02X", in);
+        len += 3;
+      }
+    }
+  }
+}
+unsigned char h2b(char c)
+{
+  unsigned char ret;
+  ret = c-'0';
+  if (c>'9')
+    ret -= 7;
+  return ret;
+}
+void decodeqp(FILE *infile, FILE *outfile)
+{
+  unsigned char in, out;
+  while (!feof(infile))
+  {
+    in = (unsigned char) getc(infile);
+    if (!feof(infile))
+    {
+      if (in==0x3d)
+      {
+        in = getc(infile);
+        if (!feof(infile))
+        {
+          if (in==0x0d)
+          {
+            in = getc(infile);
+            if (in!=0x0a)
+              in = ungetc(in, infile);
+          }
+          else
+          {
+            out = 16*h2b(in);
+            in = getc(infile);
+            out += h2b(in);
+            putc(out, outfile);
+          }
+        }
+      }
+      else
+      {
+        putc(in, outfile);
+      }
+    }
+  }
+}
+int qp(int opt, char *infilename, char *outfilename, int linesize)
+{
+  FILE *infile;
+  int retcode = 1;
+  if (!infilename)
+    infile = stdin;
+  else
+    infile = fopen(infilename, "rb");
+  if (infile)
+  {
+      FILE *outfile;
+      if (!outfilename) {
+          outfile = stdout;
+      }
+      else {
+          outfile = fopen(outfilename, "wb");
+      }
+      if (outfile)
+      {
+          if( opt == 'e' ) {
+              encodeqp( infile, outfile, linesize );
+          }
+          else {
+              decodeqp( infile, outfile );
+          }
+          if (ferror( infile ) || ferror( outfile )) {
+              retcode = 1;
+          }
+          else {
+               retcode = 0;
+          }
+          if( outfile != stdout ) {
+              if( fclose( outfile ) != 0 ) {
+                  retcode = 1;
+              }
+          }
+      }
+      if( infile != stdin ) {
+          fclose( infile );
+      }
+  }
+  return( retcode );
+}
+#ifdef HAVE_PROTO
+short Mimeq(CHARTYPE *params)
+#else
+short Mimeq(params)
+CHARTYPE *params;
+#endif
+{
+  CHARTYPE *actfname = CURRENT_FILE->fname;
+  char buf[MAX_FILE_NAME+1];
+  char mimfile[]=MIM_TMP;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm3.c:   Mimeq");
+  if (strcmp((DEFCHAR *)params,"e") != 0
+    && strcmp((DEFCHAR *)params,"d") != 0)
+  {
+    display_error(1,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (display_length == 0 && Ssave(actfname) != RC_OK)
+  {
+    display_error(0,(CHARTYPE *)"Can't process Quoted.",FALSE);
+    TRACE_RETURN();
+    return(RC_IO_ERROR);
+  }
+  strcpy(buf, actfname);
+  rc = qp(params[0], actfname, mimfile, MIM_DEF_LINE_SIZE);
+  if (rc==0)
+  {
+    Qquit((DEFCHAR *)"");
+    rc = Xedit((CHARTYPE *)mimfile);
+    Filename((CHARTYPE *)buf);
+    remove(MIM_TMP);
+    increment_alt(CURRENT_FILE);
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      modify - display current SET command for alteration
@@ -1016,6 +2288,14 @@
    LINETYPE start_line=0L,end_line=0L,num_lines=0L,dest_line=0L,lines_affected=0L;
    VIEW_DETAILS *old_mark_view=NULL;
 
+#ifdef GYMOD
+   TARGET target1;
+   short target_type1=TARGET_NORMAL;
+   LINETYPE target_abs_lines=0L;
+   char numlines[9] = "";
+   char startlin[10]= ":";
+   TRACE_FUNCTION("comm3.c:   THEMove");
+#else //GYMOD
    TRACE_FUNCTION("comm3.c:   THEMove");
    /*
     * This command invalid if source file is readonly...
@@ -1026,6 +2306,7 @@
       TRACE_RETURN();
       return(RC_INVALID_ENVIRON);
    }
+#endif //GYMOD
    if (ISREADONLY(MARK_FILE))
    {
       display_error(56,(CHARTYPE *)"",FALSE);
@@ -1047,6 +2328,50 @@
       TRACE_RETURN();
       return(RC_INVALID_OPERAND);
    }
+#ifdef GYMOD
+   if (num_params == 2
+   && equal((CHARTYPE *)"block",word[0],5) == FALSE)
+   {
+     start_line = CURRENT_VIEW->current_line;
+     if (start_line == 0 || start_line > CURRENT_FILE->number_lines)
+     {
+       display_error(0,(CHARTYPE *)"Invalid current line",FALSE);
+       TRACE_RETURN();
+       return(RC_INVALID_OPERAND);
+     }
+     itoa_dj(start_line, startlin+1, 10);
+     initialise_target(&target1);
+     if ((rc=validate_target(word[0],&target1,target_type1,get_true_line(TRUE),TRUE,TRUE))==RC_OK)
+     {
+       target_abs_lines = abs(target1.num_lines);
+       itoa_dj(target_abs_lines, numlines, 10);
+     }
+     free_target(&target1);
+     rc = Copy((CHARTYPE *)params);
+     if (rc == RC_OK)
+     {
+       (void)Locate((CHARTYPE *)word[1]);
+       if (start_line > CURRENT_VIEW->current_line)
+       {
+         (void)execute_locate((CHARTYPE *)startlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+         (void)THENext((CHARTYPE *)"");
+       }
+       else
+         (void)execute_locate((CHARTYPE *)startlin, TRUE, THE_NOT_SEARCH_SEMANTICS, NULL );
+       rc = DeleteLine((CHARTYPE *)word[0]);
+       if (rc == RC_OK)
+       {
+         (void)Locate((CHARTYPE *)word[1]);
+         (void)THENext((CHARTYPE *)numlines);
+       }
+       TRACE_RETURN();
+       return(rc);
+     }
+     display_error(17,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_TARGET_NOT_FOUND);
+   }
+#endif //GYMOD
    /*
     * Test for valid parameters...
     */
@@ -1548,6 +2873,32 @@
    TRACE_RETURN();
    return(RC_OK);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     onespace - makes all whitespace single spaces (as KEDIT RBLANK macro)
+
+SYNTAX
+     ONEspace [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Onespc(CHARTYPE *params)
+#else
+short Onespc(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm3.c:   onesp");
+ rc = Format(params,F_1SPC,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      os - execute an operating system command
diff -Naurd a/comm4.c b/comm4.c
--- a/comm4.c	2013-07-26 16:09:13.000000000 +0200
+++ b/comm4.c	2013-07-26 16:10:02.000000000 +0200
@@ -128,9 +128,31 @@
 /***********************************************************************/
 {
    short rc=RC_OK;
+#ifdef GYMOD
+   bool samescr=FALSE;
+   bool vertical;
+#endif //GYMOD
 
    TRACE_FUNCTION("comm4.c:   Popup");
+#ifdef GYMOD
+   if (display_screens > 1
+   &&  SCREEN_FILE(0) == SCREEN_FILE(1))
+   {
+     samescr=TRUE;
+     vertical = !horizontal;
+     THEScreen((CHARTYPE *)"1");
+   }
+#endif //GYMOD
    rc = prepare_popup( params );
+#ifdef GYMOD
+   if (samescr)
+   {
+     if (vertical)
+       THEScreen((CHARTYPE *)"2 v");
+     else
+       THEScreen((CHARTYPE *)"2");
+   }
+#endif //GYMOD
    TRACE_RETURN();
    return(rc);
 }
@@ -1766,6 +1788,54 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     ringcmd - execute a command on all files in the ring
+
+SYNTAX
+     RINGCMD command [# command [...]]
+
+SEE ALSO
+     <ENTER>, <COMMAND>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Ringcmd(CHARTYPE *params)
+#else
+short Ringcmd(params)
+CHARTYPE *params;
+#endif
+{
+ bool le_status;
+ VIEW_DETAILS *save_curr;
+ short i, j=number_of_files;
+ TRACE_FUNCTION("comm4.c:   Ringcmd");
+ if (strcmp((DEFCHAR *)params,"") == 0)
+ {
+   display_error(3,(CHARTYPE *)params,FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ for (i=0; i<j; i++)
+ {
+   save_curr = CURRENT_VIEW;
+   le_status=CURRENT_VIEW->linend_status;
+   command_line((CHARTYPE *)"linend on",TRUE);
+   command_line((CHARTYPE *)params,TRUE);
+   if (save_curr == CURRENT_VIEW)
+   {
+     CURRENT_VIEW->linend_status = le_status;
+     Nextwindow((CHARTYPE *)"");
+   }
+ }
+ TRACE_RETURN();
+ return(RC_OK);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      rgtleft - scroll the screen to the left or right
@@ -1923,6 +1993,35 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     rightadjust - right-justify text in target area to right MARGIN column
+
+SYNTAX
+     RIGHTAdjust [target]
+
+SEE ALSO
+     <CENTER>, <LEFTADJUST>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Rightad(CHARTYPE *params)
+#else
+short Rightad(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm4.c:   rightad");
+ rc = Format(params,F_RIGHT,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      save - save changes to current file
@@ -1981,6 +2080,189 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     sayf -  store formatted text to editv variable
+
+SYNTAX
+     SAYF variable formstr [params...]
+
+DESCRIPTION %
+     '+'  force a '+' sign on positive numbers
+
+     '0'  to pad numbers with leading zeros
+
+     'c'  single character
+
+     'd' 'D' 'i'  signed integer
+
+     'e' 'E' 'f' 'g' 'G'  floating point number
+
+     's'  string
+
+     'u' 'U'  unsigned integer
+
+     'x' 'X'  unsigned integer, in base 16
+
+COMPATIBILITY
+     XEDIT: N/A
+     KEDIT: N/A
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Sayf(CHARTYPE *params)
+#else
+short Sayf(params)
+CHARTYPE *params;
+#endif
+{
+#define SAYF_PARAMS 9
+#define PAR_LEN 256
+  CHARTYPE *word[SAYF_PARAMS+1];
+  CHARTYPE p[SAYF_PARAMS+1][PAR_LEN];
+  CHARTYPE strip[SAYF_PARAMS];
+  CHARTYPE buff[3000];
+  CHARTYPE *beg=NULL;
+  CHARTYPE *end=NULL;
+  LINE *curr=NULL;
+  unsigned short num_params=0;
+  long numl;
+  float numf;
+  short i=0, j=0, k=0;
+  bool ok=TRUE;
+  TRACE_FUNCTION("comm4.c:   Sayf");
+  beg = strpbrk(params,"/'\"|");
+  if (beg!=NULL)
+  {
+    end = strpbrk(beg+1,"/'\"|");
+    if (end!=NULL)
+    {
+      beg[0]=' ';
+      end[0]=' ';
+      beg++;
+      end--;
+      while (beg<end)
+      {
+        if (beg[0]==' ')
+          beg[0] = 0xFF;
+        beg++;
+      }
+    }
+  }
+  for (i=0;i<SAYF_PARAMS;i++)
+    strip[i]=STRIP_BOTH;
+  num_params = param_split(params,word,SAYF_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+  if (num_params < 2)
+  {
+    display_error(3,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  ok = (isalpha(word[0][0]) != 0);
+  for (i=1; i<strlen(word[0]); i++)
+  {
+    if (isalnum(word[0][i]) == 0)
+      ok = FALSE;
+  }
+  if (!ok)
+  {
+    display_error(1,(CHARTYPE *)word[0],FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  for (i=0;i<num_params;i++)
+  {
+    strcpy(p[i],word[i]);
+  }
+  word[0] = make_upper(word[0]);
+  for (i=0; i<strlen(word[1]); i++)
+  {
+    if (word[1][i]==0xFF)
+      word[1][i] = ' ';
+  }
+  j = 1;
+  for (i=0; i<strlen(word[1]); i++)
+  {
+    if (word[1][i]=='%')
+    {
+      strcpy(buff,&word[1][i]);
+      if (buff[1]=='+' || buff[1]=='0')
+      {
+        k = strcspn(buff,"cdefgisuxDEGUX");
+        buff[k+1] = 0;
+        i += k;
+      }
+      else
+      {
+        buff[2] = 0;
+        i++;
+      }
+      j++;
+      if (j>SAYF_PARAMS)
+      {
+        break;
+      }
+      if (word[1][i] == '%')
+        j--;
+      else
+      {
+        p[1][i] = 's';
+        word[j] = make_upper(word[j]);
+        curr = lll_locate(editv,word[j]);
+        if (curr!=NULL)
+          word[j] = curr->line;
+        else
+        {
+          execute_editv(EDITV_PUT,FALSE,word[j]);
+          curr = lll_locate(editv,word[j]);
+          if (curr!=NULL)
+            word[j] = curr->line;
+        }
+        strcpy(p[j],word[j]);
+      }
+      switch (word[1][i])
+      {
+        case 'c':
+          p[j][1] = 0;
+          break;
+        case 'd':
+        case 'D':
+        case 'i':
+        case 'u':
+        case 'U':
+        case 'x':
+        case 'X':
+          sscanf((CHARTYPE *)p[j],"%D",&numl);
+          sprintf(p[j],buff,numl);
+          break;
+        case 'e':
+        case 'E':
+        case 'f':
+        case 'g':
+        case 'G':
+          sscanf((CHARTYPE *)p[j],"%f",&numf);
+          sprintf(p[j],buff,numf);
+          break;
+      }
+    }
+  }
+  strcpy(buff,word[0]);
+  i = strlen(buff);
+  buff[i] = ' ';
+  i++;
+  sprintf(buff+i,p[1],p[2],p[3],p[4],p[5],p[6],p[7],p[8],p[9]);
+  for (; buff[i]!=0; i++)
+    if (buff[i] == 0xFF)
+      buff[i] = ' ';
+  execute_editv(EDITV_SETL,FALSE,buff);
+  TRACE_RETURN();
+  return(RC_OK);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      schange - selectively change strings
@@ -2138,6 +2420,369 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/* SHA-1 Message-Digest Algorithm
+ * Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+ * Copyright (C) 2004 g10 Code GmbH
+*/
+#undef BIG_ENDIAN_HOST
+typedef unsigned int u32;
+
+/****************
+ * Rotate a 32 bit integer by n bytes
+ */
+#if defined(__GNUC__) && defined(__i386__)
+static inline u32
+rol( u32 x, int n)
+{
+	__asm__("roll %%cl,%0"
+		:"=r" (x)
+		:"0" (x),"c" (n));
+	return x;
+}
+#else
+#define rol(x,n) ( ((x) << (n)) | ((x) >> (32-(n))) )
+#endif
+
+typedef struct {
+    u32  h0,h1,h2,h3,h4;
+    u32  nblocks;
+    unsigned char buf[64];
+    int  count;
+} SHA1_CONTEXT;
+
+void
+sha1_init( SHA1_CONTEXT *hd )
+{
+    hd->h0 = 0x67452301;
+    hd->h1 = 0xefcdab89;
+    hd->h2 = 0x98badcfe;
+    hd->h3 = 0x10325476;
+    hd->h4 = 0xc3d2e1f0;
+    hd->nblocks = 0;
+    hd->count = 0;
+}
+
+/****************
+ * Transform the message X which consists of 16 32-bit-words
+ */
+static void
+transform( SHA1_CONTEXT *hd, unsigned char *data )
+{
+    u32 a,b,c,d,e,tm;
+    u32 x[16];
+
+    /* get values from the chaining vars */
+    a = hd->h0;
+    b = hd->h1;
+    c = hd->h2;
+    d = hd->h3;
+    e = hd->h4;
+
+#ifdef BIG_ENDIAN_HOST
+    memcpy( x, data, 64 );
+#else
+    { int i;
+      unsigned char *p2;
+      for(i=0, p2=(unsigned char*)x; i < 16; i++, p2 += 4 ) {
+	p2[3] = *data++;
+	p2[2] = *data++;
+	p2[1] = *data++;
+	p2[0] = *data++;
+      }
+    }
+#endif
+
+#define K1  0x5A827999L
+#define K2  0x6ED9EBA1L
+#define K3  0x8F1BBCDCL
+#define K4  0xCA62C1D6L
+#define F1(x,y,z)   ( z ^ ( x & ( y ^ z ) ) )
+#define F2(x,y,z)   ( x ^ y ^ z )
+#define F3(x,y,z)   ( ( x & y ) | ( z & ( x | y ) ) )
+#define F4(x,y,z)   ( x ^ y ^ z )
+
+#define M(i) ( tm =   x[i&0x0f] ^ x[(i-14)&0x0f] \
+		    ^ x[(i-8)&0x0f] ^ x[(i-3)&0x0f] \
+	       , (x[i&0x0f] = rol(tm,1)) )
+
+#define R(a,b,c,d,e,f,k,m)  do { e += rol( a, 5 )     \
+				      + f( b, c, d )  \
+				      + k	      \
+				      + m;	      \
+				 b = rol( b, 30 );    \
+			       } while(0)
+    R( a, b, c, d, e, F1, K1, x[ 0] );
+    R( e, a, b, c, d, F1, K1, x[ 1] );
+    R( d, e, a, b, c, F1, K1, x[ 2] );
+    R( c, d, e, a, b, F1, K1, x[ 3] );
+    R( b, c, d, e, a, F1, K1, x[ 4] );
+    R( a, b, c, d, e, F1, K1, x[ 5] );
+    R( e, a, b, c, d, F1, K1, x[ 6] );
+    R( d, e, a, b, c, F1, K1, x[ 7] );
+    R( c, d, e, a, b, F1, K1, x[ 8] );
+    R( b, c, d, e, a, F1, K1, x[ 9] );
+    R( a, b, c, d, e, F1, K1, x[10] );
+    R( e, a, b, c, d, F1, K1, x[11] );
+    R( d, e, a, b, c, F1, K1, x[12] );
+    R( c, d, e, a, b, F1, K1, x[13] );
+    R( b, c, d, e, a, F1, K1, x[14] );
+    R( a, b, c, d, e, F1, K1, x[15] );
+    R( e, a, b, c, d, F1, K1, M(16) );
+    R( d, e, a, b, c, F1, K1, M(17) );
+    R( c, d, e, a, b, F1, K1, M(18) );
+    R( b, c, d, e, a, F1, K1, M(19) );
+    R( a, b, c, d, e, F2, K2, M(20) );
+    R( e, a, b, c, d, F2, K2, M(21) );
+    R( d, e, a, b, c, F2, K2, M(22) );
+    R( c, d, e, a, b, F2, K2, M(23) );
+    R( b, c, d, e, a, F2, K2, M(24) );
+    R( a, b, c, d, e, F2, K2, M(25) );
+    R( e, a, b, c, d, F2, K2, M(26) );
+    R( d, e, a, b, c, F2, K2, M(27) );
+    R( c, d, e, a, b, F2, K2, M(28) );
+    R( b, c, d, e, a, F2, K2, M(29) );
+    R( a, b, c, d, e, F2, K2, M(30) );
+    R( e, a, b, c, d, F2, K2, M(31) );
+    R( d, e, a, b, c, F2, K2, M(32) );
+    R( c, d, e, a, b, F2, K2, M(33) );
+    R( b, c, d, e, a, F2, K2, M(34) );
+    R( a, b, c, d, e, F2, K2, M(35) );
+    R( e, a, b, c, d, F2, K2, M(36) );
+    R( d, e, a, b, c, F2, K2, M(37) );
+    R( c, d, e, a, b, F2, K2, M(38) );
+    R( b, c, d, e, a, F2, K2, M(39) );
+    R( a, b, c, d, e, F3, K3, M(40) );
+    R( e, a, b, c, d, F3, K3, M(41) );
+    R( d, e, a, b, c, F3, K3, M(42) );
+    R( c, d, e, a, b, F3, K3, M(43) );
+    R( b, c, d, e, a, F3, K3, M(44) );
+    R( a, b, c, d, e, F3, K3, M(45) );
+    R( e, a, b, c, d, F3, K3, M(46) );
+    R( d, e, a, b, c, F3, K3, M(47) );
+    R( c, d, e, a, b, F3, K3, M(48) );
+    R( b, c, d, e, a, F3, K3, M(49) );
+    R( a, b, c, d, e, F3, K3, M(50) );
+    R( e, a, b, c, d, F3, K3, M(51) );
+    R( d, e, a, b, c, F3, K3, M(52) );
+    R( c, d, e, a, b, F3, K3, M(53) );
+    R( b, c, d, e, a, F3, K3, M(54) );
+    R( a, b, c, d, e, F3, K3, M(55) );
+    R( e, a, b, c, d, F3, K3, M(56) );
+    R( d, e, a, b, c, F3, K3, M(57) );
+    R( c, d, e, a, b, F3, K3, M(58) );
+    R( b, c, d, e, a, F3, K3, M(59) );
+    R( a, b, c, d, e, F4, K4, M(60) );
+    R( e, a, b, c, d, F4, K4, M(61) );
+    R( d, e, a, b, c, F4, K4, M(62) );
+    R( c, d, e, a, b, F4, K4, M(63) );
+    R( b, c, d, e, a, F4, K4, M(64) );
+    R( a, b, c, d, e, F4, K4, M(65) );
+    R( e, a, b, c, d, F4, K4, M(66) );
+    R( d, e, a, b, c, F4, K4, M(67) );
+    R( c, d, e, a, b, F4, K4, M(68) );
+    R( b, c, d, e, a, F4, K4, M(69) );
+    R( a, b, c, d, e, F4, K4, M(70) );
+    R( e, a, b, c, d, F4, K4, M(71) );
+    R( d, e, a, b, c, F4, K4, M(72) );
+    R( c, d, e, a, b, F4, K4, M(73) );
+    R( b, c, d, e, a, F4, K4, M(74) );
+    R( a, b, c, d, e, F4, K4, M(75) );
+    R( e, a, b, c, d, F4, K4, M(76) );
+    R( d, e, a, b, c, F4, K4, M(77) );
+    R( c, d, e, a, b, F4, K4, M(78) );
+    R( b, c, d, e, a, F4, K4, M(79) );
+
+    /* Update chaining vars */
+    hd->h0 += a;
+    hd->h1 += b;
+    hd->h2 += c;
+    hd->h3 += d;
+    hd->h4 += e;
+}
+
+/* Update the message digest with the contents
+ * of INBUF with length INLEN.
+ */
+static void
+sha1_write( SHA1_CONTEXT *hd, unsigned char *inbuf, size_t inlen)
+{
+    if( hd->count == 64 ) { /* flush the buffer */
+	transform( hd, hd->buf );
+	hd->count = 0;
+	hd->nblocks++;
+    }
+    if( !inbuf )
+	return;
+    if( hd->count ) {
+	for( ; inlen && hd->count < 64; inlen-- )
+	    hd->buf[hd->count++] = *inbuf++;
+	sha1_write( hd, NULL, 0 );
+	if( !inlen )
+	    return;
+    }
+
+    while( inlen >= 64 ) {
+	transform( hd, inbuf );
+	hd->count = 0;
+	hd->nblocks++;
+	inlen -= 64;
+	inbuf += 64;
+    }
+    for( ; inlen && hd->count < 64; inlen-- )
+	hd->buf[hd->count++] = *inbuf++;
+}
+
+/* The routine final terminates the computation and
+ * returns the digest.
+ * The handle is prepared for a new cycle, but adding bytes to the
+ * handle will the destroy the returned buffer.
+ * Returns: 20 bytes representing the digest.
+ */
+static void
+sha1_final(SHA1_CONTEXT *hd)
+{
+    u32 t, msb, lsb;
+    unsigned char *p;
+
+    sha1_write(hd, NULL, 0); /* flush */;
+
+    t = hd->nblocks;
+    /* multiply by 64 to make a byte count */
+    lsb = t << 6;
+    msb = t >> 26;
+    /* add the count */
+    t = lsb;
+    if( (lsb += hd->count) < t )
+	msb++;
+    /* multiply by 8 to make a bit count */
+    t = lsb;
+    lsb <<= 3;
+    msb <<= 3;
+    msb |= t >> 29;
+
+    if( hd->count < 56 ) { /* enough room */
+	hd->buf[hd->count++] = 0x80; /* pad */
+	while( hd->count < 56 )
+	    hd->buf[hd->count++] = 0;  /* pad */
+    }
+    else { /* need one extra block */
+	hd->buf[hd->count++] = 0x80; /* pad character */
+	while( hd->count < 64 )
+	    hd->buf[hd->count++] = 0;
+	sha1_write(hd, NULL, 0);  /* flush */;
+	memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
+    }
+    /* append the 64 bit count */
+    hd->buf[56] = msb >> 24;
+    hd->buf[57] = msb >> 16;
+    hd->buf[58] = msb >>  8;
+    hd->buf[59] = msb	   ;
+    hd->buf[60] = lsb >> 24;
+    hd->buf[61] = lsb >> 16;
+    hd->buf[62] = lsb >>  8;
+    hd->buf[63] = lsb	   ;
+    transform( hd, hd->buf );
+
+    p = hd->buf;
+#ifdef BIG_ENDIAN_HOST
+#define X(a) do { *(u32*)p = hd->h##a ; p += 4; } while(0)
+#else /* little endian */
+#define X(a) do { *p++ = hd->h##a >> 24; *p++ = hd->h##a >> 16;	 \
+		      *p++ = hd->h##a >> 8; *p++ = hd->h##a; } while(0)
+#endif
+    X(0);
+    X(1);
+    X(2);
+    X(3);
+    X(4);
+#undef X
+}
+
+#include <assert.h>
+
+int sha1proc (char *fn, char *buf)
+{
+  assert (sizeof (u32) == 4);
+  FILE *fp;
+  char buffer[4096];
+  size_t n;
+  SHA1_CONTEXT ctx;
+  int i;
+  
+  fp = fopen(fn, "rb");
+  if (!fp)
+  {
+    return(1);
+  }
+  sha1_init(&ctx);
+  while ( (n = fread(buffer, 1, sizeof buffer, fp)))
+    sha1_write(&ctx, buffer, n);
+  if (ferror(fp))
+  {
+    return(1);
+  }
+  sha1_final (&ctx);
+  fclose(fp);
+  for (i=0; i < 20; i++)
+    sprintf(buf+(2*i), "%02x", ctx.buf[i]);
+  sprintf(buf+40, "  \0");
+  return 0;
+}
+/*man-start*********************************************************************
+COMMAND
+     shasum - compute SHA1 checksum
+
+SYNTAX
+     SHASUM file
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short sha1sum(CHARTYPE *params)
+#else
+short sha1sum(params)
+CHARTYPE *params;
+#endif
+{
+  char fn[MAX_FILE_NAME+1];
+  char sha1buffer[MAX_FILE_NAME+42];
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm4.c:   sha1sum");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(3,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (access(params, R_OK))
+  {
+    display_error(9,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_FILE_NOT_FOUND);
+  }
+  strcpy(fn, params);
+  sha1buffer[0] = '\0';
+  if (sha1proc(fn, sha1buffer) == 0)
+    strcat(sha1buffer, basename(fn));
+  else
+  {
+    display_error(0,(CHARTYPE *)"Can't create SHA1SUM",FALSE);
+    TRACE_RETURN();
+    return(-1);
+  }
+  strcpy(fn, params);
+  strcat(fn, (DEFCHAR *)".sha1\0");
+  rc = EditFile(fn, FALSE );
+  (void)Add((DEFCHAR *)"");
+  (void)THEcursor_column();
+  (void)Text(sha1buffer);
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      shift - move text left or right
@@ -2653,6 +3298,83 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     splttok - retrieves tokens from current line which are delimited by
+               characters from parameter, then add to new lines
+
+SYNTAX
+     SPLTTOK [char/s/]
+
+SEE ALSO
+     <LINESEP>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Splttok(CHARTYPE *params)
+#else
+short Splttok(params)
+CHARTYPE *params;
+#endif
+{
+  LINE *curr=NULL;
+  LINETYPE true_line=0L;
+  CHARTYPE *tok;
+  CHARTYPE *tmp;
+  CHARTYPE *parpos;
+  char spac[]=" ";
+  short len=0;
+  TRACE_FUNCTION("comm4.c:   Splttok");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    parpos = spac;
+  }
+  else
+  {
+    parpos = params;
+    len = strlen(params);
+    if (len>1 && params[0]==params[len-1])
+    {
+      params[len-1] = 0;
+      parpos++;
+    }
+  }
+  true_line = CURRENT_VIEW->current_line;
+  if (VIEW_TOF(CURRENT_VIEW,true_line) || VIEW_BOF(CURRENT_VIEW,true_line))
+  {
+    display_error(38,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_ENVIRON);
+  }
+  post_process_line(CURRENT_VIEW,CURRENT_VIEW->focus_line,(LINE *)NULL,TRUE);
+  curr = lll_find(CURRENT_FILE->first_line,CURRENT_FILE->last_line,true_line,CURRENT_FILE->number_lines);
+  len = strlen(curr->line);
+  if ((tmp = (CHARTYPE *)(*the_malloc)(len+1)) == NULL)
+  {
+    display_error(30,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  strcpy(tmp,curr->line);
+  for (tok=strtok(tmp,parpos); tok; tok=strtok(0,parpos))
+  {
+    if (strcmp(tok,curr->line) != 0)
+    {
+      insert_new_line(current_screen,CURRENT_VIEW,(CHARTYPE *)"",0,1,get_true_line(TRUE),TRUE,FALSE,TRUE,CURRENT_VIEW->display_low,TRUE,FALSE);
+      advance_current_or_focus_line(1);
+      Replace((CHARTYPE *)tok);
+    }
+  }
+  advance_current_or_focus_line(1);
+  (*the_free)(tmp);
+  TRACE_RETURN();
+  return(RC_OK);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      ssave - force SAVE to specified file
diff -Naurd a/comm5.c b/comm5.c
--- a/comm5.c	2013-07-26 16:09:13.000000000 +0200
+++ b/comm5.c	2013-07-26 16:10:02.000000000 +0200
@@ -1019,6 +1019,113 @@
    return(RC_OK);
 }
 
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     tobin - convert to binary list
+
+SYNTAX
+     TOBIN [target]
+
+SEE ALSO
+     <TODEC>, <TOHEX>, <TOCHR>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Tobin(CHARTYPE *params)
+#else
+short Tobin(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   tobin");
+ rc = Format(params,F_TOBIN,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     tochr - convert from list
+
+SYNTAX
+     TOCHR [target]
+
+SEE ALSO
+     <TOBIN>, <TODEC>, <TOHEX>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Tochr(CHARTYPE *params)
+#else
+short Tochr(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   tochr");
+ rc = Format(params,F_TOCHR,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     todec - convert to decimal list
+
+SYNTAX
+     TODEC [target]
+
+SEE ALSO
+     <TOBIN>, <TOCHR>, <TOHEX>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Todec(CHARTYPE *params)
+#else
+short Todec(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   todec");
+ rc = Format(params,F_TODEC,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     tohex - convert to hexadecimal list
+
+SYNTAX
+     TOHEX [target]
+
+SEE ALSO
+     <TOBIN>, <TODEC>, <TOCHR>, <EBCDIC>, <TOASCII>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Tohex(CHARTYPE *params)
+#else
+short Tohex(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   tohex");
+ rc = Format(params,F_TOHEX,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      top - move to the top of the file
@@ -1086,6 +1193,166 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/*man-start*********************************************************************
+COMMAND
+     truncate - remove trailing blanks
+
+SYNTAX
+     TRUNCate [target]
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Truncate(CHARTYPE *params)
+#else
+short Truncate(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   truncate");
+ rc = Format(params,F_TRUNC,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+
+// void translate(char *str)
+// {
+//   char *here=str;
+//   size_t len=strlen(str);
+//   int num;
+//   int numlen;
+//   while (NULL!=(here=strchr(here,'\\')))
+//   {
+//     numlen=1;
+//     switch (here[1])
+//     {
+//     case '\\':
+//           break;
+//     case 'r':
+//           *here = '\r';
+//           break;
+//     case 'n':
+//           *here = '\n';
+//           break;
+//     case 't':
+//           *here = '\t';
+//           break;
+//     case 'v':
+//           *here = '\v';
+//           break;
+//     case 'a':
+//           *here = '\a';
+//           break;
+//     case 'b':
+//           *here = '\b';
+//           break;
+//     case 'f':
+//           *here = '\f';
+//           break;
+//     case 'h':
+//           *here = '\x8';
+//           break;
+// /*
+// //  case '0':
+// //  case '1':
+// //  case '2':
+// //  case '3':
+// //  case '4':
+// //  case '5':
+// //  case '6':
+// //  case '7':
+// //        numlen = sscanf(here+2,"%o",&num)+2;
+// //        *here = (char)num;
+// //        break;
+// */
+//     case 'x':
+//           numlen = sscanf(here+2,"%x",&num)+1;
+//           *here = (char)num;
+//           while (isxdigit(here[numlen]))
+//              numlen++;
+//           if (num>0xFF)
+//           {
+//             here[0] = (char)(num>>8);
+//             here[1] = (char)num;
+//             here++;
+//             numlen--;
+//           }
+//           numlen--;
+//           break;
+//     case 'd':
+//           numlen = sscanf(here+2,"%d",&num)+1;
+//           while (isdigit(here[numlen]))
+//              numlen++;
+//           *here = (char)num;
+//           numlen--;
+//           break;
+//     default:
+//           here++;
+//           continue;
+//     }
+//     num = here - str + numlen;
+//     here++;
+//     memmove(here, here+numlen, len-num);
+//   }
+// }
+// /*man-s
+// COMMAND
+//      unescape - convert escape sequences
+//
+// SYNTAX
+//      UNESCape [target]
+//
+// SEE ALSO
+//      <ANSICSTR>
+//
+// STATUS
+//      GYMOD
+// **man-e
+// #ifdef HAVE_PROTO
+// short Unesc(CHARTYPE *params)
+// #else
+// short Unesc(params)
+// CHARTYPE *params;
+// #endif
+// {
+//  short rc=RC_OK;
+//  TRACE_FUNCTION("comm5.c:   trans");
+//  rc = Format(params,F_UNESC,TRUE);
+//  TRACE_RETURN();
+//  return(rc);
+// }
+
+/*man-start*********************************************************************
+COMMAND
+     unjust - left-adjust text and compress blanks
+
+SYNTAX
+     UNJUST [target]
+
+SEE ALSO
+     <JUSTIFY>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Unjust(CHARTYPE *params)
+#else
+short Unjust(params)
+CHARTYPE *params;
+#endif
+{
+ short rc=RC_OK;
+ TRACE_FUNCTION("comm5.c:   unjust");
+ rc = Format(params,F_UNJUST,TRUE);
+ TRACE_RETURN();
+ return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      up - move backward in the file a number of lines
@@ -1186,6 +1453,716 @@
    TRACE_RETURN();
    return(rc);
 }
+#ifdef GYMOD
+/***********************************************************************/
+// static char sccsid[] = "@(#)uuencode.c  5.1 (Berkeley) 7/2/83";
+#define UUFILE ("uufile.tmp")
+void encode(FILE *in, FILE *out);
+void outdec(char *p, FILE *f);
+int fr(FILE *fd, char *buf, int cnt);
+// ENC is the basic 1 character encoding function to make a char printing
+#define ENC(c) (((c) & 077) + ' ')
+#define DEC(c) (char)(((c)-' ')&077)
+/*man-start*********************************************************************
+COMMAND
+     uudecode - decode .uue file
+
+SYNTAX
+     UUDECODE
+
+SEE ALSO
+     <UUENCODE>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Uudecode(CHARTYPE *params)
+#else
+short Uudecode(params)
+CHARTYPE *params;
+#endif
+{
+  FILE *in=NULL, *out=NULL;
+  CHARTYPE *actfname = CURRENT_FILE->fname;
+  int  n;
+  char buf[MAX_FILE_NAME+1];
+  char uufile[]=UUFILE;
+  char a,b,c,d;
+  short i;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm5.c:   Uudecode");
+  if (strcmp((DEFCHAR *)params,"") != 0)
+  {
+    display_error(1,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if ((Ssave(actfname) != RC_OK)
+      || (in=fopen(actfname, "rt")) == NULL)
+  {
+    if (in!=NULL)
+      fclose(in);
+    display_error(0,(CHARTYPE *)"Can't process UUDECODE.",FALSE);
+    TRACE_RETURN();
+    return(RC_IO_ERROR);
+  }
+  if (fscanf(in, "begin %o ", &n) !=1)
+  {
+    fclose(in);
+    display_error(7,(CHARTYPE *)actfname,FALSE);
+    TRACE_RETURN();
+    return(RC_IO_ERROR);
+  }
+  fgets(buf, MAX_FILE_NAME ,in);
+  for (i=0; i<MAX_FILE_NAME; i++)
+  {
+    if (buf[i]<0x20)
+    {
+      buf[i]=0;
+      break;
+    }
+  }
+  if ((out = fopen(uufile, "wb")) != NULL)
+  {
+    while ((n=getc(in))!=EOF&&((n=DEC(n))!=0))
+    {
+      while (n>0)
+      {
+        a=DEC(getc(in));
+        b=DEC(getc(in));
+        c=DEC(getc(in));
+        d=DEC(getc(in));
+        if (n-->0)
+          putc((a<<2)|(b>>4),out);
+        if (n-->0)
+          putc((b<<4)|(c>>2),out);
+        if (n-->0)
+          putc((c<<6)|d, out);
+      }
+      n=getc(in);  /* skip \n */
+    }
+    fclose(out);
+    Qquit((DEFCHAR *)"");
+    rc = Xedit((CHARTYPE *)uufile);
+    Filename((CHARTYPE *)buf);
+    remove(uufile);
+  }
+  fclose(in);
+  TRACE_RETURN();
+  return(rc);
+}
+/*man-start*********************************************************************
+COMMAND
+     uuencode - encode entire file
+
+SYNTAX
+     UUENCODE
+
+SEE ALSO
+     <UUDECODE>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Uuencode(CHARTYPE *params)
+#else
+short Uuencode(params)
+CHARTYPE *params;
+#endif
+{
+#if defined(MSDOS) || defined(__MSDOS__)
+ #define READ_BINARY "rb"
+#else
+ #define READ_BINARY "r"
+#endif
+  FILE *in=NULL, *out=NULL;
+  struct stat sbuf;
+  int mode;
+  CHARTYPE *actfname = CURRENT_FILE->fname;
+  char buf[MAX_FILE_NAME+1];
+  char uufile[]=UUFILE;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm5.c:   Uuencode");
+  if (strcmp((DEFCHAR *)params,"") != 0)
+  {
+    display_error(1,(CHARTYPE *)params,FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (strcmp(actfname+(strlen(actfname)-3), "uue")==0)
+  {
+    display_error(7,(CHARTYPE *)actfname,FALSE);
+    TRACE_RETURN();
+    return(RC_IO_ERROR);
+  }
+  if ((display_length == 0 && Ssave(actfname) != RC_OK)
+      || (in = fopen(actfname, READ_BINARY)) == NULL)
+  {
+    if (in!=NULL)
+      fclose(in);
+    display_error(0,(CHARTYPE *)"Can't process UUENCODE.",FALSE);
+    TRACE_RETURN();
+    return(RC_IO_ERROR);
+  }
+  strcpy(buf, actfname);
+  strcat(buf, ".uue\0");
+  fstat(fileno(in), &sbuf);
+  mode = sbuf.st_mode & 0777;
+  if ((out = fopen(uufile, "wt")) != NULL)
+  {
+    fprintf(out, "begin %o %s\n", mode, actfname);
+    encode(in, out);
+    fprintf(out, "end\n");
+    fclose(out);
+    Qquit((DEFCHAR *)"");
+    rc = Xedit((CHARTYPE *)uufile);
+    Filename((CHARTYPE *)buf);
+    remove(uufile);
+  }
+  fclose(in);
+  TRACE_RETURN();
+  return(rc);
+}
+// copy from in to out, encoding as you go along.
+void encode(FILE *in, FILE *out)
+{
+  char buf[80];
+  int i, n;
+  for (;;)
+  {
+    /* 1 (up to) 45 character line */
+    n = fr(in, buf, 45);
+    putc(ENC(n), out);
+    for (i = 0; i < n; i += 3)
+      outdec(&buf[i], out);
+    putc('\n', out);
+    if (n <= 0)
+      break;
+  }
+}
+// output one group of 3 bytes, pointed at by p, on file f.
+void outdec(char *p, FILE *f)
+{
+  int c1, c2, c3, c4;
+  c1 = *p >> 2;
+  c2 = ((p[0] << 4) & 060) | ((p[1] >> 4) & 017);
+  c3 = ((p[1] << 2) & 074) | ((p[2] >> 6) & 03);
+  c4 = p[2] & 077;
+  putc(ENC(c1), f);
+  putc(ENC(c2), f);
+  putc(ENC(c3), f);
+  putc(ENC(c4), f);
+}
+// fr: like read but stdio
+int fr(FILE *fd, char *buf, int cnt)
+{
+  int c, i;
+  for (i = 0; i < cnt; i++)
+  {
+    c = getc(fd);
+    if (c == EOF)
+      return(i);
+    buf[i] = (char)c;
+  }
+  return (cnt);
+}
+
+#include <glob.h>
+bool file_list_msg = TRUE;
+/*man-start*********************************************************************
+COMMAND
+     wedit - edit files specifyed with wildcard
+
+SYNTAX
+     Wedit files
+
+SEE ALSO
+     <FSEARCH>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Wedit(CHARTYPE *params)
+#else
+short Wedit(params)
+CHARTYPE *params;
+#endif
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+ #define WED_PARAMS 11
+ unsigned short num_params=0;
+ CHARTYPE *word[WED_PARAMS+1];
+ CHARTYPE *wpars[WED_PARAMS];
+ CHARTYPE strip[WED_PARAMS];
+ register short i,j;
+ glob_t glob_results;
+ short rc=RC_OK;
+/*--------------------------- processing ------------------------------*/
+ TRACE_FUNCTION("comm5.c:   Wedit");
+ for (i=0;i<WED_PARAMS;i++)
+   strip[i]=STRIP_BOTH;
+ num_params = param_split(params,word,WED_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+ if (num_params == 0)
+ {
+   display_error(3,(CHARTYPE *)"Specify with wildcard!",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ if (num_params >= WED_PARAMS)
+ {
+   display_error(2,(CHARTYPE *)"",FALSE);
+   TRACE_RETURN();
+   return(RC_INVALID_OPERAND);
+ }
+ for (i=0;i<num_params;i++)
+ {
+   if ((wpars[i] = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+   {
+     display_error(30,(CHARTYPE *)"",FALSE);
+     TRACE_RETURN();
+     return(RC_OUT_OF_MEMORY);
+   }
+   strcpy(wpars[i],word[i]);
+ }
+ for (i=0;i<num_params;i++)
+ {
+   glob(wpars[i], GLOB_NOCHECK, 0, &glob_results);
+   for (j = 0; j<glob_results.gl_pathc; j++)
+   {
+     rc = EditFile((CHARTYPE *)glob_results.gl_pathv[j],FALSE);
+     //if ((rc == RC_OK) && file_list_msg)
+     //{
+     //  display_error(0,glob_results.gl_pathv[j],TRUE);
+     //}
+   }
+   globfree(&glob_results);
+   the_free(wpars[i]);
+ }
+ TRACE_RETURN();
+ return(rc);
+}
+// #define WED_PARAMS 11
+// unsigned short num_params=0;
+// CHARTYPE *word[WED_PARAMS+1];
+// CHARTYPE *wpars[WED_PARAMS];
+// CHARTYPE strip[WED_PARAMS];
+// CHARTYPE *fn=NULL;
+// CHARTYPE **par=NULL;
+// register short i;
+// short rc=RC_OK;
+///*--------------------------- processing ------------------------------*/
+// TRACE_FUNCTION("comm5.c:   Wedit");
+// for (i=0;i<WED_PARAMS;i++)
+//   strip[i]=STRIP_BOTH;
+// num_params = param_split(params,word,WED_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+// if (num_params == 0)
+// {
+//   display_error(3,(CHARTYPE *)"Specify with wildcard!",FALSE);
+//   TRACE_RETURN();
+//   return(RC_INVALID_OPERAND);
+// }
+// if (num_params >= WED_PARAMS)
+// {
+//   display_error(2,(CHARTYPE *)"",FALSE);
+//   TRACE_RETURN();
+//   return(RC_INVALID_OPERAND);
+// }
+// for (i=0;i<num_params;i++)
+// {
+//   if ((wpars[i] = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+//   {
+//     display_error(30,(CHARTYPE *)"",FALSE);
+//     TRACE_RETURN();
+//     return(RC_OUT_OF_MEMORY);
+//   }
+//   strcpy(wpars[i],word[i]);
+// }
+// for (i=0;i<num_params;i++)
+// {
+//   par = __crt0_glob_function(wpars[i]);
+//   while ((fn = *par) != NULL)
+//   {
+//     rc = EditFile((CHARTYPE *)fn,FALSE);
+//     if ((rc == RC_OK) && file_list_msg)
+//     {
+//       display_error(0,fn,TRUE);
+//     }
+//     par++;
+//   }
+//   the_free(wpars[i]);
+// }
+// TRACE_RETURN();
+// return(rc);
+//}
+// DOS code removed!
+//#define WED_PARAMS 10
+// unsigned short num_params=0;
+// CHARTYPE *word[WED_PARAMS+1];
+// CHARTYPE *wpars[WED_PARAMS+1];
+// CHARTYPE strip[WED_PARAMS];
+// CHARTYPE *pn=NULL;
+// CHARTYPE *fn=NULL;
+// struct ffblk f;
+// int done;
+// register short i;
+// int j, k;
+// short rc=RC_OK;
+///*--------------------------- processing ------------------------------*/
+// TRACE_FUNCTION("comm5.c:   Wedit");
+// for (i=0;i<WED_PARAMS;i++)
+//   strip[i]=STRIP_BOTH;
+// num_params = param_split(params,word,WED_PARAMS,WORD_DELIMS,TEMP_PARAM,strip,FALSE);
+// if (num_params == 0)                                     /* no params */
+// {
+//    display_error(3,(CHARTYPE *)"Specify with wildcard!",FALSE);
+//    TRACE_RETURN();
+//    return(RC_INVALID_OPERAND);
+// }
+// for (i=0;i<=num_params;i++)
+// {
+//   if ((wpars[i] = (CHARTYPE *)(*the_malloc)(MAX_FILE_NAME)) == NULL)
+//   {
+//    display_error(30,(CHARTYPE *)"",FALSE);
+//    TRACE_RETURN();
+//    return(RC_OUT_OF_MEMORY);
+//   }
+//   strcpy(wpars[i],word[i]);
+// }
+// for (i=0;i<num_params;i++)
+// {
+//    if ((pn = dirname(wpars[i])) == NULL)
+//    {
+//       display_error(30,(CHARTYPE *)"",FALSE);
+//       TRACE_RETURN();
+//       return(RC_OUT_OF_MEMORY);
+//    }
+//    done = findfirst(wpars[i], &f, 0 ^ (FA_LABEL & FA_DIREC));
+//    if (done != 0)
+//    {
+//       display_error(9,(CHARTYPE *)"",FALSE);
+//       rc = RC_FILE_NOT_FOUND;
+//    }
+//    j = 0;
+//    while (!done)
+//    {
+//       if ((fn = (CHARTYPE *)make_full(pn,f.ff_name)) == NULL)
+//       {
+//          display_error(30,(CHARTYPE *)"",FALSE);
+//          TRACE_RETURN();
+//          return(RC_OUT_OF_MEMORY);
+//       }
+//       _truename(fn,wpars[num_params]);
+//       rc = EditFile((CHARTYPE *)fn,FALSE);
+//       if (rc == RC_OK)
+//       {
+//         display_error(0,wpars[num_params],TRUE);
+//       }
+//       j++;
+//       done = findfirst(wpars[i], &f, 0 ^ (FA_LABEL & FA_DIREC));
+//       for (k=0;k<j;k++)
+//       {
+//         done = findnext(&f);
+//       }
+//    }
+// }
+// TRACE_RETURN();
+// return(rc);
+//}
+
+/*man-start*********************************************************************
+COMMAND
+     window - get keypress or menu selection to edit variable
+
+SYNTAX
+     WINDow [MENU] </Y/X/str>[/str...]
+
+DESCRIPTION
+     Creates a new window with the Y and X position, writes the string(s),
+     and set WINDKEY edit-variable from the pressed key, or
+     WINDNUM & WINDSTR from the selected menu item.
+
+SEE ALSO
+     <EDITV>, <POPUP>
+
+STATUS
+     GYMOD
+**man-end**********************************************************************/
+#ifdef HAVE_PROTO
+short Wind(CHARTYPE *params)
+#else
+short Wind(params)
+CHARTYPE *params;
+#endif
+{
+#define MAX_LEN 256
+#define MAX_LIN 50
+  WINDOW *fw=NULL, *dw=NULL;
+  short height=0,width=0,y=0,x=0;
+  short i,j,k;
+  bool menu = FALSE;
+  bool loop = TRUE;
+  CHARTYPE *strs[MAX_LIN];
+  char pstr[MAX_LEN];
+  char windkey[9] = "";
+  char del[1] = "";
+  char u = '\0';
+  char *tok;
+  LINE *curr=NULL;
+  CHARTYPE *p=NULL,*str=NULL;
+  short rc=RC_OK;
+  TRACE_FUNCTION("comm5.c:   Wind");
+  if (strcmp((DEFCHAR *)params,"") == 0)
+  {
+    display_error(0,(DEFCHAR *)"Usage: WINDow [MENU] </Y/X/str>[/str...]",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  if (strcmp((DEFCHAR *)params,"MENU") > 0)
+  {
+    menu = TRUE;
+    strcpy(pstr, &params[5]);
+  }
+  else
+    strcpy(pstr, params);
+  for (i=0; i<MAX_LIN; i++)
+    strs[i] = NULL;
+  i = 0;
+  j = 0;
+  del[0] = pstr[0];
+  del[1] = '\0';
+  for (tok=strtok(pstr,del); tok; tok=strtok(0,del))
+  {
+    switch(i)
+    {
+      case 0:
+        y = atoi(tok);
+        break;
+      case 1:
+        x = atoi(tok);
+        break;
+      case MAX_LIN:
+        tok = NULL;
+        break;
+      default:
+        if ((strs[i-2] = (CHARTYPE *)(*the_malloc)(MAX_LEN)) == NULL)
+        {
+          display_error(30,(CHARTYPE *)"",FALSE);
+          TRACE_RETURN();
+          return(RC_OUT_OF_MEMORY);
+        }
+        k = strlen(tok);
+        if (k > j)
+          j = k;
+        strcpy(strs[i-2],tok);
+        break;
+    }
+    i++;
+  }
+  if (i < 3)
+  {
+    display_error(1,(CHARTYPE *)"",FALSE);
+    TRACE_RETURN();
+    return(RC_INVALID_OPERAND);
+  }
+  else
+  {
+    if (i > terminal_lines)
+      i = terminal_lines;
+    else if (i > MAX_LIN)
+      i = MAX_LIN;
+  }
+  height = i;
+  width = j+2;
+  fw = newwin(height,width,y,x);
+  if (fw == NULL)
+  {
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+#ifdef HAVE_WBKGD
+  wbkgd(fw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+#else
+  wattrset(fw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+  wmove(fw,0,0);
+  wclrtobot(fw);
+#endif
+#if defined(HAVE_BOX)
+  wattrset(fw,set_colour(CURRENT_FILE->attr+ATTR_DIVIDER));
+  box(fw,0,0);
+#endif
+  wnoutrefresh(fw);
+  height -= 2;
+  width -= 2;
+  y++;
+  x++;
+  dw = newwin(height,width,y,x);
+  if (dw == NULL)
+  {
+    delwin(fw);
+    display_error( 30, (CHARTYPE *)"", FALSE );
+    TRACE_RETURN();
+    return(RC_OUT_OF_MEMORY);
+  }
+  scrollok(dw,FALSE);
+  wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+  wclrtobot(dw);
+  wnoutrefresh(dw);
+  draw_cursor(FALSE);
+  if (menu)
+  {
+    strcpy(pstr,(DEFCHAR *)"WINDNUM");
+    p = make_upper(pstr);
+    curr = lll_locate(editv, p);
+    if ( curr
+    &&   curr->line )
+    {
+       str = curr->line;
+       j = atoi(str);
+       j--;
+       if (j >= height || j < 0)
+         j = 0;
+    }
+    else
+       j = 0;
+    k = 0;
+    while (loop)
+    {
+      wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_FILEAREA));
+      wclrtobot(dw);
+      for (i=0; i<height; i++)
+      {
+        wmove(dw,i,0);
+        waddstr(dw, strs[i]);
+        if (strlen(strs[i]) < width)
+          my_wclrtoeol(dw);
+      }
+      wattrset(dw,set_colour(CURRENT_FILE->attr+ATTR_CURLINE));
+      wmove(dw,j,0);
+      waddstr(dw, strs[j]);
+      if (strlen(strs[j]) < width)
+        my_wclrtoeol(dw);
+      wrefresh(dw);
+      k = wgetch(stdscr);
+#if defined(PDCURSES_MOUSE_ENABLED) || defined(NCURSES_MOUSE_VERSION)
+      if (k == KEY_MOUSE)
+      {
+         int b,ba,bm,my,mx;
+         get_mouse_info(&b,&ba,&bm);
+         if (b != 1
+         ||  ba == BUTTON_PRESSED)
+            continue;
+         wmouse_position(dw, &my, &mx);
+         if (my != -1
+         &&  mx != -1)
+         {
+           if (my == j)
+             k = KEY_ENTER;
+           j = my;
+         }
+      }
+#endif
+      switch(k)
+      {
+        case KEY_UP:
+          if (j>0)
+            j--;
+          else
+            j = height-1;
+          break;
+        case KEY_DOWN:
+          if (j<(height-1))
+            j++;
+          else
+            j = 0;
+          break;
+        case KEY_HOME:
+        case KEY_PPAGE:
+          j = 0;
+          break;
+        case KEY_END:
+        case KEY_NPAGE:
+          j = height-1;
+          break;
+        case KEY_EXIT:
+        case KEY_UNDO:
+        case 27:
+          j = -1;
+        case KEY_ENTER:
+        case 10:
+        case 13:
+          loop = FALSE;
+          break;
+        default:
+          break;
+      }
+      if (k > 0x1F && k < 0x100)
+      {
+        u = toupper(k);
+        i = j+1;
+        for (; i<height && toupper(strs[i][0])!=u; i++)
+        {
+        }
+        if (i<height)
+          j = i;
+        else
+        {
+          i = 0;
+          for (; i<j && toupper(strs[i][0])!=u; i++)
+          {
+          }
+          if (i<j)
+            j = i;
+        }
+      }
+    }
+    itoa_dj(j+1, windkey, 10);
+    strcpy(pstr,(DEFCHAR *)"WINDNUM ");
+    strcat(pstr, windkey);
+    execute_editv(EDITV_SETL,FALSE,pstr);
+    strcpy(pstr,(DEFCHAR *)"WINDSTR ");
+    if (j != -1)
+      strcat(pstr, strs[j]);
+    rc = execute_editv(EDITV_SETL,FALSE,pstr);
+  }
+  else
+  {
+    for (i=0; i<height; i++)
+    {
+      wmove(dw,i,0);
+      waddstr(dw, strs[i]);
+      if (strlen(strs[i]) < width)
+        my_wclrtoeol(dw);
+    }
+    wrefresh(dw);
+    i = my_getch(stdscr);
+    strcpy(windkey,(DEFCHAR *)"WINDKEY ?");
+    windkey[8] = (char)i;
+    rc = execute_editv(EDITV_SETL,FALSE,windkey);
+  }
+  delwin(dw);
+  delwin(fw);
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  my_wclrtoeol(CURRENT_WINDOW_COMMAND);
+  wmove(CURRENT_WINDOW_COMMAND,0,0);
+  CURRENT_VIEW->cmdline_col = -1;
+  THERefresh((CHARTYPE *)"");
+  draw_cursor(TRUE);
+  restore_THE();
+  for (i=0; i<MAX_LIN; i++)
+  {
+    if (strs[i] != NULL)
+      the_free(strs[i]);
+  }
+  TRACE_RETURN();
+  return(rc);
+}
+#endif //GYMOD
+
 /*man-start*********************************************************************
 COMMAND
      xedit - edit another file or switch to next file
diff -Naurd a/command.h b/command.h
--- a/command.h	2013-07-26 16:09:13.000000000 +0200
+++ b/command.h	2013-07-26 16:10:02.000000000 +0200
@@ -549,5 +549,71 @@
  {(CHARTYPE *)"the",         3,  (-1),            Xedit,            TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
  {(CHARTYPE *)"untaa",       5,  (-1),            Untaa,            TRUE, TRUE, FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* commset2.c */
  {(CHARTYPE *)"zone",        1,  (-1),            Zone,             TRUE, TRUE, FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* commset2.c */
+#ifdef GYMOD
+/*                                                                  Batch/ Set / SOS / RO   /edit/strip     /readv/input/reprof/CUA             /THIGHLIGHT  */
+ {(CHARTYPE *)"ansicstr",    5,  (-1),            Ansicstr,         FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"banner",      6,  (-1),            Banner,           FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"calc",        4,  (-1),            Calc,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"center",      2,  (-1),            Center,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+//#if defined(PDC_CLIP_SUCCESS)
+// {(CHARTYPE *)"clp",         3,  (-1),            Clipboard,        TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+//#endif
+ {(CHARTYPE *)"crypt",       5,  (-1),            Crypt,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"savecrypt",   9,  (-1),            SCrypt,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"loadcrypt",   9,  (-1),            LCrypt,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+// {(CHARTYPE *)"rle",         3,  (-1),            RLE,              TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+// {(CHARTYPE *)"rld",         3,  (-1),            RLD,              TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"lzencode",    3,  (-1),            LZE,              TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"lzdecode",    3,  (-1),            LZD,              TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm1.c */
+ {(CHARTYPE *)"ebcdic",      6,  (-1),            Ebcdic,           FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"eval",        4,  (-1),            Eval,             TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"flow",        4,  (-1),            Flow,             TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"forcesave",   9,  (-1),            Fsave,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"fsearch",     7,  (-1),            FSearch,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"hlowercase",  4,  (-1),            HLowercase,       TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"hsort",       5,  (-1),            HSort,            TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"huppercase",  4,  (-1),            HUppercase,       TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"justify",     4,  (-1),            Justify,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"lcompress",   5,  (-1),            Lcompress,        TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_NONE,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"ledit",       5,  (-1),            Ledit,            TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"leftadjust",  5,  (-1),            Leftad,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"lexpand",     4,  (-1),            Lexpand,          TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"linesep",     7,  (-1),            Linesep,          TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"mdsum",       5,  (-1),            md5sum,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"merge",       5,  (-1),            Merge,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"mimeb",       5,  (-1),            Mimeb,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"mimeq",       5,  (-1),            Mimeq,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"onespace",    3,  (-1),            Onespc,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm3.c */
+ {(CHARTYPE *)"rightadjust", 6,  (-1),            Rightad,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"ringcmd",     7,  (-1),            Ringcmd,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"sayf",        4,  (-1),            Sayf,             TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"shasum",      6,  (-1),            sha1sum,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"splttok",     7,  (-1),            Splttok,          TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm4.c */
+ {(CHARTYPE *)"tobin",       5,  (-1),            Tobin,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"tochr",       5,  (-1),            Tochr,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"todec",       5,  (-1),            Todec,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"tohex",       5,  (-1),            Tohex,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"truncate",    5,  (-1),            Truncate,         TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+// {(CHARTYPE *)"unescape",    5,  (-1),            Unesc,            TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"unjust",      6,  (-1),            Unjust,           TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"uudecode",    8,  (-1),            Uudecode,         TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"uuencode",    8,  (-1),            Uuencode,         TRUE, FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"wedit",       1,  (-1),            Wedit,            TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"window",      4,  (-1),            Wind,             TRUE, FALSE,FALSE,TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,FALSE,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* comm5.c */
+ {(CHARTYPE *)"copy",        0,  ALT_C,           Copy,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block reset"},  /* comm1.c */
+ {(CHARTYPE *)"copy",        0,  ALT_K,           Copy,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block"},  /* comm1.c */
+ {(CHARTYPE *)"delete",      0,  ALT_G,           DeleteLine,       FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block"}, /* comm2.c */
+ {(CHARTYPE *)"duplicate",   0,  ALT_D,           Duplicate,        TRUE, FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)"1 BLOCK"},  /* comm2.c */
+ {(CHARTYPE *)"fillbox",     4,  ALT_F,           Fillbox,          FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* comm2.c */
+ {(CHARTYPE *)"mark",        0,  ALT_L,           Mark,             FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"line"},  /* comm3.c */
+ {(CHARTYPE *)"mark",        0,  ALT_B,           Mark,             FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"box"},  /* comm3.c */
+ {(CHARTYPE *)"move",        4,  ALT_M,           THEMove,          FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"block reset"},  /* comm3.c */
+ {(CHARTYPE *)"overlaybox",  8,  ALT_O,           Overlaybox,       FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""}, /* comm3.c */
+ {(CHARTYPE *)"reset",       0,  ALT_U,           Reset,            FALSE,FALSE,FALSE,TRUE, FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)"block"},  /* comm4.c */
+ {(CHARTYPE *)"delword",     4,  ALT_W,           Sos_delword,      FALSE,FALSE,TRUE, TRUE, FALSE,STRIP_BOTH,TRUE, FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)""},  /* commsos.c */
+ {(CHARTYPE *)"edit",        4,  ALT_X,           Sos_edit,         FALSE,FALSE,TRUE, TRUE, TRUE, STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_NONE         ,(CHARTYPE *)""},  /* commsos.c */
+ {(CHARTYPE *)"split",       2,  ALT_S,           Split,            FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"aligned cursor"},  /* comm4.c */
+ {(CHARTYPE *)"join",        1,  ALT_J,           Join,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_BOTH,FALSE,FALSE,TRUE ,CUA_RESET_BLOCK  ,THIGHLIGHT_RESET_ALL    ,(CHARTYPE *)"aligned cursor"},  /* comm2.c */
+#endif //GYMOD
  {NULL,                      0,  (-1),            NULL,             FALSE,FALSE,FALSE,FALSE,FALSE,STRIP_NONE,FALSE,FALSE,TRUE ,CUA_NONE         ,THIGHLIGHT_NONE         ,(CHARTYPE *)""}
 };
diff -Naurd a/commset1.c b/commset1.c
--- a/commset1.c	2013-07-26 16:09:13.000000000 +0200
+++ b/commset1.c	2013-07-26 16:10:02.000000000 +0200
@@ -6049,6 +6049,26 @@
       return(RC_INVALID_OPERAND);
    }
    strcpy( (DEFCHAR *)the_macro_path, (DEFCHAR *)the_macro_path_buf );
+#ifdef GYMOD
+#if defined(UNIX)
+# define PATH_END "/:."
+# define PATH_END2 ":."
+#else
+# define PATH_END "/;."
+# define PATH_END2 ";."
+#endif
+   if (strcmp((DEFCHAR *)(the_macro_path+len-3),PATH_END) != 0)
+   {
+     if ((char)the_macro_path[len-1] != '/')
+     {
+       strcat((DEFCHAR *)the_macro_path,"/");
+       len++;
+     }
+     strcat((DEFCHAR *)the_macro_path,PATH_END2);
+     len += 2;
+   }
+#endif //GYMOD
+
    /*
     * Count the number of PATH_DELIM in the buffer to determine
     * how many pointers to allocate.
diff -Naurd a/commset2.c b/commset2.c
--- a/commset2.c	2013-07-26 16:09:13.000000000 +0200
+++ b/commset2.c	2013-07-26 16:10:02.000000000 +0200
@@ -2052,7 +2052,11 @@
          width1 = -1;
       else
       {
+#ifdef GYMOD
+      if (!valid_positive_integer(word[0]) || (*word[0]=='0'))
+#else //GYMOD
          if (!valid_positive_integer(word[1]))
+#endif //GYMOD
          {
             display_error(1,word[1],FALSE);
             TRACE_RETURN();
diff -Naurd a/commutil.c b/commutil.c
--- a/commutil.c	2013-07-26 16:09:13.000000000 +0200
+++ b/commutil.c	2013-07-26 16:10:02.000000000 +0200
@@ -3028,6 +3028,10 @@
    bool tabs_exhausted=FALSE;
    int state=STATE_NORMAL;
    LENGTHTYPE tabcol=0;
+#ifdef GYMOD
+   bool more=TRUE;
+   short k=0;
+#endif //GYMOD
 
    TRACE_FUNCTION("commutil.c:tabs_convert");
    /*
@@ -3037,7 +3041,11 @@
    {
       for (i=0,j=0;i<curr->length;i++)
       {
+#ifdef GYMOD
+       if (curr->line[i] == '\t' && more)
+#else //GYMOD
          if (curr->line[i] == '\t')
+#endif //GYMOD
          {
             if (use_tabs)
             {
@@ -3082,6 +3090,13 @@
             trec[j++] = curr->line[i];
             if (j >= max_line_length)
               break;
+#ifdef GYMOD
+            if (lefttabconv)
+            {
+              if (more)
+                more = isspace(curr->line[i]);
+            }
+#endif //GYMOD
          }
       }
       /*
@@ -3108,14 +3123,30 @@
    }
    else
    {
+#ifdef GYMOD
+    if (lefttabconv)
+    {
+      for (k=0; (k<curr->length) && isspace(curr->line[k]); k++)
+        {
+        }
+      k++;
+    }
+    else
+      k=curr->length;
+#endif //GYMOD
       for (i=(curr->length)-1,j=0;i>(-1);i--)
       {
          switch(state)
          {
             case STATE_NORMAL:
                trec[j++] = *(curr->line+i);
+#ifdef GYMOD
+               if (is_tab_col(i+1)
+               &&  i != 0 && i<k)
+#else //GYMOD
                if (is_tab_col(i+1)
                &&  i != 0)
+#endif //GYMOD
                {
                   if (*(curr->line+(i-1)) == ' ')
                   {
@@ -4056,6 +4087,9 @@
    int key=0;
    short rc=RC_OK;
    CHARTYPE buf[3];
+#ifdef GYMOD
+   register short i;
+#endif //GYMOD
 
    TRACE_FUNCTION("commutil.c:readv_cmdline");
    if ( CURRENT_WINDOW_COMMAND == (WINDOW *)NULL )
@@ -4066,6 +4100,16 @@
    }
    buf[1] = '\0';
    Cmsg(initial);
+#ifdef GYMOD
+   if (dialogw)
+   {
+     i = strlen((DEFCHAR *)initial);
+     for (; (DEFCHAR *)initial[i-1]==' ' && i>=0; i--)
+     {
+     }
+     start_col = i;
+   }
+#endif //GYMOD
    if ( start_col == -1 )
       THEcursor_cmdline( current_screen, CURRENT_VIEW, (short)(strlen( (DEFCHAR *)initial ) + 1 ) );
    else
@@ -4085,6 +4129,30 @@
          continue;
 #endif
 #if defined(PDCURSES_MOUSE_ENABLED) || defined(NCURSES_MOUSE_VERSION)
+#ifdef GYMOD
+      if (key==9 && dialogw)
+      {
+        rc = RC_READV_TERM;
+        break;
+      }
+      switch(key)
+      {
+        case PADSLASH:
+          key = '/';
+          break;
+        case PADSTAR:
+          key = '*';
+          break;
+        case PADMINUS:
+          key = '-';
+          break;
+        case PADPLUS:
+          key = '+';
+          break;
+        default:
+          break;
+      }
+#endif //GYMOD
       if (key == KEY_MOUSE)
       {
          int b,ba,bm,y,x;
diff -Naurd a/default.c b/default.c
--- a/default.c	2013-07-26 16:09:13.000000000 +0200
+++ b/default.c	2013-07-26 16:10:02.000000000 +0200
@@ -88,6 +88,10 @@
  int COMMANDCALLSx=0;
  int FUNCTIONCALLSx=0;
  bool inDIALOG=FALSE; /* indicates if we are running a dialog or alert */
+#ifdef GYMOD
+ bool HuSortFlag=FALSE;
+ bool HuSortCase=FALSE;
+#endif //GYMOD
 
 /*--------------------------- regular expression syntaxes -------------*/
 struct regexp_syntax _THE_FAR regexp_syntaxes[] =
@@ -114,6 +118,506 @@
    CHARTYPE *contents;
 } DEFAULT_PARSERS;
 
+#ifdef GYMOD
+#ifdef USE_WIDE_CHAR
+ #define STRTYP L
+#else
+ #define STRTYP (CHARTYPE *)
+#endif
+DEFAULT_PARSERS _THE_FAR default_parsers[] =
+{
+   { STRTYP"*REXX.TLD",
+     STRTYP"REXX",
+     STRTYP"* REXX\n:case\nignore\n" \
+":option\nrexx\nfunction ( noblank default alt 4\n" \
+":number\nrexx\n" \
+":identifier\n[a-zA-Z!?_@#$.] [a-zA-Z0-9.!?_@#$]\n" \
+":string\nsingle\ndouble\n" \
+":comment\npaired /* */ nest\nline -- any\n" \
+":label\ndelimiter : any\n" \
+":match\n( )\ndo,select end when,otherwise\n" \
+":header\nline #! column 1\nline :: any\n" \
+":keyword\naddress type 5\narg type 7\nby type 2\ncall type 5\n" \
+"caseless type 2\ndigits type 2\ndo type 5\ndrop type 1\n" \
+"else type 1\nend type 1\nengineering type 2\nexit type 1\nexpose type 2\n" \
+"failure\nfor type 2\nforever type 2\nform type 2\nfuzz type 2\nhalt\n" \
+"if type 1\ninterpret type 1\niterate type 1\nleave type 1\nloop type 1\n" \
+"lower type 2\nname type 2\nnop type 1\nnovalue\nnumeric type 5\noff type 2\n" \
+"on type 2\noptions type 1\notherwise type 1\nparse type 5\nprocedure type 5\n" \
+"pull type 7\npush type 1\nqueue type 1\nreturn type 1\nsay type 1\n" \
+"scientific type 2\nselect type 1\nsignal type 5\nsource type 2\nsyntax\n" \
+"to type 2\nthen type 1\ntrace type 5\nuntil type 2\nupper type 2\nvalue type 2\n" \
+"var type 2\nversion type 2\nwhen type 1\nwhile type 2\nwith type 2\nstem type 2\n" \
+"output type 2\ninput type 2\nerror type 2\nappend type 2\nreplace type 2\n" \
+"normal type 2\nstream type 2\ndefault type 1\ncommand type 2 alt e\n" \
+"system type 2 alt e\nos2environment type 2 alt e\nenvironment type 2 alt e\n" \
+"cmd type 2 alt e\npath type 2 alt e\nregina type 2 alt e\nrexx type 2 alt e\n" \
+":function\n" \
+"abbrev\nabs\naddress\narg\nb2x\nbeep\nbitand\nbitor\nbitxor\nc2d\nc2x\ncenter\n" \
+"centre\nchangestr\ncharin\ncharout\nchars\ncompare\ncondition\ncopies\ncountstr\n" \
+"d2c\nd2x\ndatatype\ndate\ndelstr\ndelword\ndigits\ndirectory\nerrortext\nform\n" \
+"format\nfuzz\ninsert\nlastpos\nleft\nlength\nlinein\nlineout\nlines\nlower\n" \
+"max\nmin\noverlay\npos\nqualify\nqueued\nrandom\nreverse\nright\nrxfuncdrop\n" \
+"rxfuncerrmsg\nrxfuncadd\nrxfuncquery\nrxqueue\nsign\nsourceline\nspace\nstream\n" \
+"strip\nsubstr\nsubword\nsymbol\ntime\ntrace\ntranslate\ntrunc\nupper\nvalue\n" \
+"verify\nword\nwordindex\nwordlength\nwordpos\nwords\nx2b\nx2c\nx2d\nxrange\n\n" \
+":postcompare\nclass [-\\/\\+\\=\\*\\<\\>|%&,] alt w\n" \
+"class [Aa]lt\\. alt 3\nclass [Aa]rb[Cc]har\\. alt 3\nclass [Aa]uto[Cc]ol[ou]r\\. alt 3\nclass [Aa]uto[Ss]ave\\. alt 3\n" \
+"class [Aa]uto[Ss]croll\\. alt 3\nclass [Bb]ackup\\. alt 3\nclass [Bb]eep\\. alt 3\nclass [Bb]lock\\. alt 3\nclass [Cc]ase\\. alt 3\n" \
+"class [Cc]lear[Ee]rror[Kk]ey\\. alt 3\nclass [Cc]lear[Ss]creen\\. alt 3\nclass [Cc]lock\\. alt 3\nclass [Cc]md[Aa]rrows\\. alt 3\n" \
+"class [Cc]md[Ll]ine\\. alt 3\nclass [Cc]ol[ou]r\\. alt 3\nclass [Cc]ol[ou]ring\\. alt 3\nclass [Cc]olumn\\. alt 3\nclass [Cc]ompat\\. alt 3\n" \
+"class [Cc]tl[Cc]har\\. alt 3\nclass [Cc]ur[Ll]ine\\. alt 3\nclass [Cc]ursor\\. alt 3\nclass [Cc]ursorstay\\. alt 3\nclass [Dd]efine\\. alt 3\n" \
+"class [Dd]efsort\\. alt 3\nclass [Dd]ialog\\. alt 3\nclass [Dd]ir[Ff]ileid\\. alt 3\nclass [Dd]ir[Ii]nclude\\. alt 3\nclass [Dd]isplay\\. alt 3\n" \
+"class [Ee]col[ou]r\\. alt 3\nclass [Ee][Ff]ileid\\. alt 3\nclass [Ee][Oo][Ff]\\. alt 3\nclass [Ee]olout\\. alt 3\nclass [Ee]quiv[Cc]har\\. alt 3\n" \
+"class [Ee]t[Mm]ode\\. alt 3\nclass [Ff][Ee]xt\\. alt 3\nclass [Ff]ield\\. alt 3\nclass [Ff]ield[Ww]ord\\. alt 3\nclass [Ff]ile[Nn]ame\\. alt 3\nclass [Ff]ile[Ss]tatus\\. alt 3\n" \
+"class [Ff][Mm]ode\\. alt 3\nclass [Ff][Nn]ame\\. alt 3\nclass [Ff][Pp]ath\\. alt 3\nclass [Ff][Tt]ype\\. alt 3\nclass [Ff]ull[Ff][Nn]ame\\. alt 3\n" \
+"class [Gg]et[Ee]nv\\. alt 3\nclass [Hh]eader\\. alt 3\nclass [Hh]ex\\. alt 3\nclass [Hh]ex[Dd]isplay\\. alt 3\nclass [D]hex[Ss]how\\. alt 3\n" \
+"class [Hh]igh[Ll]ight\\. alt 3\nclass [Ii]d[Ll]ine\\. alt 3\nclass [Ii]mp[Mm]acro\\. alt 3\nclass [Ii]mpos\\. alt 3\nclass [Ii]nput[Mm]ode\\. alt 3\n" \
+"class [Ii]nsert[Mm]ode\\. alt 3\nclass [Ll]ast[Kk]ey\\. alt 3\nclass [Ll]ast[Mm]sg\\. alt 3\nclass [Ll]ast[Rr][Cc]\\. alt 3\nclass [Ll]ine\\. alt 3\n" \
+"class [Ll]ine[Ff]lag\\. alt 3\nclass [Ll]in[Ee]nd\\. alt 3\nclass [Ll][Ss]creen\\. alt 3\nclass [Mm]acro\\. alt 3\nclass [Mm]acro[Ee]xt\\. alt 3\n" \
+"class [Mm]acro[Pp]ath\\. alt 3\nclass [Mm]argins\\. alt 3\nclass [Mm]onitor\\. alt 3\nclass [Mm]ouse\\. alt 3\nclass [Mm]sg[Ll]ine\\. alt 3\n" \
+"class [Mm]sg[Mm]ode\\. alt 3\nclass [Nn]b[Ff]ile\\. alt 3\nclass [Nn]b[Ss]cope\\. alt 3\nclass [Nn]ew[Ll]ines\\. alt 3\nclass [Nn]on[Dd]isp\\. alt 3\n" \
+"class [Nn]umber\\. alt 3\nclass [Pp]age[Ww]rap\\. alt 3\nclass [Pp]arser\\. alt 3\nclass [Pp]ending\\. alt 3\n" \
+"class [Pp]oint\\. alt 3\nclass [Pp]opup\\. alt 3\nclass [Pp]osition\\. alt 3\nclass [Pp]refix\\. alt 3\nclass [Pp]rinter\\. alt 3\n" \
+"class [Rr]ead[Oo]nly\\. alt 3\nclass [Rr]eadv\\. alt 3\nclass [Rr]eprofile\\. alt 3\nclass [Rr]eserved\\. alt 3\nclass [Rr][Ee][Xx][Xx]\\. alt 3\n" \
+"class [Rr]exx[Oo]utput\\. alt 3\nclass [Rr]ing\\. alt 3\nclass [Ss]cale\\. alt 3\nclass [Ss]cope\\. alt 3\nclass [Ss]creen\\. alt 3\n" \
+"class [Ss]elect\\. alt 3\nclass [Ss]hadow\\. alt 3\nclass [Ss]how[Kk]ey\\. alt 3\nclass [Ss]ize\\. alt 3\nclass [Ss]tatus[Ll]ine\\. alt 3\n" \
+"class [Ss]tay\\. alt 3\nclass [Ss]ynonym\\. alt 3\nclass [Tt]ab[Kk]ey\\. alt 3\nclass [Tt]ab[Ll]ine\\. alt 3\nclass [Tt]abs\\. alt 3\n" \
+"class [Tt]abs[Ii]n\\. alt 3\nclass [Tt]abs[Oo]ut\\. alt 3\nclass [Tt]arget[Ss]ave\\. alt 3\nclass [Tt]erminal\\. alt 3\nclass [Tt]highlight\\. alt 3\n" \
+"class [Tt]ime[Cc]heck\\. alt 3\nclass [Tt][Oo][Ff]\\. alt 3\nclass [Tt]of[Ee]of\\. alt 3\nclass [Tt]railing\\. alt 3\nclass [Tt]ype[Aa]head\\. alt 3\n" \
+"class [Uu]ndoing\\. alt 3\nclass [Uu]ntaa\\. alt 3\nclass [Vv]er[Ss]hift\\. alt 3\nclass [Vv]erify\\. alt 3\nclass [Ww]idth\\. alt 3\n" \
+"class [Ww]ord[Ww]rap\\. alt 3\nclass [Ww]rap\\. alt 3\nclass [Xx]terminal\\. alt 3\nclass [Zz]zone\\. alt 3\n"
+   },
+   { STRTYP"*C.TLD",
+     STRTYP"C",
+     STRTYP"* C\n:case\nrespect\n" \
+         ":option\npreprocessor #\nfunction ( blank default alt 4\n" \
+         ":number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle backslash\ndouble backslash\n" \
+         ":comment\npaired /* */ nest\nline // any\n"  \
+         ":label\ndelimiter : column 1\n" \
+         ":match\n( )\n{ }\n#ifdef,#if,#ifndef #endif #else,#elif,#elseif\n" \
+         ":keyword\n#define\n#elif\n#else\n#endif\n#error\n#if\n#ifdef\n" \
+         "#ifndef\n#include\n#line\n#pragma\n#undef\n" \
+         "asm\nauto\nbool\nbreak\ncase\ncatch\nchar\nclass\n\nconst\n" \
+         "continue\ndefault\ndefined alt f\ndelete\ndo\ndouble\nelse\n" \
+         "enum\nexcept\nextern\nfar\nfinally\nfloat\nfor\nfriend\n" \
+         "goto\nhuge\nif\ninline\nint\nlong\nnear\nnew\noperator\n" \
+         "private\nprotected\npublic\nregister\nreturn\nshort\nsigned\n" \
+         "sizeof\nstatic\nstruct\nswitch\ntemplate\nthis\nthrow\ntry\n" \
+         "typedef\nunion\nunsigned\nvoid\nvolatile\nwhile\n" \
+":function\nabort\nabs\nacos\nasctime\nasin\nassert\natan\natan2\natexit\n" \
+"atof\natoi\natol\nbsearch\ncalloc\nceil\nclearerr\nclock\ncos\ncosh\n" \
+"ctime\nctype\ndifftime\ndiv\nexit\nexp\nfabs\nfclose\nfeof\nferror\n" \
+"fflush\nfgetc\nfgetpos\nfgets\nfloor\nfmod\nfopen\nfprintf\nfputc\nfputs\n" \
+"fread\nfree\nfreopen\nfrexp\nfscanf\nfseek\nfsetpos\nftell\nfwrite\n" \
+"getc\ngetchar\ngetenv\ngets\ngmtime\nisalnum\nisalpha\nisascii\niscntrl\n" \
+"isdigit\nisgraph\nislower\nisprint\nispunct\nisspace\nisupper\nisxdigit\n" \
+"labs\nldexp\nldiv\nlocaltime\nlog\nlog10\nlongjmp\nmalloc\nmemchr\n" \
+"memcmp\nmemcpy\nmemmove\nmemset\nmktime\nmodf\nperror\npow\nprintf\nputc\n" \
+"putchar\nputs\nqsort\nraise\nrand\nrealloc\nremove\nrewind\nscanf\n"\ 
+"setbuf\nsetjmp\nsetvbuf\nsignal\nsin\nsinh\nsprintf\nsqrt\nsrand\nsscanf\n" \
+"strcat\nstrchr\nstrcmp\nstrcoll\nstrcpy\nstrcspn\nstrerror\nstrftime\n" \
+"strlen\nstrncat\nstrncmp\nstrncpy\nstrpbrk\nstrrchr\nstrspn\nstrstr\n" \
+"strtod\nstrtok\nstrtol\nstrtoul\nstrxfrm\nsystem\ntan\ntanh\ntime\n" \
+"tmpfile\ntmpnam\ntolower\ntoupper\nungetc\nva_arg\nva_end\nva_start\n" \
+"vfprintf\nvprintf\nvsprintf\n"
+         ":postcompare\nclass [-\\/\\+\\=\\*\\<\\>|%&!,] alt x\n"
+   },
+   { STRTYP"*SH.TLD",
+     STRTYP"SH",
+     STRTYP"* SH\n:case\nrespect\n:number\nc\n" \
+":string\nsingle backslash\ndouble backslash\n" \
+":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+":comment\nline # any\n:header\nline #! column 1\n" \
+":keyword\nbreak alt 4\ncase\ncd alt 4\ncontinue alt 4\ndo\ndone\n" \
+"echo alt 4\nelif\nelse\nesac\neval alt 4\nexec alt 4\nexit alt 4\n" \
+"export alt 4\nfi\nfor\nfunction alt r\ngetopts alt 4\nif\nin\nset alt 4\n" \
+"shift alt 4\ntest alt 4\nthen\ntrap alt 4\nunset alt 4\nuntil\nwhile\n\n"
+   },
+   { STRTYP"*PERL.TLD",
+     STRTYP"PERL",
+     STRTYP"* PERL\n:case\nrespect\n" \
+         ":option\npreprocessor #\nfunction ( blank default alt 4\n" \
+         ":number\nc\n:identifier\n[\$] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n" \
+         ":comment\nline # any\n:header\nline #! column 1\n" \
+         ":match\n( )\n{ }\n[ ]\n" \
+":keyword\nBEGIN\nEND\nCORE\n__END__\n__FILE__\n__LINE__\nAUTOLOAD\nDESTROY"\
+"\nabs\naccept\nalarm\nand\natan2\nbind\nbinmode\nbless\ncaller\nchdir\nchmod"\
+"\nchomp\nchop\nchown\nchr\nchroot\nclose\nclosedir\ncmp\nconnect\ncontinue\ncos"\
+"\ncrypt\ndbmclose\ndbmopen\ndefined\ndelete\ndie\ndo\ndump\neach\nelse\nelsif"\
+"\nendgrent\nendhostent\nendnetent\nendprotoent\nendpwent\nendservent\neof"\
+"\neq\neval\nexec\nexists\nexit\nexp\nfcntl\nfileno\nflock\nfor\nforeach\nfork"\
+"\nformat\nformline\nge\ngetc\ngetgrent\ngetgrgid\ngetgrnam\ngethostbyaddr"\
+"\ngethostbyname\ngethostent\ngetlogin\ngetnetbyaddr\ngetnetbyname"\
+"\ngetnetent\ngetpeername\ngetpgrp\ngetppid\ngetpriority\ngetprotobyname"\
+"\ngetprotobynumber\ngetprotoent\ngetpwent\ngetpwnam\ngetpwuid"\
+"\ngetservbyname\ngetservbyport\ngetservent\ngetsockname\ngetsockopt"\
+"\nglob\ngmtime\ngoto\ngrep\ngt\nhex\nif\nindex\nint\nioctl\njoin\nkeys\nkill"\
+"\nlast\nlc\nlcfirst\nle\nlength\nlink\nlisten\nlocal\nlocaltime\nlog\nlstat"\
+"\nlt\nm\nmap\nmkdir\nmsgctl\nmsgget\nmsgrcv\nmsgsnd\nmy\nne\nnext\nno\nnot\noct"\
+"\nopen\nopendir\nor\nord\npack\npackage\npipe\npop\npos\nprint\nprintf\npush\nq"\
+"\nqq\nquotemeta\nqw\nqx\nrand\nread\nreaddir\nreadline\nreadlink\nreadpipe"\
+"\nrecv\nredo\nref\nrename\nrequire\nreset\nreturn\nreverse\nrewinddir\nrindex"\
+"\nrmdir\ns\nscalar\nseek\nseekdir\nselect\nsemctl\nsemget\nsemop\nsend\nsetgrent"\
+"\nsethostent\nsetnetent\nsetpgrp\nsetpriority\nsetprotoent\nsetpwent"\
+"\nsetservent\nsetsockopt\nshift\nshmctl\nshmget\nshmread\nshmwrite\nshutdown"\
+"\nsin\nsleep\nsocket\nsocketpair\nsort\nsplice\nsplit\nsprintf\nsqrt\nsrand"\
+"\nstat\nstudy\nsub\nsubstr\nsymlink\nsyscall\nsysread\nsystem\nsyswrite\ntell"\
+"\ntelldir\ntie\ntime\ntimes\ntr\ntruncate\nuc\nucfirst\numask\nundef\nunless"\
+"\nunlink\nunpack\nunshift\nuntie\nuntil\nuse\nutime\nvalues\nvec\nwait\nwaitpid"\
+"\nwantarray\nwarn\nwhile\nwrite\nx\nxor\ny"
+   },
+   { STRTYP"*JAVA.TLD",
+     STRTYP"JAVA",
+     STRTYP"* JAVA" \
+      ":case\nrespect\n" \
+      ":option\nfunction ( blank default alt 4\n" \
+      ":number\nc\n" \
+      ":identifier\n[a-zA-Z_$] [a-zA-Z0-9_$]\n" \
+      ":string\nsingle backslash\ndouble backslash\n" \
+      ":comment\npaired /* */ nonest\nline // any\n" \
+      ":label\ndelimiter : any\n" \
+      ":match\n( )\n{ }\n" \
+      ":keyword\nabstract\nboolean\nbreak\nbyte\ncase\ncatch\nchar\nclass\n" \
+      "const\ncontinue\ndefault\ndo\ndouble\nelse\nextends\nfinal\nfinally\n" \
+      "float\nfor\ngoto\nif\nimplements\nimport\ninstanceof\nint\ninterface\n" \
+      "long\nnative\nnew\npackage\nprivate\nprotected\npublic\nreturn\nshort\n" \
+      "static\nstrictfp\nsuper\nswitch\nsynchronized\nthis\nthrow\nthrows\n" \
+      "transient\ntry\nvoid\nvolatile\nwhile\n" \
+      ":function\n\n"
+   },
+   { STRTYP"*JSCR.TLD",
+     STRTYP"JSCR",
+     STRTYP"* JSCR" \
+      ":case\nrespect\n" \
+      ":number\nc\n" \
+      ":option\nfunction ( blank default alt 4\n" \
+      ":identifier\n[a-zA-Z_$] [a-zA-Z0-9_]\n" \
+      ":string\nsingle backslash\ndouble backslash\n" \
+      ":comment\npaired /* */ nonest\nline // any\n" \
+      ":label\ndelimiter : firstnonblank\n" \
+      ":match\n( )\n{ }\n[ ]\n" \
+      ":keyword\nabstract\napply\narity\nArray\nboolean\nbreak\nbyte\ncall\n" \
+      "callee\ncaller\ncase\ncatch\nchar\nclass\nclassName\ncompile\nconcat\n" \
+      "const\ncontinue\ndebugger\ndefault\ndelete\ndo\ndouble\nelse\nenum\n" \
+      "exec\nexport\nextends\nfalse alt 2\nfinal\nfinally\nfloat\nfor\nfunction alt 1\n" \
+      "global\ngoto\nif\nignoreCase\nimplements\nimport\nin\nint\ninterface\n" \
+      "Infinity alt 4\njava\nJavaArray\nJavaClass\nJavaObject\nJavaPackage\n" \
+      "index\ninput\nlabel\nlastIndex\nlastMatch\nlastParen\nleftContext\n" \
+      "instanceof\nitalics\nlink\nlong\nmatch\nmultiline\nMath\nNaN alt 4\n" \
+      "native\nnetscape\nnew\nnull\nNumber\nObject\npackage\nPackages\nparse\n" \
+      "pop\nprivate\nprotected\npublic\npush\nRegExp\nreplace\nreturn\nrightContext\n" \
+      "search\nshift\nshort\nsource\nsplice\nslice\nsmall\nstatic\nstrike\n" \
+      "String\nsub\nsuper\nsup\nswitch\nsynchronized\ntest\nthis\nthrow\n" \
+      "throws\ntransient\ntrue alt 2\ntry\ntypeof\nvar alt 3\nundefined alt 4\n" \
+      "unshift\nunwatch\nvoid\nvolatile\nwatch\nwhile\nwith\nform alt 7\n" \
+      "value alt 7\narguments alt 7\nconstructor alt 7\nE alt 7\nlength alt 7\n" \
+      "LN10 alt 7\nLN2 alt 7\nLOG10E alt 7\nLOG2E alt 7\nMAX_VALUE alt 7\n" \
+      "MIN_VALUE alt 7\nNEGATIVE_INFINITY alt 7\nPI alt 7\nPOSITIVE_INFINITY alt 7\n" \
+      "prototype alt 7\nSQRT1_2 alt 7\nSQRT2 alt 7\n" \
+      ":function\nalert\nescape\neval\nisFinite\nisNaN\nnumber\nparsefloat\n" \
+      "parseint\nstring\nunescape\nclick\nchange\nblur\nfocus\nabs\nacos\n" \
+      "asin\natan\natan2\natend\nceil\ncharAt\ncharCodeAt\ncos\nDate\nexp\n" \
+      "floor\nfromCharCode\ngetDate\ngetDay\ngetFullYear\ngetHours\ngetMilliseconds\n" \
+      "getMinutes\ngetMonth\ngetSeconds\ngetTime\ngetTimezoneOffset\ngetUTCDate\n" \
+      "getUTCDay\ngetUTCFullYear\ngetUTCHours\ngetUTCMilliseconds\ngetUTCMinutes\n" \
+      "getUTCMonth\ngetUTCSeconds\ngetYear\nindexOf\nitem\njoin\nlastIndexOf\n" \
+      "log\nmax\nmin\nmovefirst\nmovenext\nparse\nparseFloat\nparseInt\n" \
+      "pow\nrandom\nreverse\nround\nsetDate\nsetFullYear\nsetHours\nsetMilliseconds\n" \
+      "setMinutes\nsetMonth\nsetSeconds\nsetTime\nsetUTCDate\nsetUTCFullYear\n" \
+      "setUTCHours\nsetUTCMilliseconds\nsetUTCMinutes\nsetUTCMonth\nsetUTCSeconds\n" \
+      "setUTCTime\nsetyear\nsin\nsort\nsplit\nsqrt\nsubstr\nsubstring\nsun\n" \
+      "tan\ntoGMTString\ntoLocaleString\ntoLowerCase\ntoSource\ntoString\n" \
+      "toUpperCase\ntoUTCString\nUTC\nvalueOf\n\n"
+   },
+   { STRTYP"*SPEC.TLD",
+     STRTYP"SPEC",
+     STRTYP"* SPEC" \
+            ":case\nignore\n" \
+            ":identifier\n[a-zA-Z_{] [a-zA-Z0-9_{}:]\n" \
+            ":comment\nline dnl any\nline # any\n" \
+            ":header\nline % column 1\n" \
+":keyword\nautoprov: alt 5\nautoreq: alt 5\nautoreqprov: alt 5\n" \
+"buildroot: alt 5\nconflicts: alt 5\nepoch: alt 5\nexcludearch: alt 5\n" \
+"excludeos: alt 5\nexclusivearch: alt 5\nexclusiveos: alt 5\ngroup: alt 5\n" \
+"icon: alt 5\nlicense: alt 5\nname: alt 5\nnopatch: alt 5\nnosource: alt 5\n" \
+"packager: alt 5\npatch: alt 5\nprefix: alt 5\nprovides: alt 5\n" \
+"release: alt 5\nrequires: alt 5\nsource: alt 5\nsummary: alt 5\n" \ 
+"url: alt 5\nvendor: alt 5\nversion: alt 5\n{_tmppath}\n{buildroot}\n" \
+"{group}\n{license}\n{name}\n{packager}\n{prefix}\n{provides}\n{release}\n" \
+"{source}\n{summary}\n{url}\n{vendor}\n{version}\n\n"
+   },
+   { STRTYP"*TLD.TLD",
+     STRTYP"TLD",
+     STRTYP"* TLD\n:case\nignore\n"                                                                                \
+         ":comment\nline * firstnonblank\n"                                                                                        \
+         ":header\nline : column 1\n"
+   },
+   { STRTYP"*HTML.TLD",
+     STRTYP"HTML",
+     STRTYP"* HTML\n" \
+         ":case\nignore\n" \
+         ":identifier\n[a-zA-Z] [a-zA-Z0-9]\n" \
+         ":string\ndouble\n" \
+         ":comment\npaired <!-- --> nonest\n" \
+         ":markup\ntag < >\nreference & ;\n"
+/*
+":keyword\n<a\n<script\n</script\nhref\n<img\nsrc\n<pre\n<p\n</p\n</a\n<br"       \
+"\n<b\n</b\n</pre\n<xmp\n</xmp\n<table\n</table\n<table\n<center\n</center"       \
+"\n<i\n</i\n<h1\n</h1\n<h2\n</h2\n<h3\n</h3\n<h4\n</h4\n<h5\n</h5\n<h6\n</h6"     \
+"\n<td\n</td\n<tr\n</tr\n<li\n</li\n<menu\n</menu\n<u\n</u\n<font\n</font\n<hr"   \
+"\n<title\n</title\n<html\n</html\n<head\n</head\n<meta\nwidth\nheight\n<body"    \
+"\n</body\nalign\nvalign\n<applet\n<param\nname\nvalue\narchive\ncode\ncodebase"  \
+"\n</applet\nalt\nismap\nborder\nface\nsize\ntarget\ncellspacing\nhspace\nvspace" \
+"\ncellpadding\nbgcolor\ncolor\nnowrap\ncenter\nbottom\nleft\nright\ncolspan"     \
+"\n<form\n</form\nmethode\npost\naction\n<input\ntype\ntop\n_top\n<tt\n</tt"      \
+"\ncontent\n<map\n</map\n<area\nshape\ncoords\nnohref\nonclick\nonmouseover"      \
+"\nrowspan\n<blockquote\n</blockquote\n<em\n</em\ntext\nlink\nvlink\n<ul\n</ul"   \
+"\n<ol\n</ol\nmethod\nenctype\nmaxlength\n<textarea\nrows\ncols\n</textarea"      \
+"\n<dl\n</dl\n<dt\n<option\n<select\n</select\nselected\nonUnLoad\n<sup\n</sup"   \
+"\nbackground\nscrolling\nnoresize\nframeborder\nonload\nalink\nlanguage"         \
+"\n<div\n</div\n<frameset\n</frameset\n<noframes\n</noframes\n<frame\n</frame"    \
+"\n<strong\n</strong\n<dd\n<base\n<cite\n</cite\n<code\n</code\n</option\n<nobr"  \
+"\nhttp-equiv\n<sub\n</sub\n<th\n</th\n<blink\n</blink\n<noscript\n</noscript"    \
+"\nstyle\nclear\n<link\n<style\n</style\n<col\n<colgroup\n</colgroup"             \
+"\n<tbody\n</tbody\n<thead\n</thead\n<tfoot\n</tfoot\nrel\nrev"
+*/
+   },
+   { STRTYP"*DIR.TLD",
+     STRTYP"DIR",
+     STRTYP"* DIR\n" \
+         ":case\nignore\n" \
+         ":directory\n" \
+         "directory alt a\n" \
+         "executable\n" \
+         "link\n" \
+         "extensions .bak alt 8\n" \
+         "extensions .the alt 1\n" \
+         "extensions .c .cc .cpp .h .hpp alt 2\n" \
+         "extensions .rex .rexx .cmd alt 3\n" \
+         "extensions .exe .dll alt 6\n" \
+         "extensions .zip .Z .gz .tgz alt w\n" \
+         "extensions Makefile .mak alt 4\n"
+         ":column\nexclude 1 38\n" \
+         ":postcompare\ntext -> alt 1\n" \
+         "class .*\\.bak$ alt 8\n" \
+         "class .*Makefile alt 4\n" \
+         "class .*makefile.*$ alt 4\n" \
+         "class .*\\.mak$ alt 4\n" \
+         "class .*\\.[eE][xX][eE]$ alt 6\n" \
+         "class .*\\.dll$ alt 6\n" \
+         "class .*\\.[cC][oO][mM]$ alt 6\n" \
+         "class .*\\.[bB][aA][tT]$ alt 6\n" \
+         "class .*\\.[cC]$ alt 2\n" \
+         "class .*\\.[cC][cC]$ alt 2\n" \
+         "class .*\\.[cC][pP][pP]$ alt 2\n" \
+         "class .*\\.[hH]$ alt 2\n" \
+         "class .*\\.[hH][pP][pP]$ alt 2\n" \
+         "class .*\\.[pP][aA][sS]$ alt 2\n" \
+         "class .*\\.[aA][sS][mM]$ alt 2\n" \
+         "class .*\\.[tT][hH][eE]$ alt 1\n" \
+         "class .*\\.rexx$ alt 3\n" \
+         "class .*\\.rex$ alt 3\n" \
+         "class .*\\.cmd$ alt 3\n" \
+         "class .*\\.[bB][aA][kK]$ alt 8\n" \
+         "class .*\\.[zZ][iI][pP]$ alt 5\n" \
+         "class .*\\.Z$ alt 5\n"   \
+         "class .*\\.gz$ alt 5\n"  \
+         "class .*\\.tgz$ alt 5\n"
+   },
+   { STRTYP"*ASM.TLD",
+     STRTYP"ASM",
+     STRTYP"* ASM\n:case\nignore\n" \
+         ":option\npreprocessor #\nfunction ( noblank\n" \
+         ":number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n:comment\nline ; any\n" \
+         ":label\n* column 1\n:header\nline ; firstnonblank\n" \
+         ":keyword\naaa\naad\naam\naas\nadc\nadd\nah\nal\nalign\nalpha\n" \
+         "and\narpl\nassume\nax\nbh\nbl\nbound\nbp\nbsf\nbsr\nbswap\nbt\n" \
+         "btc\nbtr\nbts\nbx\nbyte\ncall\ncbw\ncdq\nch\ncl\nclc\ncld\ncli\n" \
+         "clts\ncmc\ncmp\ncmps\ncmpsb\ncmpsd\ncmpsw\ncmpxchg\ncode\ncomm\n" \
+         "con\nconst\ncr0\ncr2\ncr3\ncref\ncs\ncwd\ncwde\ncx\ndaa\ndas\n" \
+         "data\ndb\ndd\ndec\ndf\ndh\ndi\ndiv\ndl\ndosseg\ndq\ndr0\ndr1\ndr2\n" \
+         "dr3\ndr6\ndr7\nds\ndt\ndup\ndw\ndword\ndx\neax\nebp\nebx\necx\n" \
+         "edi\nedx\neip\nelse\nend\nendif\nendm\nendp\nends\nenter\neq\nequ\n" \
+         "err\nerr1\nerr2\nerrb\nerrdef\nerrdif\nerrdifi\nerre\nerridn\n" \
+         "erridni\nerrnb\nerrndef\nerrnz\nes\nesc\nesi\nesp\neven\nexitm\n" \
+         "extrn\nf2xm1\nfabs\nfadd\nfaddp\nfar\nfardata\nfbld\nfbstp\nfchs\n" \
+         "fcom\nfcomp\nfcompp\nfcos\nfdiv\nfdivp\nfdivr\nfdivrp\nfiadd\nfidiv\n" \
+         "fild\nfimul\nfinit\nfist\nfistp\nfisub\nfld\nfld1\nfldcw\nfldl2e\n"\
+         "fldl2t\nfldpi\nfldz\nfmul\nfmulp\nfmulr\nfmulrp\nfninit\nfnsave\n" \
+         "fnstsw\nfprem\nfpatan\nfptan\nfrndint\nfs\nfscale\nfsin\nfsincos\n"\
+         "fsqrt\nfst\nfstcw\nfstp\nfstsw\nfsub\nfsubp\nfsubrp\nftst\nfwait\n" \
+         "fword\nfxam\nfxch\nfyl2x\nge\ngroup\ngs\ngt\nhigh\n" \
+         "hlt\nidiv\nif\nif1\nif2\nifb\nifdef\nifdif\nifdifi\nife\nifidn\n" \
+         "ifidni\nifnb\nifndef\nimul\nin\ninc\ninclude\nincludelib\nins\n" \
+         "insb\ninsd\ninsw\nint\ninto\ninvd\ninvlpg\nip\niret\niretd\nirpc\n" \
+         "ja\njae\njb\njbe\njc\njcxz\nje\njecxz\njg\njge\njl\njle\njmp\njna\n" \
+         "jnae\njnb\njnbe\njnc\njne\njng\njnge\njnl\njnle\njno\njnp\njns\n" \
+         "jnz\njo\njp\njpe\njpo\njs\njz\nlabel\nlahf\nlall\nlar\nlds\nle\n" \
+         "lea\nleave\nlength\nles\nlfcond\nlfs\nlgdt\nlgs\nlidt\nline\nlist\n" \
+         "lldt\nlmsw\nlocal\nlock\nlods\nlodsb\nlodsd\nlodsw\nloop\nloope\n" \
+         "loopne\nloopnz\nloopz\nlow\nlsl\nlss\nlt\nltr\nmacro\nmask\nmod\n" \
+         "model\nmov\nmovs\nmovsb\nmovsd\nmovsw\nmovsx\nmovzx\nmul\nname\n" \
+         "ne\nnear\nneg\nnop\nnot\nnothing\noffset\nor\norg\nout\nouts\n" \
+         "outsb\noutsd\noutsw\npage\npop\npopa\npopad\npopf\nproc\nptr\n" \
+         "public\npurge\npush\npusha\npushad\npushf\nqword\nradix\nrcl\n" \
+         "rcr\nrecord\nrep\nrepe\nrepne\nrepnz\nrept\nrepz\nret\nretf\n" \
+         "retn\nrol\nror\nsahf\nsal\nsar\nsbb\nscas\nscasb\nscasd\nscasw\n" \
+         "seg\nsegcs\nsegds\nseges\nsegfs\nseggs\nsegment\nsegss\nseq\n" \
+         "setae\nsetb\nsetbe\nsetc\nsete\nsetg\nsetge\nsetl\nsetle\nsetna\n" \
+         "setnae\nsetnb\nsetnc\nsetne\nsetng\nsetnge\nsetnl\nsetnle\nsetno\n" \
+         "setnp\nsetns\nsetnz\nseto\nsetp\nsetpe\nsetpo\nsets\nsetz\nsfcond\n" \
+         "sgdt\nshl\nshld\nshort\nshr\nshrd\nsi\nsidt\nsize\nsldt\nsmsw\n" \
+         "sp\nss\nstack\nstc\nstd\nsti\nstos\nstosb\nstosd\nstosw\nstr\n" \
+         "struc\nsub\nsubttl\ntbyte\ntest\ntfcond\nthis\ntitle\ntr4\ntr5\n" \
+         "tr6\ntr7\ntype\nverr\nverw\nwait\nwbinvd\nwidth\nword\nxall\n" \
+         "xchg\nxcref\nxlat\nxlatb\nxlist\nxor\n"
+   },
+   { STRTYP"*BAT.TLD",
+     STRTYP"BAT",
+     STRTYP"* BAT\n:case\nignore\n" \
+         ":option\npreprocessor @\npreprocessor %\n" \
+         ":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n\n:comment\nline rem firstnonblank\n" \
+         ":header\nline : column 1\n"
+         ":keyword\nbreak\ncall\ncd\nchcp\nchdir\ncls\ncopy\ndate\ndel\n" \
+         "delete\ndir\necho\nerase\nexit\nfor\ngoto\nif\nlh\nloadhigh\nmd\n" \
+         "mkdir\npath\npause\nprompt\nrd\nren\nrename\nrmdir\nset\nshift\n" \
+         "time\ntype\nver\nverify\nvol"
+   },
+   { STRTYP"*PASCAL.TLD",
+     STRTYP"PASCAL",
+     STRTYP"* PAS\n:case\nignore\n" \
+         ":option\npreprocessor #\nfunction ( blank\n" \
+         ":number\nC\n:string\nsingle\n" \
+         ":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":comment\npaired (* *) nonest\npaired { } nonest\nline // any\n" \
+         ":header\nline program firstnonblank\nline unit firstnonblank\n" \
+         "line interface firstnonblank\nline implementation firstnonblank\n" \
+         "line procedure firstnonblank\nline function firstnonblank\n" \
+         ":label\n* Borland!\ndelimiter @ firstnonblank\n" \
+         ":match\n(. .)\n( )\n[ ]\n" \
+         ":keyword\nand\narray\nbegin\ncase\nconst\ndiv\ndo\ndownto\n" \
+         "else\nend\nfile\nfor\nfunction\ngoto\nif\nin\nlabel\nmod\n" \
+         "nil\nnot\nof\nor\npacked\nprocedure\nprogram\nrecord\nrepeat\n" \
+         "set\nthen\nto\ntype\nuntil\nvar\nwhile\nwith\n" \
+         "boolean\nbyte\nchar\nextended\ninteger\nlongint\npointer\nreal\n" \
+         "shortint\nstring\nword\ntrue\nfalse\nasm\nbreak\nconstructor\n" \
+         "continue\ndestructor\nexit\nexports\nhalt\nimplementation\n" \
+         "inherited\ninline\ninterface\nlibrary\nobject\nprivate\npublic\n" \
+         "shl\nshr\nunit\nuses\nxor\n" \
+         "absolute\nabstract\nassembler\nexternal\nforward\ninterrupt\n" \
+         "read\nreadln\nvirtual\nwrite\nwriteln\n" \
+         ":function\nabs\naddr\nappend\narctan\nassign\nassigned\nchr\n" \
+         "close\nconcat\ncopy\ncos\ndec\ndelete\ndispose\ndouble\neof\neoln\n" \
+         "exp\nfillchar\nflush\nfrac\nfreemem\ngetmem\nhi\ninc\ninsert\nint\n" \
+         "ioresult\nlength\nln\nlo\nmark\nmaxavail\nmaxint\nmaxlongint\nmem\n" \
+         "memavail\nmemw\nmove\nnew\nodd\nofs\nord\nparamcount\nparamstr\n" \
+         "pchar\npi\nport\nportw\npos\npred\nptr\nrandom\nrandomize\nrelease\n" \
+         "reset\nrewrite\nround\nseek\nsettextbuf\nsin\nsizeof\nsqr\nsqrt\n" \
+         "str\nsucc\nswap\ntext\ntrunc\ntypeof\nupcase\nval\n"
+   },
+   { STRTYP"*FOX.TLD",
+     STRTYP"FOX",
+     STRTYP"* FOX\n:case\nignore\n" \
+         ":option\npreprocessor #\nfunction ( blank\n" \
+         ":number\nc\n:identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":string\nsingle\ndouble\n" \
+         ":comment\nline * firstnonblank\nline && any\n" \
+/*         "line note firstnonblank\nline NOTE firstnonblank\npaired text endtext\n" \*/
+         "line note firstnonblank\nline NOTE firstnonblank\n" \
+         ":label\n* delimiter : column 1\n" \
+         ":header\nline # firstnonblank\nline proc firstnonblank\n" \
+         "line func firstnonblank\nline PROC firstnonblank\nline FUNC firstnonblank\n" \
+         ":keyword\nacce\naccept\nacti\nactiv\nactiva\nactivat\nactivate\n" \
+         "appe\nappen\nappend\nassist\naverage\nblank\nbox\nbrow\nbrows\n" \
+         "browse\ncalculate\ncall\ncancel\ncase\nchange\nclea\nclear\nclos\n" \
+         "close\ncont\nconti\ncontin\ncontinu\ncontinue\ncopy\ncoun\ncount\n" \
+         "crea\ncreat\ncreate\ndeac\ndeact\ndeacti\ndeactiv\ndeactiva\n" \
+         "deactivat\ndeactivate\ndecl\ndecla\ndeclar\ndeclare\ndefi\ndefin\n" \
+         "define\ndele\ndelet\ndelete\ndime\ndimen\ndimens\ndimensi\ndimensio\n" \
+         "dimension\ndir\ndirectory\ndisp\ndisplay\ndo\nedit\neject\nelse\n" \
+         "endc\nendca\nendcas\nendcase\nendd\nenddo\nendfor\nendi\nendif\n" \
+         "endprintjob\nendscan\nendtext\neras\nerase\nexit\nexport\nexternal\n" \
+         "fill\nfind\nflush\nfor\nfunction\ngath\ngathe\ngather\nget\n" \
+         "getexpr\ngo\ngoto\nhelp\nhide\nif\nimport\ninde\nindex\n" \
+         "inpu\ninput\ninse\ninser\ninsert\njoin\nkeyb\nkeyboard\nlabel\n" \
+         "list\nload\nloca\nlocat\nlocate\nmenu\nmodi\nmodif\nmodify\n" \
+         "move\nnext\nnote\non\nother\notherwise\npack\npara\nparam\n" \
+         "parameter\nparameters\nplay\npop\nprintjob\npriv\npriva\nprivat\n" \
+         "private\nprocedure\nprom\npromp\nprompt\npubl\npubli\npublic\n" \
+         "push\nquit\nread\nreca\nrecal\nrecall\nrein\nreind\nreinde\nreindex\n" \
+         "rele\nrelea\nreleas\nrelease\nrename\nrepl\nrepla\nreplac\nreplace\n" \
+         "repo\nrepor\nreport\nrest\nresto\nrestor\nrestore\nresume\n" \
+         "retr\nretry\nretu\nretur\nreturn\nrun\nsave\nsay\nscan\n" \
+         "scat\nscatt\nscatte\nscatter\nscroll\nseek\nsele\nselec\nselect\n" \
+         "set\nshow\nsize\nskip\nsort\nstor\nstore\nsum\nsusp\nsuspend\n" \
+         "text\nto\ntotal\ntype\nunlock\nupdate\nuse\nwait\nwhil\nwhile\n" \
+         "zap\nzoom\n:function\nabs\nacopy\nacos\nadel\nadir\naelement\n" \
+         "afields\nains\nalen\nalias\nallt\nalltr\nalltri\nalltrim\nasc\n" \
+         "ascan\nasin\nasort\nasub\nasubscript\nat\natan\natc\natcline\n" \
+         "atline\natn2\nbar\nbarcount\nbarprompt\nbetween\nbof\ncaps\n" \
+         "capslock\ncdow\ncdx\nceil\nceiling\nchr\nchrsaw\nchrtran\ncmonth\n" \
+         "cntbar\ncntpad\ncol\ncos\nctod\ncurdir\ndate\nday\ndbf\ndele\n" \
+         "deleted\ndescending\ndifference\ndiskspace\ndmy\ndow\ndtoc\ndtor\n" \
+         "dtos\nempty\neof\nerror\nevaluate\nexp\nfchsize\nfclose\nfcount\n" \
+         "fcreate\nfdate\nfeof\nferror\nfflush\nfgets\nfield\nfile\nfilter\n" \
+         "fklabel\nfkmax\nfldlist\nflock\nfloor\nfopen\nfor\nfound\nfputs\n" \
+         "fread\nfseek\nfsize\nftime\nfullpath\nfv\nfwrite\ngetbar\ngetdir\n" \
+         "getenv\ngetfile\ngetpad\ngomonth\nheader\nhome\niif\ninkey\ninlist\n" \
+         "insmode\nint\nisal\nisalpha\nisbl\nisblank\niscolo\niscolor\nisdig\n" \
+         "isdigit\nislow\nislower\nisread\nisreadonly\nisuppe\nisupper\nkey\n" \
+         "keymatch\nlastkey\nleft\nlen\nlike\nlineno\nlocfile\nlock\nlog\n" \
+         "log10\nlookup\nlowe\nlower\nltri\nltrim\nlupdate\nmax\nmcol\nmdown\n" \
+         "mdx\nmdy\nmemlin\nmemline\nmemlines\nmemory\nmenu\nmessage\nmin\n" \
+         "mlin\nmline\nmod\nmonth\nmrkbar\nmrkpad\nmrow\nmwindow\nndx\n" \
+         "normalize\nnumlock\nobjnum\nobjvar\noccurs\non\norder\nos\npad\n" \
+         "padc\npadl\npadr\npara\nparam\nparameter\nparameters\npayment\n" \
+         "pcol\npi\npopup\nprint\nprintstat\nprintstatus\nprmbar\nprmpad\n" \
+         "prog\nprogram\nprompt\nprop\nproper\nprow\nprtinfo\nputfile\npv\n" \
+         "rand\nrat\nratl\nratli\nratlin\nratline\nrdlevel\nreadkey\n" \
+         "reccou\nreccount\nrecno\nrecsiz\nrecsize\nrela\nrelation\n" \
+         "repl\nrepli\nreplicate\nright\nrlock\nround\nrow\nrtod\nrtrim\n" \
+         "scheme\nscols\nsecond\nseconds\nseek\nselect\nset\nsign\nsin\n" \
+         "skpbar\nskppad\nsoundex\nspac\nspace\nsqrt\nsrows\nstr\nstrtran\n" \
+         "stuff\nsubs\nsubst\nsubstr\nsys\ntag\ntagcount\ntagno\ntan\n" \
+         "target\ntime\ntran\ntrans\ntransform\ntrim\ntxtwidth\ntype\n" \
+         "unique\nupdated\nuppe\nupper\nused\nval\nvarread\nversion\n" \
+         "wborder\nwchild\nwcols\nwexist\nwlast\nwlcol\nwlrow\nwmax\n" \
+         "wmaximum\nwmin\nwminimum\nwontop\nwoutput\nwparent\nwread\n" \
+         "wrows\nwtitle\nwvisible\nyear\n:match\n( )\n"
+   },
+   { STRTYP"*MAK.TLD",
+     STRTYP"MAK",
+     STRTYP"* MAK\n:case\nrespect\n" \
+         ":string\nsingle backslash\ndouble backslash\n" \
+         ":identifier\n[a-zA-Z_] [a-zA-Z0-9_]\n" \
+         ":comment\nline # any\n" \
+/*         ":label\ndelimiter : firstnonblank\n" \*/
+         ":postcompare\nclass \$([a-zA-Z0-9_\*@]*) alt w\n"
+         "class ^[a-zA-Z0-9_.]*: alt 1\n" \
+         "class ^[a-zA-Z0-9_]*= alt 2\n" \
+":keyword\n.DEFAULT\n.DELETE_ON_ERROR\n.EXPORT_ALL_VARIABLES\n.IGNORE" \
+"\n.INTERMEDIATE\n.PHONY\n.POSIX\n.PRECIOUS\n.SECONDARY\n.SILENT\n.SUFFIXES" \
+"\nAR\nARFLAGS\nAS\nASFLAGS\nCC\nCFLAGS\nCO\nCOFLAGS\nCOMSPEC\nCPP\nCPPFLAGS" \
+"\nCTANGLE\nCWEAVE\nCXX\nCXXFLAGS\nFC\nFFLAGS\nGET\nGFLAGS\nGPATH\nLDFLAGS" \
+"\nLEX\nLFLAGS\nMAKE\nMAKECMDGOALS\nMAKEFILES\nMAKEFLAGS\nMAKEINFO\nMAKELEVEL" \
+"\nMAKEOVERRIDES\nMFLAGS\nOUTPUT_OPTION\nPC\nPFLAGS\nRFLAGS\nRM\nSHELL" \
+"\nSUFFIXES\nTANGLE\nTEX\nTEXI2DVI\nVPATH\nWEAVE\nYACC\nYACCR\nYFLAGS" \
+"\naddprefix\naddsuffix\nbasename\ndefine\ndir\nelse\nendef\nendif\nexport" \
+"\nfilter\nfilter-out\nfindstring\nfirstword\nforeach\nifdef\nifeq\nifndef" \
+"\nifneq\ninclude\njoin\nnotdir\norigin\noverride\npatsubst\nshell\nsort\nstrip"\
+"\nsubst\nsuffix\nunexport\nvpath\nwildcard\nword\nwordlist\nwords"
+   },
+   {
+     NULL, NULL, NULL
+   }
+};
+#else //GYMOD
+
 DEFAULT_PARSERS _THE_FAR default_parsers[] =
 {
    { (CHARTYPE *)"*REXX.TLD",
@@ -198,6 +702,8 @@
    }
 };
 
+#endif //GYMOD
+
 PARSER_MAPPING _THE_FAR default_parser_mapping[] =
 {
 
@@ -215,6 +721,10 @@
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.c"    , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.cc"   , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.cpp"  , NULL  ,0, NULL },
+#ifdef GYMOD
+   { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.cxx"  , NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.tcc"  , NULL  ,0, NULL },
+#endif //GYMOD
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.h"    , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"C",    (CHARTYPE*)"*.hpp"  , NULL  ,0, NULL },
    { NULL,NULL,(CHARTYPE*)"REXX", (CHARTYPE*)"*.cmd"  , NULL  ,0, NULL },
@@ -233,6 +743,26 @@
    { NULL,NULL,(CHARTYPE*)"SH",   NULL    ,(CHARTYPE*)"ksh"   ,3, NULL },
    { NULL,NULL,(CHARTYPE*)"SH",   NULL    ,(CHARTYPE*)"bash"  ,4, NULL },
    { NULL,NULL,(CHARTYPE*)"SH",   NULL    ,(CHARTYPE*)"zsh"   ,3, NULL },
+#ifdef GYMOD
+   { NULL,NULL,(CHARTYPE*)"ASM",  (CHARTYPE*)"*.asm",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"ASM",  (CHARTYPE*)"*.inc",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"ASM",  (CHARTYPE*)"*.s",     NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"BAT",  (CHARTYPE*)"*.bat",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"PASCAL", (CHARTYPE*)"*.pas", NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"FOX",  (CHARTYPE*)"*.prg",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"MAK",  (CHARTYPE*)"*.mak",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"MAK",  (CHARTYPE*)"makefile",NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"MAK",(CHARTYPE*)"makefile.*",NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"HTML", (CHARTYPE*)"*.sht"  , NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"HTML", (CHARTYPE*)"*.shtml", NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"PERL", (CHARTYPE*)"*.pl",    NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"PERL", (CHARTYPE*)"*.pm",    NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JAVA", (CHARTYPE*)"*.j",     NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JAVA", (CHARTYPE*)"*.jav",   NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JAVA", (CHARTYPE*)"*.java",  NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"JSCR", (CHARTYPE*)"*.js",    NULL  ,0, NULL },
+   { NULL,NULL,(CHARTYPE*)"SPEC", (CHARTYPE*)"*.spec",  NULL  ,0, NULL },
+#endif //GYMOD
    { NULL,NULL,NULL,              NULL    , NULL              ,0, NULL }
 };
 
diff -Naurd a/directry.h b/directry.h
--- a/directry.h	2013-07-26 16:09:13.000000000 +0200
+++ b/directry.h	2013-07-26 16:10:02.000000000 +0200
@@ -64,12 +64,27 @@
 # define MONT_MASK (mon[((date & 0x01e0) >> 5)-1])
 # define YEAR_MASK (((date & 0xfe00) >> 9)+1980)
 
+#ifdef GYMOD
+# define HH_MAS(a) ((a & 0xf800) >> 11)
+# define MI_MAS(a) ((a & 0x07e0) >> 5)
+# define SS_MAS(a) ((a & 0x001f) << 1)
+# define DD_MAS(a) (a & 0x001f)
+# define MM_MAS(a) (((a & 0x01e0) >> 5)-1)
+# define YY_MAS(a) (((a & 0xfe00) >> 9)+1980)
+# define HH_MASK(a) ((HH_MAS(a)<0) ? 0 : HH_MAS(a))
+# define MI_MASK(a) ((MI_MAS(a)<0) ? 0 : MI_MAS(a))
+# define SS_MASK(a) ((SS_MAS(a)<0) ? 0 : SS_MAS(a))
+# define DD_MASK(a) ((DD_MAS(a)<0) ? 0 : DD_MAS(a))
+# define MM_MASK(a) ((MM_MAS(a)<0) ? 0 : MM_MAS(a))
+# define YY_MASK(a) ((YY_MAS(a)<0) ? 0 : YY_MAS(a))
+#else //GYMOD
 # define HH_MASK(a) ((a & 0xf800) >> 11)
 # define MI_MASK(a) ((a & 0x07e0) >> 5)
 # define SS_MASK(a) ((a & 0x001f) << 1)
 # define DD_MASK(a) (a & 0x001f)
 # define MM_MASK(a) (((a & 0x01e0) >> 5)-1)
 # define YY_MASK(a) (((a & 0xfe00) >> 9)+1980)
+#endif //GYMOD
 
 #endif
 
diff -Naurd a/execute.c b/execute.c
--- a/execute.c	2013-07-26 16:09:13.000000000 +0200
+++ b/execute.c	2013-07-26 16:10:02.000000000 +0200
@@ -38,6 +38,16 @@
 #include <the.h>
 #include <proto.h>
 
+#ifdef GYMOD
+#define PREV   (QUIT-1)
+#define PREVOK (PREV-1)
+#define HAVE_DERWIN 1
+#if defined(DOS)
+# define ACS_DARROW	(chtype)''
+# define ACS_UARROW	(chtype)''
+#endif
+#endif //GYMOD
+
 /***********************************************************************/
 #ifdef HAVE_PROTO
 static short selective_change(TARGET *target,CHARTYPE *old_str,LENGTHTYPE len_old_str,CHARTYPE *new_str,
@@ -123,12 +133,24 @@
        * string to be changed
        */
       if ( CURRENT_VIEW->thighlight_on )
+#ifdef GYMOD
+         CURRENT_VIEW->thighlight_target.rt[0].found_length = (changed) ? len_new_str : len_old_str;
+#else
          CURRENT_VIEW->thighlight_target.rt[0].length = (changed) ? len_new_str : len_old_str;
+#endif //GYMOD
       display_screen(current_screen);
       if (changed)
+#ifdef GYMOD
+         display_prompt((CHARTYPE *)"Press 'N' for next, 'C' to undo, 'P' to prev, 'Q' to quit");
+#else
          display_prompt((CHARTYPE *)"Press 'N' for next,'C' to undo 'Q' to quit");
+#endif //GYMOD
       else
+#ifdef GYMOD
+         display_prompt((CHARTYPE *)"Press 'N' for next, 'C' to change, 'P' to prev, 'Q' to quit");
+#else
          display_prompt((CHARTYPE *)"Press 'N' for next,'C' to change 'Q' to quit");
+#endif //GYMOD
       wmove(CURRENT_WINDOW_FILEAREA,y,x);
       wrefresh(CURRENT_WINDOW_FILEAREA);
 
@@ -136,6 +158,15 @@
       clear_msgline(-1);
       switch(key)
       {
+#ifdef GYMOD
+         case 'P':
+         case 'p':
+            if (changed)
+               rc = PREVOK;
+            else
+               rc = PREV;
+            break;
+#endif //GYMOD
          case 'N':
          case 'n':
             if (changed)
@@ -214,6 +245,11 @@
    CHARTYPE *params;
    short save_target_type=TARGET_RELATIVE;
    LENGTHTYPE str_length=0;
+#ifdef GYMOD
+   bool previous=FALSE;
+   bool reverse =FALSE;
+   short loc2=0;
+#endif //GYMOD
 
    TRACE_FUNCTION("execute.c: execute_change_command");
    /*
@@ -368,6 +404,13 @@
    curr = lll_find( CURRENT_FILE->first_line, CURRENT_FILE->last_line, true_line, CURRENT_FILE->number_lines );
    for ( i = 0L, num_actual_lines = 0L; ; i++ )
    {
+#ifdef GYMOD
+      if (previous)
+      {
+        num_actual_lines -= 2;
+        i -=2;
+      }
+#endif //GYMOD
       if ( lines_based_on_scope )
       {
          if ( num_actual_lines == abs_num_lines )
@@ -445,6 +488,24 @@
                                  CURRENT_VIEW->arbchar_single,
                                  CURRENT_VIEW->arbchar_multiple,
                                  &str_length );
+#ifdef GYMOD
+                  reverse = FALSE;
+                  if (previous)
+                  {
+                    loc2= memfind(rec+real_start,new_str,(real_end-real_start+1),
+                                len_new_str,
+                                (CURRENT_VIEW->case_change == CASE_IGNORE) ? TRUE : FALSE,
+                                CURRENT_VIEW->arbchar_status,
+                                CURRENT_VIEW->arbchar_single,
+                                CURRENT_VIEW->arbchar_multiple,
+                                &str_length);
+                    if (loc2 > loc)
+                    {
+                      loc = loc2;
+                      reverse = TRUE;
+                    }
+                  }
+#endif //GYMOD
                }
                if ( loc != (-1) )
                {
@@ -470,11 +531,30 @@
                      else
                      {
                        /* selective */
+#ifdef GYMOD
+                        if (previous)
+                        {
+                          direction = (direction==DIRECTION_FORWARD) ? DIRECTION_BACKWARD : DIRECTION_FORWARD;
+                          previous = FALSE;
+                        }
+                        if (reverse)
+                          selective_rc = selective_change(&target,new_str,len_new_str,old_str,len_old_str,
+                                                        true_line,last_true_line,start_col);
+                        else
+#endif //GYMOD
                         selective_rc = selective_change( &target, old_str, len_old_str, new_str, len_new_str,
                                                          true_line, last_true_line, start_col );
                         last_true_line = true_line;
                         switch( selective_rc )
                         {
+#ifdef GYMOD
+                           case PREVOK:
+                              if (!previous)
+                              {
+                                direction = (direction==DIRECTION_FORWARD) ? DIRECTION_BACKWARD : DIRECTION_FORWARD;
+                                previous = TRUE;
+                              }
+#endif //GYMOD
                            case QUITOK:
                            case RC_OK:
                               start_col += len_new_str;
@@ -486,6 +566,14 @@
                                  loc = (-1);
                               }
                               break;
+#ifdef GYMOD
+                           case PREV:
+                              if (!previous)
+                              {
+                                direction = (direction==DIRECTION_FORWARD) ? DIRECTION_BACKWARD : DIRECTION_FORWARD;
+                                previous = TRUE;
+                              }
+#endif //GYMOD
                            case SKIP:
                               start_col += len_old_str;
                               break;
@@ -1158,6 +1246,13 @@
 }
 
 /***********************************************************************/
+#ifdef GYMOD
+ extern bool HuSortCase;
+ char chr_lo[] = " áéĄí˘óöőŁúüű";
+ char chr_hi[] = "ÁÉÍîÓÖ§ŐÚÜŰ";
+ char chr_utflo[] = "ĄŠ­łśşźą";
+ char chr_utfhi[] = "°";
+#endif //GYMOD
 #ifdef HAVE_PROTO
 static bool change_case(CHARTYPE *str,LENGTHTYPE start,LENGTHTYPE end,CHARTYPE which_case)
 #else
@@ -1172,6 +1267,9 @@
  */
 {
    LENGTHTYPE i;
+#ifdef GYMOD
+   register int j,k;
+#endif //GYMOD
    bool altered=FALSE;
 
    TRACE_FUNCTION("execute.c: change_case");
@@ -1185,6 +1283,35 @@
                *(str+i) = toupper(*(str+i));
                altered = TRUE;
             }
+#ifdef GYMOD
+            else
+              if (HuSortCase)
+              {
+                if (str[i] == 195 || str[i] == 197)
+                {
+                  i++;
+                  j = (int) &chr_utflo;
+                  k = (int) strstr(chr_utflo, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_utfhi[k];
+                    altered = TRUE;
+                  }
+                }
+                else
+                {
+                  j = (int) &chr_lo;
+                  k = (int) strstr(chr_lo, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_hi[k];
+                    altered = TRUE;
+                  }
+                }
+              }
+#endif //GYMOD
             break;
          case CASE_LOWER:
             if (isupper(*(str+i)))
@@ -1192,6 +1319,35 @@
                *(str+i) = tolower(*(str+i));
                altered = TRUE;
             }
+#ifdef GYMOD
+            else
+              if (HuSortCase)
+              {
+                if (str[i] == 195 || str[i] == 197)
+                {
+                  i++;
+                  j = (int) &chr_utfhi;
+                  k = (int) strstr(chr_utfhi, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_utflo[k];
+                    altered = TRUE;
+                  }
+                }
+                else
+                {
+                  j = (int) &chr_hi;
+                  k = (int) strstr(chr_hi, *(str+i));
+                  if (k>0)
+                  {
+                    k -= j;
+                    *(str+i) = (char) chr_lo[k];
+                    altered = TRUE;
+                  }
+                }
+              }
+#endif //GYMOD
             break;
       }
    }
@@ -2344,6 +2500,14 @@
    }
    else
    {
+#if defined(GYMOD) && defined(DOS)
+      WinClip = FALSE;
+      if (equal((CHARTYPE *)"wclip:",MyStrip(target.rt[target.spare].string,STRIP_BOTH,' '),6))
+      {
+        strcpy(target.rt[target.spare].string,"clip:");
+        WinClip = TRUE;
+      }
+#endif //GYMOD
       if ( equal( (CHARTYPE *)"clip:", MyStrip( target.rt[target.spare].string, STRIP_BOTH, ' ' ), 5 ) )
       {
          clip = TRUE;
@@ -2475,6 +2639,11 @@
    bool allow_interactive=FALSE;
    CHARTYPE *tmpfilename=NULL;
    CHARTYPE *tmpargs=NULL;
+#if defined(GYMOD) && defined(DOS)
+#define BUFFER_LEN  BUFSIZ
+   FILE *InFile, *OutFile;      // file declaration
+   CHARTYPE *rbuffer = NULL;    // Read Buffer
+#endif //GYMOD
 
    TRACE_FUNCTION("execute.c: execute_macro");
    /*
@@ -2528,6 +2697,36 @@
       TRACE_RETURN();
       return(RC_OUT_OF_MEMORY);
    }
+#if defined(GYMOD) && defined(DOS)
+   if (allow_interactive)
+   {
+     strcpy(macroname, "$tracef$.the");
+     if ( (OutFile = fopen( macroname, "wt")) != NULL )  // create file
+     {
+       if ( (InFile = fopen( tmpfilename, "rt")) != NULL )   // open file
+       {
+         if ((rbuffer = (CHARTYPE *)(*the_malloc)((BUFFER_LEN+1)*sizeof(CHARTYPE))) != NULL)
+         {
+           fputs( "Trace ?All\n", OutFile );
+           while( fgets( rbuffer, BUFFER_LEN, InFile ) != NULL )
+           {
+             if (strnicmp(rbuffer, "trace o", 7) == 0)
+             {
+               rbuffer[6] = 'a';
+             }
+             fputs( rbuffer, OutFile );
+           }
+           fclose( InFile );
+           fflush( OutFile );
+           (*the_free)(rbuffer);
+         }
+       }
+       fclose( OutFile );
+     }
+     strcpy(tmpfilename, macroname);
+   }
+#endif //GYMOD
+
    /*
     * Find the fully qualified file name for the supplied macro name.
     */
@@ -2562,6 +2761,12 @@
          TRACE_RETURN();
          return(rc);
    }
+#if defined(GYMOD) && defined(DOS)
+   if (allow_interactive)
+   {
+     remove("$tracef$.the");
+   }
+#endif //GYMOD
    /*
     * Set in_macro = TRUE to stop multiple show_page()s being performed.
     */
@@ -4072,6 +4277,9 @@
    return(rc);
 }
 
+#ifdef GYMOD
+bool dialogw=FALSE;
+#endif //GYMOD
 /***********************************************************************/
 #ifdef HAVE_PROTO
 short execute_dialog(CHARTYPE *prompt, CHARTYPE *title, CHARTYPE *initial, bool editfield,short button, short default_button,CHARTYPE *stemname, short icon, bool alert)
@@ -4359,7 +4567,13 @@
           * an exit key is pressed. On exit make the first button active.
           */
          draw_cursor(TRUE);
+#ifdef GYMOD
+         dialogw = TRUE;
+#endif //GYMOD
          rc = readv_cmdline( editfield_buf, dialog_win, editfield_col );
+#ifdef GYMOD
+         dialogw = FALSE;
+#endif //GYMOD
          memcpy( (DEFCHAR *)editfield_buf, (DEFCHAR *)cmd_rec, cmd_rec_len );
          editfield_buf[cmd_rec_len] = '\0';
          in_editfield = FALSE;
@@ -5188,6 +5402,12 @@
    int x_overlap,y_overlap;
    int offset_lines=0,scroll_lines;
    int escape_key_index = 0;
+#ifdef GYMOD
+   #define KBCMAX 20
+   int l, k=0;
+   char kbuf[KBCMAX+1] = {0};
+   char ukey;
+#endif //GYMOD
 
    TRACE_FUNCTION("execute.c: execute_popup");
 
@@ -5270,8 +5490,38 @@
 #if defined(HAVE_BOX)
       wattrset(dialog_win,set_colour(CURRENT_FILE->attr+ATTR_POP_BORDER));
       box(dialog_win,0,0);
+#ifdef GYMOD
+      if (k>0)
+      {
+        for (l=0; l<k; l++)
+        {
+          wmove(dialog_win,height-1,l+2);
+          waddch(dialog_win,kbuf[l]);
+        }
+      }
+#endif //GYMOD
       if ( height != pad_height )
       {
+#ifdef GYMOD
+         if (y_offset!=0)
+         {
+           wmove(dialog_win,1,width-1);
+#ifdef ACS_UARROW
+           waddch(dialog_win, A_ALTCHARSET|ACS_UARROW );
+#else
+           waddch(dialog_win,'^');
+#endif
+         }
+         if (y_offset<(num_args-height+2))
+         {
+           wmove(dialog_win,height-2,width-1);
+#ifdef ACS_DARROW
+           waddch(dialog_win, A_ALTCHARSET|ACS_DARROW );
+#else
+           waddch(dialog_win,'v');
+#endif
+         }
+#else //GYMOD
          wmove(dialog_win,0,width-1);
          waddch(dialog_win,' ');
          wmove(dialog_win,1,width-1);
@@ -5286,6 +5536,7 @@
 # else
          waddch(dialog_win,'v');
 # endif
+#endif //GYMOD
       }
       if ( width != pad_width )
       {
@@ -5358,6 +5609,10 @@
          continue;
 #endif
 #if defined(PDCURSES_MOUSE_ENABLED) || defined(NCURSES_MOUSE_VERSION)
+#ifdef GYMOD
+      if ((key=='q') && (popup_escape_key != -1))
+        key = 'Q';
+#endif //GYMOD
       if (key == KEY_MOUSE)
       {
          int b,ba,bm,y,x;
@@ -5378,12 +5633,114 @@
              */
             break;
          }
+#ifdef GYMOD
+         if (y == 0)
+         {
+           if (highlighted_line>0)
+           {
+             if ( y_overlap )
+             {
+               highlighted_line -=(height-3);
+               if (highlighted_line<0)
+               {
+                 y_offset = 0;
+                 highlighted_line = 0;
+               }
+               else
+               {
+                 y_offset -= (height-3);
+                 if (y_offset<0)
+                   y_offset = 0;
+               }
+             }
+             else
+             {
+               highlighted_line--;
+               if (highlighted_line<y_offset)
+                 y_offset--;
+             }
+           }
+           offset_lines = 1;
+           scroll_lines = 0;
+           if (args[highlighted_line][0] == '-')
+           {
+              offset_lines = get_non_separator_line( highlighted_line, num_args, args, -1 );
+              if ( offset_lines == 0 )
+                 highlighted_line++;
+              else
+              {
+                 highlighted_line -= offset_lines;
+                 scroll_lines = offset_lines;
+              }
+           }
+           if ( y_overlap )
+           {
+              if ( highlighted_line+1 <= y_offset
+              &&   y_offset )
+                 y_offset -= 1+scroll_lines;
+           }
+           continue;
+         }
+         if (y > (height-2))
+         {
+           if ( y_overlap )
+           {
+             highlighted_line +=(height-3);
+             if (highlighted_line>=num_args)
+             {
+               highlighted_line = num_args-1;
+             }
+             y_offset += (height-3);
+             if (y_offset > (num_args-height+2))
+               y_offset = (num_args-height+2);
+           }
+           else
+           {
+             if (highlighted_line<(num_args-1))
+             {
+               highlighted_line++;
+               if ((highlighted_line-y_offset)>(height-3))
+                 y_offset++;
+             }
+           }
+           offset_lines = 1;
+           scroll_lines = 0;
+           if (args[highlighted_line][0] == '-')
+           {
+              offset_lines = get_non_separator_line( highlighted_line, num_args, args, 1 );
+              if ( offset_lines == 0 )
+                 highlighted_line--;
+              else
+              {
+                 highlighted_line += offset_lines;
+                 scroll_lines = offset_lines;
+              }
+           }
+           if ( y_overlap )
+           {
+              if ( highlighted_line + 2 >= y_offset + height
+              &&   y_offset < y_overlap )
+                 y_offset += 1+scroll_lines;
+           }
+           continue;
+         }
+         if (y != (highlighted_line-y_offset+1))
+         {
+           if ((args[y_offset+y-1][0]) != '-')
+             highlighted_line = y_offset+y-1;
+           continue;
+         }
+#endif //GYMOD
+
          /*
           * Check that the mouse is clicked on a valid item
           */
          if (y > 0 && y+1 < height && x > 0 && x+1 < width)
          {
             i = y-1;
+#ifdef GYMOD
+            i += y_offset;
+#endif //GYMOD
          }
          else
          {
@@ -5430,7 +5787,12 @@
                /* increment highlighted line and check we haven't gone past the end of the list */
                if ( ++highlighted_line >= num_args )
                {
+#ifdef GYMOD
+                  highlighted_line = 0;
+                  y_offset = 0;
+#else //GYMOD
                   highlighted_line = num_args - 1;
+#endif //GYMOD
                   break;
                }
                offset_lines = 1;
@@ -5504,11 +5866,20 @@
                }
                break;
 #endif
+#ifdef GYMOD
+            case KEY_BTAB:
+#endif //GYMOD
 #if defined(KEY_UP)
             case KEY_UP:
                if (--highlighted_line < 0 )
                {
+#ifdef GYMOD
+                  highlighted_line = num_args-1;
+                  if ( y_overlap )
+                     y_offset = num_args-height+2;
+#else //GYMOD
                   highlighted_line = 0;
+#endif //GYMOD
                   break;
                }
                offset_lines = 1;
@@ -5595,6 +5966,18 @@
             case 'q':
                time_to_quit = TRUE;
                break;
+#ifdef GYMOD
+            case KEY_HOME:
+               highlighted_line = 0;
+               y_offset = 0;
+               break;
+            case KEY_END:
+               highlighted_line = num_args-1;
+               if ( y_overlap )
+                  y_offset = num_args-height+2;
+               break;
+#endif //GYMOD
+
             default:
                if ( key == popup_escape_key )
                   time_to_quit = TRUE;
@@ -5617,6 +6000,58 @@
                break;
 
          }
+#ifdef GYMOD
+         if ((key > 0x1F && key < 0x100)
+             && (key != 'q' || key != popup_escape_key ))
+         {
+           ukey = toupper(key);
+           j = highlighted_line;
+           for (; j<num_args && toupper(args[j][k])!=ukey; j++)
+           {
+           }
+           if (j<num_args)
+           {
+             for (l=0; l<k && toupper(args[j][l])==kbuf[l]; l++)
+             {
+             }
+             if (l<k)
+               j = num_args;
+           }
+           if (j<num_args)
+           {
+             highlighted_line = j;
+             if ( y_overlap && j>(height-3) )
+                y_offset = j-height+3;
+             if ((k<KBCMAX) && (k<(width-4)))
+             {
+               kbuf[k] = ukey;
+               k++;
+             }
+           }
+           else
+           {
+             k=0;
+             for (j=0; j<num_args && toupper(args[j][0])!=ukey; j++)
+             {
+             }
+             if (j<num_args)
+             {
+               y_offset = 0;
+               highlighted_line = j;
+               if ( y_overlap && j>(height-3) )
+                  y_offset = j-height+3;
+               kbuf[0] = ukey;
+               k++;
+             }
+           }
+         }
+         else
+         {
+           kbuf[0]=0;
+           k=0;
+         }
+#endif //GYMOD
+
          if ( time_to_quit )
             break;
       }
diff -Naurd a/getch.c b/getch.c
--- a/getch.c	2013-07-26 16:09:13.000000000 +0200
+++ b/getch.c	2013-07-26 16:10:02.000000000 +0200
@@ -308,6 +308,58 @@
                              state = NORMAL;
                   }
                   break;
+#ifdef GYMOD
+/*===vvvv==stk 02/2003M==vvvv===*/
+               /* Create some strings to be used by a Linux keymap and  */
+               /*  have THE be able to recognise 'em...                 */
+               case '@':
+                       switch (fkeycount) {
+                       /* A-F1-A-F12 */
+                       case 37: case 38: case 39: case 40: case 41:
+                       case 42: case 43: case 44: case 45: case 46:
+                       case 47: case 48:
+                               return KEY_A_F1 + (fkeycount - 37);
+
+                       /* A-[cursor keypad key] */
+                       case 478: return ALT_DEL;
+                       case 479: return ALT_INS;
+                       case 486: return ALT_HOME;
+                       case 487: return ALT_PGUP;
+                       case 488: return ALT_PGDN;
+                       case 489: return ALT_END;
+                       case 490: return ALT_UP;
+                       case 491: return ALT_DOWN;
+                       case 492: return ALT_RIGHT;
+                       case 493: return ALT_LEFT;
+
+                       /* A-[numeric keypad key] */
+                       case 461: return ALT_PADENTER;
+                       case 472: return ALT_PADPLUS;
+                       case 473: return ALT_PADMINUS;
+                       case 474: return ALT_PADSLASH;
+                       case 475: return ALT_PADSTAR;
+                       case 476: return ALT_PADSTOP;
+
+                       /* more A-[numeric keypad key]...           */
+                       /*  (In the keymap I only bother with       */
+                       /*  "zero " and the "arrows" [2, 4, 6, 8])  */
+                       case 517: return ALT_PAD0;
+                       case 518: return ALT_PAD1;
+                       case 519: return ALT_PAD2;
+                       case 520: return ALT_PAD3;
+                       case 521: return ALT_PAD4;
+                       case 522: return ALT_PAD5;
+                       case 523: return ALT_PAD6;
+                       case 524: return ALT_PAD7;
+                       case 525: return ALT_PAD8;
+                       case 526: return ALT_PAD9;
+                       default:
+                               state = NORMAL;
+                               }
+                       break;
+/*===^^^^==stk 02/2003M==^^^^===*/
+#endif //GYMOD
+
                case '[':
                   state = BRACK;
                   break;
@@ -326,6 +378,75 @@
                   state = FKEY;
                   fkeycount = 0;
                   break;
+#ifdef GYMOD
+/*===vvvv==stk 02/2003M==vvvv===*/
+#define HIGHBIT 0200 
+               /* let's use octal format, to make life easier for    */
+               /*  keymap-fiddlers...                                */
+               case HIGHBIT: /*<--- useless label? Helps make the    */
+                             /*  (il)logic clear... I'm not a Real   */
+                             /*  C Programmer yet ;-) Just glad this */
+                             /*  works!                              */
+                       /* A-[special key] */
+                       case 0207: return ALT_ESC; 
+                       case 0210: return ALT_BKSP; 
+                       case 0211: return ALT_TAB; 
+                       case 0215: return ALT_ENTER; 
+                       /* A-0-A-9 */
+                       /* loop here?... */
+                       case 0251: return ALT_0;   
+                       case 0241: return ALT_1;   
+                       case 0300: return ALT_2;   
+                       case 0243: return ALT_3;   
+                       case 0244: return ALT_4;   
+                       case 0245: return ALT_5;   
+                       case 0336: return ALT_6;   
+                       case 0246: return ALT_7;   
+                       case 0252: return ALT_8;   
+                       case 0250: return ALT_9;   
+                       /* A-[punct] */
+                       case 0247: return ALT_FQUOTE;  
+                       case 0253: return ALT_EQUAL;   
+                       case 0254: return ALT_COMMA;   
+                       case 0256: return ALT_STOP;    
+                       case 0257: return ALT_FSLASH;  
+                       case 0273: return ALT_SEMICOLON; 
+                       case 0333: return ALT_LBRACKET;
+                       case 0334: return ALT_BSLASH;  
+                       case 0335: return ALT_RBRACKET;
+                       case 0337: return ALT_MINUS;   
+                       case 0340: return ALT_BQUOTE;
+                       /* A-A-A-Z */                  
+                       /* another potential loop, I daresay... */
+                       case 0341: return ALT_A;       
+                       case 0342: return ALT_B;       
+                       case 0343: return ALT_C;       
+                       case 0344: return ALT_D;       
+                       case 0345: return ALT_E;       
+                       case 0346: return ALT_F;       
+                       case 0347: return ALT_G;       
+                       case 0350: return ALT_H;       
+                       case 0351: return ALT_I;       
+                       case 0352: return ALT_J;       
+                       case 0353: return ALT_K;       
+                       case 0354: return ALT_L;       
+                       case 0355: return ALT_M;       
+                       case 0356: return ALT_N;       
+                       case 0357: return ALT_O;       
+                       case 0360: return ALT_P;       
+                       case 0361: return ALT_Q;       
+                       case 0362: return ALT_R;       
+                       case 0363: return ALT_S;       
+                       case 0364: return ALT_T;       
+                       case 0365: return ALT_U;       
+                       case 0366: return ALT_V;       
+                       case 0367: return ALT_W;       
+                       case 0370: return ALT_X;       
+                       case 0371: return ALT_Y;       
+                       case 0372: return ALT_Z;       
+/*===^^^^==stk 02/2003M==^^^^===*/            
+#endif //GYMOD
+
                /* VT52 PF keys */
                case 'P': case 'Q': case 'R': case 'S':
                   return KEY_PF1 + (c - 'P');
diff -Naurd a/getch.h b/getch.h
--- a/getch.h	2013-07-26 16:09:13.000000000 +0200
+++ b/getch.h	2013-07-26 16:10:02.000000000 +0200
@@ -651,3 +651,154 @@
 #define KEY_A_DB2      0x42a
 #define KEY_A_DB3      0x42b
 
+#ifdef GYMOD
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+/* PDCurses specific key definitions */
+# define KEY_A1          0x1c1   /* upper left on Virtual keypad  */
+# define KEY_A2          0x1c2   /* upper middle on Virt. keypad  */
+# define KEY_A3          0x1c3   /* upper right on Vir. keypad    */
+# define KEY_B1          0x1c4   /* middle left on Virt. keypad   */
+# define KEY_B2          0x1c5   /* center on Virt. keypad        */
+# define KEY_B3          0x1c6   /* middle right on Vir. keypad   */
+# define KEY_C1          0x1c7   /* lower left on Virt. keypad    */
+# define KEY_C2          0x1c8   /* lower middle on Virt. keypad  */
+# define KEY_C3          0x1c9   /* lower right on Vir. keypad    */
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADENTER        0x1cb   /* enter on keypad               */
+# define CTL_PADENTER    0x1cc   /* ctl-enter on keypad           */
+# define ALT_PADENTER    0x1cd   /* alt-enter on keypad           */
+# define PADSTOP         0x1ce   /* stop on keypad                */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+# define CTL_PADSTOP     0x1d2   /* ctl-stop on keypad            */
+# define CTL_PADCENTER   0x1d3   /* ctl-enter on keypad           */
+# define CTL_PADPLUS     0x1d4   /* ctl-plus on keypad            */
+# define CTL_PADMINUS    0x1d5   /* ctl-minus on keypad           */
+# define CTL_PADSLASH    0x1d6   /* ctl-slash on keypad           */
+# define CTL_PADSTAR     0x1d7   /* ctl-star on keypad            */
+# define ALT_PADPLUS     0x1d8   /* alt-plus on keypad            */
+# define ALT_PADMINUS    0x1d9   /* alt-minus on keypad           */
+# define ALT_PADSLASH    0x1da   /* alt-slash on keypad           */
+# define ALT_PADSTAR     0x1db   /* alt-star on keypad            */
+# define ALT_PADSTOP     0x1dc   /* alt-stop on keypad            */
+# define CTL_INS         0x1dd   /* ctl-insert                    */
+# define ALT_DEL         0x1de   /* alt-delete                    */
+# define ALT_INS         0x1df   /* alt-insert                    */
+# define CTL_UP          0x1e0   /* ctl-up arrow                  */
+# define CTL_DOWN        0x1e1   /* ctl-down arrow                */
+# define CTL_TAB         0x1e2   /* ctl-tab                       */
+# define ALT_TAB         0x1e3   /* alt-tab                       */
+# define ALT_MINUS       0x1e4   /* alt-minus                     */
+# define ALT_EQUAL       0x1e5   /* alt-equal                     */
+# define ALT_HOME        0x1e6   /* alt-home                      */
+# define ALT_PGUP        0x1e7   /* alt-pgup                      */
+# define ALT_PGDN        0x1e8   /* alt-pgdn                      */
+# define ALT_END         0x1e9   /* alt-end                       */
+# define ALT_UP          0x1ea   /* alt-up arrow                  */
+# define ALT_DOWN        0x1eb   /* alt-down arrow                */
+# define ALT_RIGHT       0x1ec   /* alt-right arrow               */
+# define ALT_LEFT        0x1ed   /* alt-left arrow                */
+# define ALT_ENTER       0x1ee   /* alt-enter                     */
+# define ALT_ESC         0x1ef   /* alt-escape                    */
+# define ALT_BQUOTE      0x1f0   /* alt-back quote                */
+# define ALT_LBRACKET    0x1f1   /* alt-left bracket              */
+# define ALT_RBRACKET    0x1f2   /* alt-right bracket             */
+# define ALT_SEMICOLON   0x1f3   /* alt-semi-colon                */
+# define ALT_FQUOTE      0x1f4   /* alt-forward quote             */
+# define ALT_COMMA       0x1f5   /* alt-comma                     */
+# define ALT_STOP        0x1f6   /* alt-stop                      */
+# define ALT_FSLASH      0x1f7   /* alt-forward slash             */
+# define ALT_BKSP        0x1f8   /* alt-backspace                 */
+# define CTL_BKSP        0x1f9   /* ctl-backspace                 */
+# define PAD0            0x1fa   /* ctl-keypad 0                  */
+# define CTL_PAD0        0x1fb   /* ctl-keypad 0                  */
+# define CTL_PAD1        0x1fc   /* ctl-keypad 1                  */
+# define CTL_PAD2        0x1fd   /* ctl-keypad 2                  */
+# define CTL_PAD3        0x1fe   /* ctl-keypad 3                  */
+# define CTL_PAD4        0x1ff   /* ctl-keypad 4                  */
+# define CTL_PAD5        0x200   /* ctl-keypad 5                  */
+# define CTL_PAD6        0x201   /* ctl-keypad 6                  */
+# define CTL_PAD7        0x202   /* ctl-keypad 7                  */
+# define CTL_PAD8        0x203   /* ctl-keypad 8                  */
+# define CTL_PAD9        0x204   /* ctl-keypad 9                  */
+# define ALT_PAD0        0x205   /* ctl-keypad 0                  */
+# define ALT_PAD1        0x206   /* ctl-keypad 1                  */
+# define ALT_PAD2        0x207   /* ctl-keypad 2                  */
+# define ALT_PAD3        0x208   /* ctl-keypad 3                  */
+# define ALT_PAD4        0x209   /* ctl-keypad 4                  */
+# define ALT_PAD5        0x20a   /* ctl-keypad 5                  */
+# define ALT_PAD6        0x20b   /* ctl-keypad 6                  */
+# define ALT_PAD7        0x20c   /* ctl-keypad 7                  */
+# define ALT_PAD8        0x20d   /* ctl-keypad 8                  */
+# define ALT_PAD9        0x20e   /* ctl-keypad 9                  */
+# define CTL_DEL         0x20f   /* clt-delete                    */
+# define ALT_BSLASH      0x210   /* alt-back slash                */
+# define CTL_ENTER       0x211   /* ctl-enter                     */
+# define SHF_PADENTER    0x212   /* shift-enter on keypad         */
+# define SHF_PADSLASH    0x213   /* shift-slash on keypad         */
+# define SHF_PADSTAR     0x214   /* shift-star  on keypad         */
+# define SHF_PADPLUS     0x215   /* shift-plus  on keypad         */
+# define SHF_PADMINUS    0x216   /* shift-minus on keypad         */
+# define SHF_UP          0x217   /* shift-up on keypad            */
+# define SHF_DOWN        0x218   /* shift-down on keypad          */
+# define SHF_IC          0x219   /* shift-insert on keypad        */
+# define SHF_DC          0x21a   /* shift-delete on keypad        */
+# define KEY_MOUSE       0x21b   /* "mouse" key                   */
+# define KEY_SHIFT_L     0x21c   /* Left-shift                    */
+# define KEY_SHIFT_R     0x21d   /* Right-shift                   */
+# define KEY_CONTROL_L   0x21e   /* Left-control                  */
+# define KEY_CONTROL_R   0x21f   /* Right-control                 */
+# define KEY_ALT_L       0x220   /* Left-alt                      */
+# define KEY_ALT_R       0x221   /* Right-alt                     */
+# define KEY_RESIZE      0x222   /* Window resize                 */
+# define KEY_SUP         0x223   /* Shifted up arrow              */
+# define KEY_SDOWN       0x224   /* Shifted down arrow            */
+# define KEY_MAX         0x224   /* Maximum curses key            */
+#define ALT_0           0x197 
+#define ALT_1           0x198 
+#define ALT_2           0x199 
+#define ALT_3           0x19a 
+#define ALT_4           0x19b 
+#define ALT_5           0x19c 
+#define ALT_6           0x19d 
+#define ALT_7           0x19e 
+#define ALT_8           0x19f 
+#define ALT_9           0x1a0 
+#define ALT_A           0x1a1 
+#define ALT_B           0x1a2 
+#define ALT_C           0x1a3 
+#define ALT_D           0x1a4 
+#define ALT_E           0x1a5 
+#define ALT_F           0x1a6 
+#define ALT_G           0x1a7 
+#define ALT_H           0x1a8 
+#define ALT_I           0x1a9 
+#define ALT_J           0x1aa 
+#define ALT_K           0x1ab 
+#define ALT_L           0x1ac 
+#define ALT_M           0x1ad 
+#define ALT_N           0x1ae 
+#define ALT_O           0x1af 
+#define ALT_P           0x1b0 
+#define ALT_Q           0x1b1 
+#define ALT_R           0x1b2 
+#define ALT_S           0x1b3 
+#define ALT_T           0x1b4 
+#define ALT_U           0x1b5 
+#define ALT_V           0x1b6 
+#define ALT_W           0x1b7 
+#define ALT_X           0x1b8 
+#define ALT_Y           0x1b9 
+#define ALT_Z           0x1ba 
+#define CTL_LEFT        0x1bb 
+#define CTL_RIGHT       0x1bc 
+#define CTL_PGUP        0x1bd 
+#define CTL_PGDN        0x1be 
+#define CTL_HOME        0x1bf 
+#define CTL_END         0x1c0 
+#endif //GYMOD
+
diff -Naurd a/key.h b/key.h
--- a/key.h	2013-07-26 16:09:13.000000000 +0200
+++ b/key.h	2013-07-26 16:10:02.000000000 +0200
@@ -219,6 +219,87 @@
   {(CHARTYPE *)"NUM7"     ,KEY_A1,0},
   {(CHARTYPE *)"NUM8"     ,KEY_A2,0},
   {(CHARTYPE *)"NUM9"     ,KEY_A3,0},
+#ifdef GYMOD
+/*===vvvv==stk 02/2003==vvvv===*/
+  {(CHARTYPE *)"A-A",ALT_A,SHIFT_ALT},
+  {(CHARTYPE *)"A-B",ALT_B,SHIFT_ALT},
+  {(CHARTYPE *)"A-C",ALT_C,SHIFT_ALT},
+  {(CHARTYPE *)"A-D",ALT_D,SHIFT_ALT},
+  {(CHARTYPE *)"A-E",ALT_E,SHIFT_ALT},
+  {(CHARTYPE *)"A-F",ALT_F,SHIFT_ALT},
+  {(CHARTYPE *)"A-G",ALT_G,SHIFT_ALT},
+  {(CHARTYPE *)"A-H",ALT_H,SHIFT_ALT},
+  {(CHARTYPE *)"A-I",ALT_I,SHIFT_ALT},
+  {(CHARTYPE *)"A-J",ALT_J,SHIFT_ALT},
+  {(CHARTYPE *)"A-K",ALT_K,SHIFT_ALT},
+  {(CHARTYPE *)"A-L",ALT_L,SHIFT_ALT},
+  {(CHARTYPE *)"A-M",ALT_M,SHIFT_ALT},
+  {(CHARTYPE *)"A-N",ALT_N,SHIFT_ALT},
+  {(CHARTYPE *)"A-O",ALT_O,SHIFT_ALT},
+  {(CHARTYPE *)"A-P",ALT_P,SHIFT_ALT},
+  {(CHARTYPE *)"A-Q",ALT_Q,SHIFT_ALT},
+  {(CHARTYPE *)"A-R",ALT_R,SHIFT_ALT},
+  {(CHARTYPE *)"A-S",ALT_S,SHIFT_ALT},
+  {(CHARTYPE *)"A-T",ALT_T,SHIFT_ALT},
+  {(CHARTYPE *)"A-U",ALT_U,SHIFT_ALT},
+  {(CHARTYPE *)"A-V",ALT_V,SHIFT_ALT},
+  {(CHARTYPE *)"A-W",ALT_W,SHIFT_ALT},
+  {(CHARTYPE *)"A-X",ALT_X,SHIFT_ALT},
+  {(CHARTYPE *)"A-Y",ALT_Y,SHIFT_ALT},
+  {(CHARTYPE *)"A-Z",ALT_Z,SHIFT_ALT},
+  {(CHARTYPE *)"A-0",ALT_0,SHIFT_ALT},
+  {(CHARTYPE *)"A-1",ALT_1,SHIFT_ALT},
+  {(CHARTYPE *)"A-2",ALT_2,SHIFT_ALT},
+  {(CHARTYPE *)"A-3",ALT_3,SHIFT_ALT},
+  {(CHARTYPE *)"A-4",ALT_4,SHIFT_ALT},
+  {(CHARTYPE *)"A-5",ALT_5,SHIFT_ALT},
+  {(CHARTYPE *)"A-6",ALT_6,SHIFT_ALT},
+  {(CHARTYPE *)"A-7",ALT_7,SHIFT_ALT},
+  {(CHARTYPE *)"A-8",ALT_8,SHIFT_ALT},
+  {(CHARTYPE *)"A-9",ALT_9,SHIFT_ALT},
+  {(CHARTYPE *)"A-`",ALT_BQUOTE,SHIFT_ALT},
+  {(CHARTYPE *)"A--",ALT_MINUS,SHIFT_ALT},
+  {(CHARTYPE *)"A-=",ALT_EQUAL,SHIFT_ALT},
+  {(CHARTYPE *)"A-[",ALT_LBRACKET,SHIFT_ALT},
+  {(CHARTYPE *)"A-]",ALT_RBRACKET,SHIFT_ALT},
+  {(CHARTYPE *)"A-\\",ALT_BSLASH,SHIFT_ALT},
+  {(CHARTYPE *)"A-;",ALT_SEMICOLON,SHIFT_ALT},
+  {(CHARTYPE *)"A-'",ALT_FQUOTE,SHIFT_ALT},
+  {(CHARTYPE *)"A-,",ALT_COMMA,SHIFT_ALT},
+  {(CHARTYPE *)"A-.",ALT_STOP,SHIFT_ALT},
+  {(CHARTYPE *)"A-/",ALT_FSLASH,SHIFT_ALT},
+  {(CHARTYPE *)"A-ENTER",ALT_ENTER,SHIFT_ALT},
+  {(CHARTYPE *)"A-TAB",ALT_TAB,SHIFT_ALT},
+  {(CHARTYPE *)"A-ESC",ALT_ESC ,SHIFT_ALT},
+  {(CHARTYPE *)"A-BKSP",ALT_BKSP ,SHIFT_ALT},
+  {(CHARTYPE *)"A-HOME",ALT_HOME,SHIFT_ALT},
+  {(CHARTYPE *)"A-PGUP",ALT_PGUP,SHIFT_ALT},
+  {(CHARTYPE *)"A-PGDN",ALT_PGDN,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURU",ALT_UP,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURD",ALT_DOWN,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURL",ALT_LEFT,SHIFT_ALT},
+  {(CHARTYPE *)"A-CURR",ALT_RIGHT,SHIFT_ALT},
+  {(CHARTYPE *)"A-END",ALT_END,SHIFT_ALT},
+  {(CHARTYPE *)"A-INS",ALT_INS,SHIFT_ALT},
+  {(CHARTYPE *)"A-DEL",ALT_DEL,SHIFT_ALT},
+  {(CHARTYPE *)"A-PLUS",ALT_PADPLUS,SHIFT_ALT},
+  {(CHARTYPE *)"A-MINUS",ALT_PADMINUS,SHIFT_ALT},
+  {(CHARTYPE *)"A-SLASH",ALT_PADSLASH,SHIFT_ALT},
+  {(CHARTYPE *)"A-STAR",ALT_PADSTAR,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUMENTER",ALT_PADENTER,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUMSTOP",ALT_PADSTOP,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM0",ALT_PAD0,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM1",ALT_PAD1,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM2",ALT_PAD2,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM3",ALT_PAD3,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM4",ALT_PAD4,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM5",ALT_PAD5,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM6",ALT_PAD6,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM7",ALT_PAD7,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM8",ALT_PAD8,SHIFT_ALT},
+  {(CHARTYPE *)"A-NUM9",ALT_PAD9,SHIFT_ALT},
+/*===^^^^==stk 02/2003==^^^^===*/
+#endif //GYMOD
 
 #if defined(DOS) || defined(OS2) || defined(USE_XCURSES) || defined(WIN32)
 /* normal characters */
diff -Naurd a/Makefile.in b/Makefile.in
--- a/Makefile.in	2013-07-26 16:09:13.000000000 +0200
+++ b/Makefile.in	2013-07-26 16:10:02.000000000 +0200
@@ -36,7 +36,7 @@
 HTML_EXT		= @HTML_EXT@
 
 CC		= @CC@
-CFLAGS		= @CFLAGS@
+CFLAGS		= @CFLAGS@ -DGYMOD
 LIBS		= @LIBS@
 DEBUG =            @DEBUG@
 DEBUGGING =        @DEBUGGING@
@@ -380,11 +380,11 @@
 binarybase: $(THEBIN) the the.man THE_Help.txt
 	-rm -fr ./tmpdir
 	$(INSTALL) -m 755 -d ./tmpdir/bin
-	$(INSTALL) -m 755 -d ./tmpdir/man/man1
+	$(INSTALL) -m 755 -d ./tmpdir/share/man/man1
 	$(INSTALL) -m 755 -d ./tmpdir/share/THE
 	$(INSTALL) -m 755 -c ./$(THEBIN) ./tmpdir/bin/$(THEBIN)
 	$(INSTALL) -m 755 -c ./the ./tmpdir/bin/the
-	$(INSTALL) -m 644 -c $(srcdir)/the.1 ./tmpdir/man/man1/the.1
+	$(INSTALL) -m 644 -c $(srcdir)/the.1 ./tmpdir/share/man/man1/the.1
 	$(INSTALL) -m 644 -c ./THE_Help.txt ./tmpdir/share/THE/THE_Help.txt
 	$(INSTALL) -m 644 -c $(srcdir)/append.the   ./tmpdir/share/THE/append.the
 	$(INSTALL) -m 644 -c $(srcdir)/comm.the     ./tmpdir/share/THE/comm.the
@@ -513,7 +513,8 @@
 	target.o   \
 	the.o      \
 	mygetopt.o \
-	util.o
+	util.o \
+	calc.o
 
 the: execthe.o mygetopt.o
 	$(LINK) execthe.o mygetopt.o -o the $(THELDFLAGS)
@@ -665,6 +666,9 @@
 alloca.o: $(srcdir)/alloca.c
 	$(CC) $(CCFLAGS) -o alloca.o $(srcdir)/alloca.c
 
+calc.o: $(srcdir)/calc.c
+	$(CC) $(CCFLAGS) -o calc.o $(srcdir)/calc.c
+
 utf8.o: $(contribdir)/utf8.c $(H1)
 	$(CC) $(CCFLAGS) -o utf8.o $(contribdir)/utf8.c
 
diff -Naurd a/mouse.c b/mouse.c
--- a/mouse.c	2013-07-26 16:09:13.000000000 +0200
+++ b/mouse.c	2013-07-26 16:10:02.000000000 +0200
@@ -539,14 +539,20 @@
             WINDOW_FILEAREA|MOUSE_LEFT|MOUSE_DRAG|MOUSE_SHIFT,
             (CHARTYPE *)"CURSOR MOUSE#MARK LINE",FALSE,FALSE,0);
    add_define(&first_mouse_define,&last_mouse_define,
-            WINDOW_FILEAREA|MOUSE_LEFT|MOUSE_DRAG|MOUSE_CONTROL,
+            WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_CONTROL,
             (CHARTYPE *)"CURSOR MOUSE#MARK BOX",FALSE,FALSE,0);
    add_define(&first_mouse_define,&last_mouse_define,
             WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_SHIFT,
             (CHARTYPE *)"CURSOR MOUSE#MARK LINE",FALSE,FALSE,0);
+#ifdef GYMOD
+   add_define(&first_mouse_define,&last_mouse_define,
+            WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_CONTROL,
+            (CHARTYPE *)"CURSOR MOUSE#SOS EDIT",FALSE,FALSE,0);
+#else  //GYMOD
    add_define(&first_mouse_define,&last_mouse_define,
             WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_PRESS|MOUSE_CONTROL,
             (CHARTYPE *)"CURSOR MOUSE#MARK BOX",FALSE,FALSE,0);
+#endif //GYMOD
    add_define(&first_mouse_define,&last_mouse_define,
             WINDOW_FILEAREA|MOUSE_RIGHT|MOUSE_CLICK|MOUSE_NORMAL,
             (CHARTYPE *)"CURSOR MOUSE#SOS MAKECURR",FALSE,FALSE,0);
diff -Naurd a/nonansi.c b/nonansi.c
--- a/nonansi.c	2013-07-26 16:09:13.000000000 +0200
+++ b/nonansi.c	2013-07-26 16:10:02.000000000 +0200
@@ -71,6 +71,273 @@
 # endif
 #endif
 
+#if defined(GYMOD) && defined(DOS)
+#include <dpmi.h>
+#include <sys/movedata.h>
+#include <sys/segments.h>
+/* Text only */
+#define CF_TEXT 0x01
+#define CF_OEMTEXT 0x07
+/* Max size 1M */
+#define MAX_CLIP_SIZE (0x100000)
+static long actual_clip_size = 0L;
+bool WinClip = FALSE;
+/* Clipboard return codes */
+#define CLIP_OPENED         0
+#define CLIP_OPENED_ALREADY 1
+int  win_clip_open (void);
+int  win_clip_close (void);
+int  win_clip_empty (void);
+long win_clip_getsize (int format);
+int  win_clip_getdata (int format, char *buffer, long buffer_size);
+int  win_clip_setdata (int format, char *buffer, long buffer_size);
+// int  win_clip_compact (int size);
+
+/*  Get windows clipboard to local buffer */
+int getclp(char **pastebuf, long *sizebuf)
+{
+  int rc=RC_OK;
+  rc=win_clip_open();
+  if (rc==CLIP_OPENED || rc==CLIP_OPENED_ALREADY)
+  {
+    rc=win_clip_getdata(CF_OEMTEXT, *pastebuf, MAX_CLIP_SIZE);
+    *sizebuf = actual_clip_size;
+    win_clip_close();
+  }
+  if (rc != RC_OK)
+  {
+    display_error(186,(CHARTYPE *)"Read from clip failed",FALSE);
+    return PDC_CLIP_ACCESS_ERROR;
+  }
+  display_error(0,"Imported from clipboard",TRUE);
+  return(RC_OK);
+}
+
+/*  write buffer to windows clipboard */
+int setclp(char *pastebuf, long sizebuf)
+{
+  int rc=RC_OK;
+  if (sizebuf > MAX_CLIP_SIZE)
+  {
+    display_error(186,(CHARTYPE *)"Size to big",FALSE);
+    return PDC_CLIP_ACCESS_ERROR;
+  }
+  win_clip_open();
+  if (rc==CLIP_OPENED || rc==CLIP_OPENED_ALREADY)
+  {
+    win_clip_empty();
+    rc=win_clip_setdata(CF_OEMTEXT, pastebuf, sizebuf);
+    win_clip_close();
+  }
+  if (rc != RC_OK)
+  {
+    display_error(186,(CHARTYPE *)"Write to clip failed",FALSE);
+    return PDC_CLIP_ACCESS_ERROR;
+  }
+  display_error(0,"Placed to clipboard",TRUE);
+  return(RC_OK);
+}
+
+/* - win_winoldap_getversion - */
+int win_winoldap_getversion (int *major, int *minor, int *clip)
+{
+  union REGS r;
+  r.x.ax=0x1600;   /* See if Enhanced mode windows */
+  int86(0x2f,&r,&r);
+  if ((255 & r.x.ax)==0)
+  {
+    display_error(186,(CHARTYPE *)"Not in windows enhanced mode",FALSE);
+    return(1);
+  }
+  /* Call INT 0x2F AX=0x1700 to get WinOldAp version */
+  memset(&r, 0, sizeof(r));
+  r.x.ax = 0x1700;
+  int86(0x2F, &r, &r);
+  /* Clipboard support? */
+  if (clip != NULL) { if (r.x.ax == 0x1700) *clip = 0; else *clip = 1; }
+  /* Store version numbers */
+  if (major != NULL)  *major = r.h.al;
+  if (minor != NULL)  *minor = r.h.ah;
+  /* TODO: Error check */
+  /* Succeed every time because I am unsure how to detect an error */
+  return(1);
+}
+
+/* - clip_valid - */
+/* This checks that the clipboard can be used. When first called, it calls
+   WinOldAp to find out whether it supports clipboard usage. After that it
+   simply returns a stored status variable. */
+int clip_valid (void)
+{
+  static int clip_inited = 0;
+  static int clip_supported = 0;
+  /* Just return the initialisation value */
+  if (clip_inited) return(clip_supported);
+  /* Find out whether we can use the clipboard */
+  win_winoldap_getversion(NULL, NULL, &clip_supported);
+  if (!clip_supported)
+    display_error(186,(CHARTYPE *)"API not implemented for clipboard",FALSE);
+  /* Done */
+  clip_inited = 1;
+  return(clip_supported);
+}
+
+/* - win_clip_open - */
+int win_clip_open (void)
+{
+  __dpmi_regs r;
+  if (!clip_valid()) return(-1);
+  /* Perform the call */
+  memset(&r, 0, sizeof(r));
+  r.x.ax = 0x1701;
+  __dpmi_int(0x2F, &r);
+  /* Clipboard opened ok */
+  if (r.x.ax != 0)
+      return(CLIP_OPENED);
+  /* Clipboard already open */
+  else if (r.x.ax == 0)
+      return(CLIP_OPENED_ALREADY);
+  /* Fail by default */
+  display_error(186,(CHARTYPE *)"Open clip failed",FALSE);
+  return(-1);
+}
+
+/* - win_clip_empty - */
+int win_clip_empty (void)
+{
+  __dpmi_regs r;
+  if (!clip_valid()) return(-1);
+  /* Perform the call */
+  memset(&r, 0, sizeof(r));
+  r.x.ax = 0x1702;
+  __dpmi_int(0x2F, &r);
+  /* Clipboard emptied ok */
+  if (r.x.ax != 0)
+  {
+    actual_clip_size = 0;
+    return(0);
+  }
+  /* Failed to empty it */
+  return(-1);
+}
+
+/* - win_clip_getsize - */
+long win_clip_getsize (int format)
+{
+  __dpmi_regs r;
+  if (!clip_valid()) return(-1);
+  /* Perform the call */
+  memset(&r, 0, sizeof(r));
+  /* Get Windows Clipboard size dx:ax */
+  r.x.ax = 0x1704;
+  r.x.dx = format;
+  __dpmi_int(0x2F, &r);
+  /* Failed to get size */
+  if ((r.x.ax == 0) && (r.x.dx == 0))
+  {
+    display_error(187,(CHARTYPE *)"",FALSE);
+    return(-1);
+  }
+  /* Return the size */    
+/*  return( (r.x.dx << 16) + r.x.ax );*/
+  actual_clip_size = ((r.x.dx << 16) + r.x.ax );
+  return(actual_clip_size);
+}
+
+/* - win_clip_close - */
+int win_clip_close (void)
+{
+  __dpmi_regs r;
+  if (!clip_valid()) return(-1);
+  /* Perform the call */
+  memset(&r, 0, sizeof(r));
+  r.x.ax = 0x1708;
+  __dpmi_int(0x2F, &r);
+  /* Clipboard closed ok */
+  if (r.x.ax != 0) return(0);
+  /* Failed to close it */    
+  display_error(186,(CHARTYPE *)"Close clip failed",FALSE);
+  return(-1);
+}
+
+/* - win_clip_getdata - */
+int win_clip_getdata (int format, char *buffer, long buffer_size)
+{
+  long clipsize;
+  int paras, selector, segment;
+  __dpmi_regs r;
+  /* Get clipboard size - fail if this fails,
+     or the supplied buffer is too small */
+  clipsize = win_clip_getsize(format);
+  if ( (clipsize == -1) || (clipsize > buffer_size) ) return(-1);
+  /* Allocate a buffer for the library */
+  paras = (clipsize + 15) >> 4;
+  segment = __dpmi_allocate_dos_memory(paras, &selector);
+  if (segment == -1) return(-1);
+  /* Do the call */
+  memset(&r, 0, sizeof(r));
+  r.x.ax = 0x1705;
+  r.x.dx = format;
+  r.x.es = segment;
+  r.x.bx = 0;         /* Already done by memset anyway, but do it again */
+  __dpmi_int(0x2F, &r);
+  /* Success? */
+  if (r.x.ax == 0) { __dpmi_free_dos_memory(selector); return(-1); }
+  /* Copy the data & free the DOS memory */
+  movedata(selector, 0, _my_ds(), (int) buffer, clipsize);
+  __dpmi_free_dos_memory(selector);
+  /* OK */
+  return(0);
+}
+
+/* - win_clip_setdata - */
+int win_clip_setdata (int format, char *buffer, long buffer_size)
+{
+  __dpmi_regs r;
+  int segment, selector, paras;
+  /* Allocate some DOS memory */
+  paras = (buffer_size + 15) >> 4;
+  segment = __dpmi_allocate_dos_memory(paras, &selector);
+  if (segment == -1) return(-1);
+  /* Copy the data into it */
+  movedata(_my_ds(), (int) buffer, selector, 0, buffer_size);
+  /* Copy to the clipboard */
+  memset(&r, 0, sizeof(r));
+  r.x.ax = 0x1703;
+  r.x.dx = format;
+  r.x.es = segment;
+  r.x.bx = 0;                      /* Done already by memset */
+  r.x.si = buffer_size >> 16;
+  r.x.cx = buffer_size &  0xFFFF;
+  __dpmi_int(0x2F, &r);
+  /* Free the DOS memory */
+  __dpmi_free_dos_memory(selector);
+  /* Success? */
+  if (r.x.ax == 0)
+    return(-1);
+  win_clip_getsize(format);
+  return(0);
+}
+
+// /* - win_clip_compact - */
+// /* I'm not entirely sure what's meant by "compacting" the clipboard, but I
+//    think it discovers whether the clipboard is the size wanted. I.e. you call
+//    with desired size in bytes, and it returns the actual size in bytes. */
+// int win_clip_compact (int size)
+// {
+//     __dpmi_regs r;
+//     if (!clip_valid()) return(-1);
+//     /* Perform the call */
+//     memset(&r, 0, sizeof(r));
+//     r.x.ax = 0x1709;
+//     r.x.si = size >> 16;
+//     r.x.cx = size & 0xFFFF;
+//     __dpmi_int(0x2F, &r);
+//     /* Return the size of the largest block free */
+//     return((r.x.dx << 16) + r.x.ax);
+// }
+#endif //GYMOD
+
 /***********************************************************************/
 #ifdef HAVE_PROTO
 short file_readable(CHARTYPE *filename)
@@ -1201,6 +1468,69 @@
 
 #if defined(PDC_CLIP_SUCCESS)
    TRACE_FUNCTION("nonansi.c: getclipboard");
+#if defined(GYMOD) && defined(DOS)
+   if (WinClip)
+   {
+     if ((ptr = (CHARTYPE *)(*the_malloc)(MAX_CLIP_SIZE)) == NULL)
+     {
+        display_error(30,(CHARTYPE *)"",FALSE);
+        TRACE_RETURN();
+        return NULL;
+     }
+     rc = getclp( (DEFCHAR **)&ptr, &length );
+     if (rc != RC_OK)
+     {
+        TRACE_RETURN();
+        return NULL;
+     }
+     /* Trim any extra junk at end of OEM text */
+     if (length>0)
+     {
+       while (*(ptr+length-1)=='\0')
+       {
+         length--;
+         if (length==0)
+           break;
+       }
+     }
+     line_start=0;
+     maxlen = CURRENT_FILE->max_line_length;
+     for (i=0; i<length; i++)
+     {
+        if (*(ptr+i) == 0x0A) /* CR was prior character */
+        {
+           *(ptr+i-offset) = '\0';
+           if ((curr = add_LINE(CURRENT_FILE->first_line,curr,ptr+line_start,i-line_start-offset,0,TRUE)) == NULL)
+           {
+              curr = NULL;
+              break;
+           }
+           line_start = i+1;
+           numlines++;
+           if (i-line_start-offset > maxlen)
+              maxlen = i-line_start-offset;
+        }
+     }
+     if (line_start != i
+     &&  curr)
+     {
+        curr = add_LINE(CURRENT_FILE->first_line,curr,ptr+line_start,i-line_start,0,TRUE);
+        numlines++;
+        if (i-line_start > maxlen)
+           maxlen = i-line_start;
+     }
+     if (curr)
+     {
+        CURRENT_FILE->max_line_length = maxlen;
+        CURRENT_FILE->number_lines += numlines;
+     }
+     if (ptr != (CHARTYPE *)NULL)
+        (*the_free)(ptr);
+     TRACE_RETURN();
+     return curr;
+   }
+#endif //GYMOD
+
    rc = PDC_getclipboard( (DEFCHAR **)&ptr, &length );
 
    switch( rc )
@@ -1558,6 +1888,15 @@
 #if defined(PDC_CLIP_SUCCESS)
    if ( pos )
    {
+#if defined(GYMOD) && defined(DOS)
+      if (WinClip)
+      {
+        rc = setclp( (DEFCHAR *)ptr, pos );
+        free(ptr);
+        TRACE_RETURN();
+        return(rc);
+      }
+#endif //GYMOD
       rc = PDC_setclipboard( (DEFCHAR *)ptr, pos );
 
       switch( rc )
@@ -1703,7 +2042,11 @@
 
 #if defined(DOS)
 # define curs_set THE_curs_set
+#ifdef GYMOD
+static void THE_curs_set(int visibility)
+#else
 static void PDC_curs_set(int visibility)
+#endif //GYMOD
 {
    union REGS regs;
    int start, end;
diff -Naurd a/parser.c b/parser.c
--- a/parser.c	2013-07-26 16:09:13.000000000 +0200
+++ b/parser.c	2013-07-26 16:10:02.000000000 +0200
@@ -113,6 +113,10 @@
    return rc;
 }
 
+#ifdef GYMOD
+static CHARTYPE c_scrno;
+static SHOW_LINE *c_scurr;
+#endif //GYMOD
 /*
  * For the supplied displayed line find a paired comment delimiter
  * Only look for delimiters if there is no syntax highlighting already
@@ -137,6 +141,15 @@
    CHARTYPE ch1,ch2,ch3;
 
    TRACE_FUNCTION( "parser.c:  find_comment" );
+#ifdef GYMOD
+   LENGTHTYPE vcol=0;
+   chtype string_colour;
+   vcol = SCREEN_VIEW(c_scrno)->verify_col-1;
+   if ( c_scurr->is_current_line )
+      string_colour = merge_curline_colour(fd->attr+ATTR_CURLINE,fd->ecolour+ECOLOUR_STRINGS);
+   else
+      string_colour = set_colour(fd->ecolour+ECOLOUR_STRINGS);
+#endif //GYMOD
    for ( i = start; i < length; i++ )
    {
       if ( scurr->highlight_type[i] == THE_SYNTAX_NONE
@@ -163,6 +176,13 @@
             }
             if ( ch1 == ch2 )
             {
+#ifdef GYMOD
+               if (c_scurr->highlighting[i-vcol] == string_colour)
+               {
+                 TRACE_RETURN();
+                 return -1;
+               }
+#endif //GYMOD
                /*
                 * We have a match for the first character of the start delimiter;
                 * check if the rest of the delimiter matches...
@@ -201,6 +221,13 @@
             }
             if ( ch1 == ch2 )
             {
+#ifdef GYMOD
+               if (c_scurr->highlighting[i-vcol] == string_colour)
+               {
+                 TRACE_RETURN();
+                 return -1;
+               }
+#endif //GYMOD
                /*
                 * We have a match for the first character of the end delimiter;
                 * check if the rest of the delimiter matches...
@@ -239,12 +266,23 @@
 /***********************************************************************/
 {
    PARSE_COMMENTS *curr=fd->parser->first_comments;
+#ifdef GYMOD
+   LENGTHTYPE i,vcol,pos=0,len=scurr->length,len_comment;
+#else //GYMOD
    LENGTHTYPE i,pos=0,len=scurr->length,len_comment;
+#endif //GYMOD
    CHARTYPE *ptr;
    int state;
    CHARTYPE ch1,ch2;
 
    TRACE_FUNCTION( "parser.c:  find_line_comments" );
+#ifdef GYMOD
+   chtype string_colour;
+   if ( scurr->is_current_line )
+      string_colour = merge_curline_colour(fd->attr+ATTR_CURLINE,fd->ecolour+ECOLOUR_STRINGS);
+   else
+      string_colour = set_colour(fd->ecolour+ECOLOUR_STRINGS);
+#endif //GYMOD
    for (; curr != NULL; curr = curr->next)
    {
       /* this loop is executed for each defined single line comment */
@@ -305,6 +343,10 @@
             || ( state == STATE_COMMENT && *ptr == '\0'))
             {
                TRACE_RETURN();
+#ifdef GYMOD
+               if (scurr->highlighting[pos-vcol] == string_colour)
+                 return -1L;
+#endif //GYMOD
                return (long)pos;
             }
             break;
@@ -362,6 +404,10 @@
             || ( state == STATE_COMMENT && *ptr == '\0'))
             {
                TRACE_RETURN();
+#ifdef GYMOD
+               if (scurr->highlighting[pos-vcol] == string_colour)
+                 return -1L;
+#endif //GYMOD
                return (long)pos;
             }
             break;
@@ -384,6 +430,10 @@
                   if ( ch2 == '\0' )
                   {
                      TRACE_RETURN();
+#ifdef GYMOD
+                     if (scurr->highlighting[i-vcol] == string_colour)
+                       return -1L;
+#endif //GYMOD
                      return (long)curr->column;
                   }
                   if ( ch2 != ch1 )
@@ -415,6 +465,10 @@
    chtype comment_colour;
 
    TRACE_FUNCTION( "parser.c:  parse_line_comments" );
+#ifdef GYMOD
+   c_scrno = scrno;
+   c_scurr = scurr;
+#endif //GYMOD
    if ( scurr->is_cursor_line
    &&   scurr->is_cursor_line_filearea_different )
       comment_colour = merge_curline_colour( fd->attr+ATTR_CURSORLINE, fd->ecolour+ECOLOUR_COMMENTS );
diff -Naurd a/proto.h b/proto.h
--- a/proto.h	2013-07-26 16:09:13.000000000 +0200
+++ b/proto.h	2013-07-26 16:10:02.000000000 +0200
@@ -751,3 +751,54 @@
 short Xedit Args((CHARTYPE *));
 short Xterminal Args((CHARTYPE *));
 short Zone Args((CHARTYPE *));
+#ifdef GYMOD
+short Ansicstr Args((CHARTYPE *));
+short Banner Args((CHARTYPE *));
+short Calc Args((CHARTYPE *));
+short Center Args((CHARTYPE *));
+#if defined(PDC_CLIP_SUCCESS)
+short Clipboard Args((CHARTYPE *));
+#endif
+short Crypt Args((CHARTYPE *));
+short SCrypt Args((CHARTYPE *));
+short LCrypt Args((CHARTYPE *));
+short Linesep Args((CHARTYPE *));
+/*short RLE Args((CHARTYPE *));*/
+/*short RLD Args((CHARTYPE *));*/
+short LZE Args((CHARTYPE *));
+short LZD Args((CHARTYPE *));
+short Ebcdic Args((CHARTYPE *));
+short Eval Args((CHARTYPE *));
+short Flow Args((CHARTYPE *));
+short Fsave Args((CHARTYPE *));
+short FSearch Args((CHARTYPE *));
+short HLowercase Args((CHARTYPE *));
+short HSort Args((CHARTYPE *));
+short HUppercase Args((CHARTYPE *));
+short Justify Args((CHARTYPE *));
+short Lcompress Args((CHARTYPE *));
+short Ledit Args((CHARTYPE *));
+short Leftad Args((CHARTYPE *));
+short Lexpand Args((CHARTYPE *));
+short md5sum Args((CHARTYPE *));
+short Merge Args((CHARTYPE *));
+short Mimeb Args((CHARTYPE *));
+short Mimeq Args((CHARTYPE *));
+short Onespc Args((CHARTYPE *));
+short Rightad Args((CHARTYPE *));
+short Ringcmd Args((CHARTYPE *));
+short Sayf Args((CHARTYPE *));
+short sha1sum Args((CHARTYPE *));
+short Splttok Args((CHARTYPE *));
+short Tobin Args((CHARTYPE *));
+short Tochr Args((CHARTYPE *));
+short Todec Args((CHARTYPE *));
+short Tohex Args((CHARTYPE *));
+short Truncate Args((CHARTYPE *));
+/*short Unesc Args((CHARTYPE *));*/
+short Unjust Args((CHARTYPE *));
+short Uudecode Args((CHARTYPE *));
+short Uuencode Args((CHARTYPE *));
+short Wedit Args((CHARTYPE *));
+short Wind Args((CHARTYPE *));
+#endif //GYMOD
diff -Naurd a/query.c b/query.c
--- a/query.c	2013-07-26 16:09:13.000000000 +0200
+++ b/query.c	2013-07-26 16:10:02.000000000 +0200
@@ -1979,6 +1979,24 @@
 **man-end**********************************************************************/
 
 
+#ifdef GYMOD
+short set_boolean_value(bool, short);
+#ifdef HAVE_PROTO
+short extract_gymod_function(short number_variables,short itemno,CHARTYPE *itemargs,CHARTYPE query_type,LINETYPE argc,CHARTYPE *arg,LINETYPE arglen)
+#else
+short extract_gymod_function(number_variables,itemno,itemargs,query_type,argc,arg,arglen)
+short number_variables,itemno;
+CHARTYPE *itemargs;
+CHARTYPE query_type;
+LINETYPE argc;
+CHARTYPE *arg;
+LINETYPE arglen;
+#endif
+{
+   return set_boolean_value((bool)TRUE,(short)1);
+}
+#endif //GYMOD
+
 /***********************************************************************/
 /* Keep the following items in alphabetic order of name.               */
 /***********************************************************************/
@@ -2146,6 +2164,9 @@
    {(CHARTYPE *)"first",           5, 5,ITEM_FIRST_FUNCTION,         0, 1,LVL_VIEW,0,extract_first_function         },
    {(CHARTYPE *)"focuseof",        8, 8,ITEM_FOCUSEOF_FUNCTION,      0, 1,LVL_VIEW,0,extract_focuseof_function      },
    {(CHARTYPE *)"focustof",        8, 8,ITEM_FOCUSTOF_FUNCTION,      0, 1,LVL_VIEW,0,extract_focustof_function      },
+#ifdef GYMOD
+   {(CHARTYPE *)"gymod",           5, 5,ITEM_GYMOD_FUNCTION,         0, 1,LVL_GLOB,0,extract_gymod_function         },
+#endif //GYMOD
    {(CHARTYPE *)"inblock",         7, 7,ITEM_INBLOCK_FUNCTION,       0, 1,LVL_VIEW,0,extract_inblock_function       },
    {(CHARTYPE *)"incommand",       9, 9,ITEM_INCOMMAND_FUNCTION,     0, 1,LVL_VIEW,0,extract_incommand_function     },
    {(CHARTYPE *)"initial",         7, 7,ITEM_INITIAL_FUNCTION,       0, 1,LVL_GLOB,0,extract_initial_function       },
@@ -2451,7 +2472,11 @@
          }
       }
    }
+#ifdef GYMOD
+   mvaddstr(terminal_lines-1,0,HIT_ANY_KEY);
+#else //GYMOD
    mvaddstr(terminal_lines-2,0,HIT_ANY_KEY);
+#endif //GYMOD
    refresh();
 
    TRACE_RETURN();
diff -Naurd a/query.h b/query.h
--- a/query.h	2013-07-26 16:09:13.000000000 +0200
+++ b/query.h	2013-07-26 16:10:02.000000000 +0200
@@ -205,6 +205,25 @@
 #define ITEM_FIRST_FUNCTION                  14
 #define ITEM_FOCUSEOF_FUNCTION               15
 #define ITEM_FOCUSTOF_FUNCTION               16
+#ifdef GYMOD
+#define ITEM_GYMOD_FUNCTION                  17
+#define ITEM_INBLOCK_FUNCTION                18 
+#define ITEM_INCOMMAND_FUNCTION              19 
+#define ITEM_INITIAL_FUNCTION                20 
+#define ITEM_INPREFIX_FUNCTION               21 
+#define ITEM_INSERTMODE_FUNCTION             22
+#define ITEM_LEFTEDGE_FUNCTION               23
+#define ITEM_MODIFIABLE_FUNCTION             24
+#define ITEM_RIGHTEDGE_FUNCTION              25
+#define ITEM_RUN_OS_FUNCTION                 26
+#define ITEM_SHADOW_FUNCTION                 27
+#define ITEM_SHIFT_FUNCTION                  28
+#define ITEM_SPACECHAR_FUNCTION              29
+#define ITEM_TOF_FUNCTION                    30
+#define ITEM_TOPEDGE_FUNCTION                31
+#define ITEM_VALID_TARGET_FUNCTION           32
+#define ITEM_VERONE_FUNCTION                 33
+#else //GYMOD
 #define ITEM_INBLOCK_FUNCTION                17
 #define ITEM_INCOMMAND_FUNCTION              18
 #define ITEM_INITIAL_FUNCTION                19
@@ -221,6 +240,7 @@
 #define ITEM_TOPEDGE_FUNCTION                30
 #define ITEM_VALID_TARGET_FUNCTION           31
 #define ITEM_VERONE_FUNCTION                 32
+#endif //GYMOD
 /*---------------------------------------------------------------------*/
 /* The following are item number defines for the 'other' functions.    */
 /*---------------------------------------------------------------------*/
diff -Naurd a/sort.c b/sort.c
--- a/sort.c	2013-07-26 16:09:13.000000000 +0200
+++ b/sort.c	2013-07-26 16:10:02.000000000 +0200
@@ -58,6 +58,17 @@
 
 short num_fields;
 
+#ifdef GYMOD
+extern bool HuSortFlag;
+extern bool HuSortCase;
+char chr_hun[] = "ÁľÉÍÓÖ§ŐŕÚÜŰë áäéĄí˘óöőŁúüű\x00";
+char chr_bas[] = "AAAEEIIIIOOOOOOOOUUUUUUUaaaaeeiiooooooouuuuuu\x00";
+char chr_dis[] = "123121234012345671234567123412121234567123456 ";
+/*char ch_utf2[]="°ĄŠ­łśşźą\x00";*/
+char ch_utfa[] = "AEIOOOUUUaeiooouuu\x00";
+char ch_utfb[] = "88889:89:9999:;9:;\x00";
+#endif //GYMOD
+
 #ifdef HAVE_PROTO
 static int cmp(const void *,const void *);
 #else
@@ -73,6 +84,9 @@
 #endif
 /***********************************************************************/
 {
+#ifdef GYMOD
+   register int k,l;
+#endif //GYMOD
    LENGTHTYPE i=0,j=0;
    short rc=RC_OK;
    LENGTHTYPE len=0;
@@ -89,6 +103,10 @@
        * Calculate the length of the sort field.
        */
       len = sort_fields[i].right_col - sort_fields[i].left_col + 1;
+#ifdef GYMOD
+     if (HuSortFlag && HuSortCase)
+       len *= 2;
+#endif //GYMOD
       /*
        * Set the two temporary fields to blanks.
        */
@@ -105,7 +123,17 @@
        * contents of the sort field blank.
        */
       if (sort_fields[i].left_col <= one->length)
+#ifdef GYMOD
+       if (HuSortFlag && HuSortCase)
+       {
+         for (j=0,k=0;j<(len-1);j+=2,k++)
+           memcpy(sort_field_1+j,one->line+left_col-1+k,1);
+       }
+       else
          memcpy(sort_field_1,one->line+left_col-1,right_col-left_col+1);
+#else //GYMOD
+         memcpy(sort_field_1,one->line+left_col-1,right_col-left_col+1);
+#endif //GYMOD
       /*
        * For the next  line to be compared, extract the portion of the line
        * that corresponds with the current sort column...
@@ -117,7 +145,422 @@
        * contents of the sort field blank.
        */
       if (sort_fields[i].left_col <= two->length)
+#ifdef GYMOD
+       if (HuSortFlag && HuSortCase)
+       {
+         for (j=0,k=0;j<(len-1);j+=2,k++)
+           memcpy(sort_field_2+j,two->line+left_col-1+k,1);
+       }
+       else
          memcpy(sort_field_2,two->line+left_col-1,right_col-left_col+1);
+     if (HuSortFlag)
+     {
+         if (sort_field_1[2] == '.'
+         && (sort_field_1[0] == 'd' || sort_field_1[0] == 'D')
+         && (sort_field_1[1] == 'r' || sort_field_1[1] == 'R'))
+         {
+           j = 3;
+           if (sort_field_1[0] == ' ')
+             j++;
+           memcpy(sort_field_1,sort_field_1+j,len-j);
+         }
+         if (sort_field_2[2] == '.'
+         && (sort_field_2[0] == 'd' || sort_field_2[0] == 'D')
+         && (sort_field_2[1] == 'r' || sort_field_2[1] == 'R'))
+         {
+           j = 3;
+           if (sort_field_2[0] == ' ')
+             j++;
+           memcpy(sort_field_2,sort_field_2+j,len-j);
+         }
+         if (HuSortCase)
+         {
+             l = (int) &chr_hun;
+             for (j=0;j<(len-2);j+=2)
+             {
+                 if (sort_field_1[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_1[j+2])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     sort_field_1[j+1] = ch_utfb[k];
+                     strcpy(sort_field_1+j+2,sort_field_1+j+4);
+                   }
+                 }
+                 else if (sort_field_1[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_1[j+2])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     sort_field_1[j+1] = ch_utfb[k];
+                     strcpy(sort_field_1+j+2,sort_field_1+j+4);
+                   }
+                 }
+                 else
+                 {
+                   k = (int) strstr(chr_hun, sort_field_1[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_1[j] = chr_bas[k];
+                     sort_field_1[j+1] = chr_dis[k];
+                   }
+                 }
+                 if (sort_field_2[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_2[j+2])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     sort_field_2[j+1] = ch_utfb[k];
+                     strcpy(sort_field_2+j+2,sort_field_2+j+4);
+                   }
+                 }
+                 else if (sort_field_2[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_2[j+2])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     sort_field_2[j+1] = ch_utfb[k];
+                     strcpy(sort_field_2+j+2,sort_field_2+j+4);
+                   }
+                 }
+                 else
+                 {
+                   k = (int) strstr(chr_hun, sort_field_2[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_2[j] = chr_bas[k];
+                     sort_field_2[j+1] = chr_dis[k];
+                   }
+                 }
+             }
+         }
+         else
+         {
+             l = (int) &chr_hun;
+             for (j=0;j<len;j++)
+             {
+                 if (sort_field_1[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_1[j+1])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     memcpy(sort_field_1+j+1,sort_field_1+j+2,len-(j+2));
+                   }
+                 }
+                 else if (sort_field_1[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_1[j+1])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_1[j] = ch_utfa[k];
+                     memcpy(sort_field_1+j+1,sort_field_1+j+2,len-(j+2));
+                   }
+                 }
+                 else
+                 {
+                   k = (int) strstr(chr_hun, sort_field_1[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_1[j] = chr_bas[k];
+                   }
+                 }
+                 if (sort_field_2[j] == 195)
+                 {
+                   k = -1;
+                   switch(sort_field_2[j+1])
+                   {
+                     case 129:
+                       k = 0;
+                       break;
+                     case 137:
+                       k = 1;
+                       break;
+                     case 141:
+                       k = 2;
+                       break;
+                     case 147:
+                       k = 3;
+                       break;
+                     case 150:
+                       k = 4;
+                       break;
+                     case 154:
+                       k = 6;
+                       break;
+                     case 156:
+                       k = 7;
+                       break;
+                     case 161:
+                       k = 9;
+                       break;
+                     case 169:
+                       k = 10;
+                       break;
+                     case 173:
+                       k = 11;
+                       break;
+                     case 179:
+                       k = 12;
+                       break;
+                     case 182:
+                       k = 13;
+                       break;
+                     case 186:
+                       k = 15;
+                       break;
+                     case 188:
+                       k = 16;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != -1)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     memcpy(sort_field_2+j+1,sort_field_2+j+2,len-(j+2));
+                   }
+                 }
+                 else if (sort_field_2[j] == 197)
+                 {
+                   k = 0;
+                   switch(sort_field_2[j+1])
+                   {
+                     case 144:
+                       k = 5;
+                       break;
+                     case 145:
+                       k = 14;
+                       break;
+                     case 176:
+                       k = 8;
+                       break;
+                     case 177:
+                       k = 17;
+                       break;
+                     default:
+                       break;
+                   }
+                   if (k != 0)
+                   {
+                     sort_field_2[j] = ch_utfa[k];
+                     memcpy(sort_field_2+j+1,sort_field_2+j+2,len-(j+2));
+                   }
+                 }
+                 else
+                 {
+                   k = (int) strstr(chr_hun, sort_field_2[j]);
+                   if (k>0)
+                   {
+                     k -= l;
+                     sort_field_2[j] = chr_bas[k];
+                   }
+                 }
+             }
+         }
+     }
+#else //GYMOD
+         memcpy(sort_field_2,two->line+left_col-1,right_col-left_col+1);
+#endif //GYMOD
       /*
        * If CASE IGNORE is on for the current view, set both sort fields to
        * uppercase for the comparison.
@@ -386,6 +829,10 @@
    {
       max_column_width = max(max_column_width, sort_fields[i].right_col - sort_fields[i].left_col + 1);
    }
+#ifdef GYMOD
+   if (HuSortFlag && HuSortCase)
+      max_column_width *=2;
+#endif
    /*
     * Allocate memory for each of the temporary sort fields to the length
     * of the maximum field width.
diff -Naurd a/the.c b/the.c
--- a/the.c	2013-07-26 16:09:13.000000000 +0200
+++ b/the.c	2013-07-26 16:10:02.000000000 +0200
@@ -59,7 +59,13 @@
 # ifdef UNIX
 static RETSIGTYPE handle_signal(int);
 # endif
+#ifdef GYMOD
+//#define THE_VERSION "3.3RC1"
+//#define THE_VERSION_DATE "10-July-2011"
+static void display_info(CHARTYPE *, char);
+#else //GYMOD
 static void display_info(CHARTYPE *);
+#endif //GYMOD
 static void init_signals(void);
 #else
 # ifdef UNIX
@@ -193,6 +199,10 @@
    CHARTYPE *prf_arg=(CHARTYPE *)NULL;
    CHARTYPE *local_prf=(CHARTYPE *)NULL;
    CHARTYPE *specified_prf=(CHARTYPE *)NULL;
+#ifdef GYMOD
+   CHARTYPE *specified_lsf=(CHARTYPE *)NULL;
+   CHARTYPE *specified_str=(CHARTYPE *)NULL;
+#endif //GYMOD
 
    CHARTYPE tabkey_insert='C';
    CHARTYPE tabkey_overwrite='T';
@@ -550,6 +560,9 @@
 #if defined(USE_XCURSES) && PDC_BUILD >= 2401
    strcat( mygetopt_opts, "X:" );
 #endif
+#ifdef GYMOD
+   strcat( mygetopt_opts, "vV@:f:" );
+#endif //GYMOD
    while ((c = my_getopt( my_argc, my_argv, mygetopt_opts ) ) != EOF )
    {
       switch((char)c)
@@ -736,11 +749,43 @@
             }
             break;
 #endif
+#ifdef GYMOD
+         case '@':
+            if ((specified_lsf = (CHARTYPE *)(*the_malloc)(
+                 (strlen(optarg)+1)*sizeof(CHARTYPE))) == NULL)
+            {
+              cleanup();
+              display_error(30,(CHARTYPE *)"",FALSE);
+              return(6);
+            }
+            strcpy((DEFCHAR *)specified_lsf,(DEFCHAR *)optarg);
+            break;
+         case 'f':
+            if ((specified_str = (CHARTYPE *)(*the_malloc)(
+                 (strlen(optarg)+2)*sizeof(CHARTYPE))) == NULL)
+            {
+              cleanup();
+              display_error(30,(CHARTYPE *)"",FALSE);
+              return(6);
+            }
+            if (optarg[0] == '/')
+              strcpy((DEFCHAR *)specified_str,(DEFCHAR *)"");
+            else
+              strcpy((DEFCHAR *)specified_str,(DEFCHAR *)"/");
+            strcat((DEFCHAR *)specified_str,(DEFCHAR *)optarg);
+            break;
+         case 'v':
+         case 'V':
+#endif //GYMOD
          case 'h':
          case '?':
             cleanup();
             STARTUPCONSOLE();
+#ifdef GYMOD
+            display_info((CHARTYPE *)my_argv[0], c);
+#else //GYMOD
             display_info((CHARTYPE *)my_argv[0]);
+#endif //GYMOD
             CLOSEDOWNCONSOLE();
             return(0);
             break;
@@ -1284,7 +1329,27 @@
          return(24);
       }
       current_file_name = current_file_name->next;
+#ifdef GYMOD
+      if (specified_str != NULL)
+      {
+        in_nomsg = TRUE;
+        rc = execute_locate(specified_str, FALSE, THE_NOT_SEARCH_SEMANTICS, NULL);
+        in_nomsg = FALSE;
+        if (rc == RC_OK)
+        {
+          Sos_current((CHARTYPE *)"");
+          Clocate((CHARTYPE *)specified_str);
+        }
+      }
+#endif //GYMOD
    }
+#ifdef GYMOD
+   if (specified_str != NULL)
+   {
+     (*the_free)(specified_str);
+     specified_str = NULL;
+   }
+#endif //GYMOD
    first_file_name = lll_free(first_file_name);
    /*
     * If THE has only been used to process a profile file, then exit.
@@ -1299,6 +1364,13 @@
     */
    in_profile = FALSE;
    been_interactive = TRUE;
+#ifdef GYMOD
+   if (specified_lsf != NULL)
+   {
+      Ledit(specified_lsf);
+      (*the_free)(specified_lsf);
+   }
+#endif //GYMOD
    /*
     * This is where it all happens!!!
     */
@@ -1590,19 +1662,91 @@
    return(rc);
 }
 /***********************************************************************/
+#ifdef GYMOD
+char *itoa_dj(int value, char *string, int radix)
+{
+  char tmp[33];
+  char *tp = tmp;
+  int i;
+  unsigned v;
+  int sign;
+  char *sp;
+  if (radix > 36 || radix <= 1)
+  {
+    errno = EDOM;
+    return 0;
+  }
+  sign = (radix == 10 && value < 0);
+  if (sign)
+    v = -value;
+  else
+    v = (unsigned)value;
+  while (v || tp == tmp)
+  {
+    i = v % radix;
+    v = v / radix;
+    if (i < 10)
+      *tp++ = i+'0';
+    else
+      *tp++ = i + 'a' - 10;
+  }
+  if (string == 0)
+    string = (char *)malloc((tp-tmp)+sign+1);
+  sp = string;
+  if (sign)
+    *sp++ = '-';
+  while (tp > tmp)
+    *sp++ = *--tp;
+  *sp = 0;
+  return string;
+}
+#ifdef HAVE_PROTO
+static void display_info(CHARTYPE *argv0, char opt)
+#else
+static void display_info(argv0)
+CHARTYPE *argv0;
+char opt;
+#endif
+#else //GYMOD
 #ifdef HAVE_PROTO
 static void display_info(CHARTYPE *argv0)
 #else
 static void display_info(argv0)
 CHARTYPE *argv0;
 #endif
+#endif //GYMOD
 /***********************************************************************/
 {
+#ifdef GYMOD
+   CHARTYPE rsrvd[MAX_FILE_NAME+1];
+#endif //GYMOD
    fprintf(stdout,"\nTHE %s %2s %s. All rights reserved.\n",the_version,the_release,the_copyright);
+#ifdef GYMOD
+   if (toupper(opt)=='V')
+   {
+#ifdef PDC_BUILD
+     strcpy(rsrvd, (DEFCHAR *)"PDC_????");
+     itoa_dj(PDC_BUILD, rsrvd+4, 10);
+     fprintf(stdout,"- Curses: %s\n",rsrvd);
+#endif
+#ifdef USE_REGINA
+     rexx_support = TRUE;
+     get_rexx_interpreter_version(rsrvd);
+     fprintf(stdout,"-   Rexx: %s\n",rsrvd);
+#endif
+     fprintf(stdout,"Modified: GYMOD\n");
+     fflush(stdout);
+     return;
+   }
+#endif //GYMOD
    fprintf(stdout,"THE is distributed under the terms of the GNU General Public License \n");
    fprintf(stdout,"and comes with NO WARRANTY. See the file COPYING for details.\n");
    fprintf(stdout,"\nUsage:\n\n%s [-h?nmrsbq] [-p profile] [-a profile_arg] [-l line_num] [-c col_num] [-w width] [-u display_length] [-k[fmt]] [[dir] [file [...]]]\n",argv0);
+#ifdef GYMOD
+   fprintf(stdout,"\nwhere:\n");
+#else //GYMOD
    fprintf(stdout,"\nwhere:\n\n");
+#endif //GYMOD
    fprintf(stdout,"-h,-?                  show this message\n");
    fprintf(stdout,"-n                     do not execute a profile file\n");
    fprintf(stdout,"-m                     force display into mono\n");
@@ -1621,6 +1765,11 @@
    fprintf(stdout,"-X X11_switches        X11 switches (enclosed in \"\"\n");
    fprintf(stdout,"-1[fifoname]           run in single window mode, optionally supplying FIFO name\n");
 #endif
+#ifdef GYMOD
+   fprintf(stdout,"-@ lstfile             filename of listfile for open files\n");
+   fprintf(stdout,"-f searchstring        find first occurrence of specified string\n");
+   fprintf(stdout,"-v                     output version information\n");
+#endif //GYMOD
    fprintf(stdout,"[dir [file [...]]]     file(s) and/or directory to be edited\n\n");
    fflush(stdout);
    return;
diff -Naurd a/thedefs.h b/thedefs.h
--- a/thedefs.h	2013-07-26 16:09:13.000000000 +0200
+++ b/thedefs.h	2013-07-26 16:10:02.000000000 +0200
@@ -277,6 +277,7 @@
 /* The following values can be changed to suit your needs.             */
 /*---------------------------------------------------------------------*/
 #define MAX_FILE_NAME             1000  /* maximum length of fully qualified file */
+#define MAX_COMMAND_LENGTH         150  /* maximum length of a command */
 #define MAX_LENGTH_OF_LINE        1000  /* default maximum length of a line */
 #define MAX_COMMANDS                10  /* default maximum number of commands allowed on command line */
 #define MAX_RECV                    20  /* number of lines that can be recovered */
diff -Naurd a/the.h b/the.h
--- a/the.h	2013-07-26 16:09:13.000000000 +0200
+++ b/the.h	2013-07-26 16:10:02.000000000 +0200
@@ -34,6 +34,20 @@
 */
 
 #include "thedefs.h"
+#ifdef GYMOD
+#if defined(DOS)
+# define DOS 6
+# define PDCURSES_MOUSE_ENABLED 1
+#endif
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+#if defined(CYGWIN)
+# define PDCURSES_MOUSE_ENABLED 1
+#endif
+#endif //GYMOD
+
 /*
  * Handle Win32 console when using PDCurses GUI
  */
diff -Naurd a/vars.h b/vars.h
--- a/vars.h	2013-07-26 16:09:13.000000000 +0200
+++ b/vars.h	2013-07-26 16:10:02.000000000 +0200
@@ -35,6 +35,38 @@
 
 /* Please, include the.h first. */
 
+#ifdef GYMOD
+#define F_CENTER 0
+#define F_LEFT   1
+#define F_UNJUST 2
+#define F_RIGHT  3
+#define F_TRUNC  4
+#define F_JUST   5
+#define F_1SPC   6
+#define F_TOBIN  7
+#define F_TOCHR  8
+#define F_TODEC  9
+#define F_TOHEX 10
+#define F_UNESC 11
+#define F_CRYPT 12
+/*#define F_RLE   13*/
+/*#define F_RLD   14*/
+#define F_LZE   13
+#define F_LZD   14
+#ifdef DOS
+//extern bool NoMouse; //bool!
+//extern bool MSosEdit;
+//extern bool MStatusL;
+//extern bool MDialog;
+//extern bool MPopup;
+//extern bool MPressed;
+extern bool WinClip;
+#endif
+extern bool lefttabconv;
+extern bool dialogw;
+extern bool file_list_msg;
+#endif //GYMOD
+
 /* commset1.c */
 extern the_header_mapping thm[];
 

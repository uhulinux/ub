diff -Naur orig/AUTHORS patched/AUTHORS
--- orig/AUTHORS	2007-12-22 15:12:16.000000000 +0100
+++ patched/AUTHORS	2012-08-16 15:34:36.000000000 +0200
@@ -1,9 +1,9 @@
 Actual Team :
-- Franck Tabary <franck34 at users.sourceforge.net>
-- Bart Vanbrabant <zoeloelip at users.sourceforge.net>
-- Hans Rakers <hrak at users.sourceforge.net>
+- Hans Rakers <hans at rakers dot org>
 
 Inactive member(s) :
+- Bart Vanbrabant <bart at vanbrabant dot eu>
+- Franck Tabary <franck34 at users.sourceforge.net>
 - Everaldo Canuto <everaldo_canuto at users.sourceforge.net>
 - Reiner Jung  <reinerj at users.sourceforge.net>  
 - Shin Seung Woo <segv74 at users.sourceforge.net>
@@ -13,7 +13,7 @@
 Aidan Lister <aidan [ett] php [dutt] net> - The PHP_Highlight.php script
 
 Contributors:
-Thomas Love <tomlove@gmail.com> - The new control panel
+Thomas Love <tomlove at gmail dot com> - The new control panel
 
 eAccelerator is based on Turck MMCache, written by
   Dmitry Stogov <dstogov at users.sourceforge.net>
diff -Naur orig/ChangeLog patched/ChangeLog
--- orig/ChangeLog	2010-05-31 22:21:14.000000000 +0200
+++ patched/ChangeLog	2012-08-16 15:34:36.000000000 +0200
@@ -1,141 +1,258 @@
-2010-05-31  Bart Vanbrabant <bart at vanbrabant.eu>
-		
-		* Release version 0.9.6.1
-		* php_check_open_basedir only needs to be called when restoring
+2012-08-16  Hans Rakers <hans at rakers.org>
+
+	* Remove current memory protection implementation. This code has
+	  been dead for a while now
+	* Re-enabled some EQUAL/NOT_EQUAL optimisations in the optimizer
+	* Removed duplicate macro CONSTANT() and rewrote all its occurances
+	  to OPx_CONST
+	* Removed old code related to BRK/CONT handling
+	* Some cosmetic fixes to optimize.c
+
+2012-08-13  Hans Rakers <hans at rakers.org>
+
+	* Fixed CONCAT/ADD_STRING + ADD_CHAR optimizer bug
+	* Removed unused var in reassign_registers
+
+2012-08-10  Hans Rakers <hans at rakers.org>
+
+	* Small tweaks to the disassembler:
+	  - Display zval properly ignoring all non-relevant extra flags
+	    possible on zval type (>=php-5.3)
+	  - display op1 properly on FETCH_CONSTANT and
+	    INIT_STATIC_METHOD_CALL (>=php 5.4)
+
+2012-08-08  Hans Rakers <hans at rakers.org>
+
+	* Fixed a longstanding issue regarding exceptions in the optimizer.
+	  The optimizer removed try/catch blocks resulting in exceptions not
+	  being caught.
+
+	  This also solves Drupal 7 installation issues when using eAccelerator
+	  (tested with Drupal 7.15 and PHP 5.4.5)
+	* Update Win32 VC project files
+	* Fixed several Win32 compilation issues, thanks @tengattack
+
+2012-08-06  Hans Rakers <hans at rakers.org>
+
+	* Fixed memory leaks in restore_hash() and the optimizer
+	* Fixed several issues in the optimizer related to result type
+	  checking / setting (PHP 5.4 uses op.result_type for both result
+	  type and 'result used mask' instead of two seperate values)
+	* Fixed displaying of function/method names in the disassembler
+	* Fixed handling of fetch ops by the optimizer and the disassembler
+
+2012-07-30  Hans Rakers <hans at rakers.org>
+
+	* Fixed open_basedir issues as reported on the old Trac site
+	* Removed key/value store and session handler bits from config.w32
+	  and added doc-comment-inclusion. Win32 project files also need
+	  updating but i currently don't have a win32 development station
+	* Fixed segfault in store_default_property_access_check when
+	  compiled with -O2 and removed unused vars
+	* Fixed a very stupid bug in restore_class_parent
+	* Rewrote the spinlock implementation. This hopefully takes care of
+	  deadlock issues reported on the old Trac site.
+	* Removed some excessive debug output
+
+2012-07-26  Hans Rakers <hans at rakers.org>
+
+	* fixed compilation of ea_dasm.c against php < 5.4
+	* fixed handling of hashes for php < 5.4
+	* disabled MM_CHECK by default because it is broken and causes segfaults when
+	  shared memory is exhausted (debug builds only).
+
+2012-07-19  Hans Rakers <hans at rakers.org>
+
+	* PHP-5.4 compatibility
+	* Fixed a segfault when restoring class doc comments from
+	  disk cache
+	* Storing doc comments in cache is default now since most
+	  frameworks require this (Reflection API).
+	* Re-indented all files using astyle and bumped year
+
+2010-07-28  Bart Vanbrabant <bart at vanbrabant.eu>
+
+	* Make the error message about creating the cache directory more
+	  clear.
+
+2010-07-26  Hans Rakers <hans at react.nl>
+
+	* Fix for ticket #432. The optimizer would eliminate the final
+	  ZEND_RETURN of an op array if the script ended with a switch
+	  statement. Last opcodes ZEND_BRK, ZEND_JMP, ZEND_JMP,
+	  ZEND_RETURN. ZEND_BRK gets optimized to a JMP, which is a JMP
+	  to RETURN so gets eliminated. Other 2 JMPs get eliminated,
+	  RETURN loses all predecessors, and thus gets eliminated aswell,
+	  resulting in a crash. Problem ended up being in the handling of
+	  the ZEND_BRK to ZEND_JMP optimization. /long story
+
+2010-07-11  Bart Vanbrabant <bart@vanbrabant.eu>
+
+	* Changed the way the cache directory is created:
+	- The forked process creates the cache dir and makes it world writable
+	- The first request creates a subdir with the userid of the process and
+	with permissions 700.
+
+	* Comment out an unused function to support compilin with -Werror
+	* Add sched.h include to fix a compiler warning
+
+2010-06-03  Hans Rakers <hans at react.nl>
+
+	* Fixed compilation against php-5.1. This closes ticket #426.
+
+2010-02-25  Hans Rakers <hans at react.nl>
+
+	* Fixed class static variable restore where parent was protected
+	  static and child was public static. This would lead to error
+	  'Access to undeclared static property' upon restore from cache
+	* Added proper handling of class properties during storing in
+	  cache. Public/private/protected is properly handled now. Somehow
+	  this was a long overdue TODO spotted by running the testsuite.
+	  This fixes ticket #408
+	* Small fix that solves some issues with lambda (closure)
+	  functions. This solves ticket #405
+
+2010-02-24  Hans Rakers <hans at react.nl>
+
+	* Fixed double free in eaccelerator_globals_dtor. This closes
+	  ticket #404
 
-2010-02-25	Hans Rakers <hans at react.nl>
+2010-02-18  Hans Rakers <hans at react.nl>
 
-		* Fixed class static variable restore where parent was protected
-		  static and child was public static. This would lead to error
-		  'Access to undeclared static property' upon restore from cache
-		* Added proper handling of class properties during storing in
-		  cache. Public/private/protected is properly handled now. Somehow
-		  this was a long overdue TODO spotted by running the testsuite.
-		  This fixes ticket #408
-		* Small fix that solves some issues with lambda (closure)
-		  functions. This solves ticket #405
+	* Remove some leftover debug output that broke compilation with
+	  php-5.2 and --with-eaccelerator-debug
+	* php_check_open_basedir only needs to be called when restoring
 
-2010-02-24	Hans Rakers <hans at react.nl>
+2010-02-04  Hans Rakers <hans at react.nl>
 
-		* Fixed double free in eaccelerator_globals_dtor. This closes
-		  ticket #404
+	* Fixed linking of ZEND_DECLARE_INHERITED_CLASS_DELAYED across
+	  bb's in the optimizer. This fixes bug #399
 
-2010-02-18	Hans Rakers <hans at react.nl>
+2010-02-04  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Remove some leftover debug output that broke compilation with
-		  php-5.2 and --with-eaccelerator-debug
+	* Remove some leftovers from the lock api
+	* Now really add the sched_yield command and not only in commented
+	  out
 
-2010-02-04	Bart Vanbrabant <bart at vanbrabant.eu>
+2010-02-03  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Now really add the sched_yield command and not only in commented out
-		* Bump version to 0.9.6
+	* Include the resolve path function from php so it is available for
+	  older PHP versions as well. Includes that start file:// work now.
+	* Enable phar caching: Files in included from a phar file are cached
+	  now. The phar archive is used to excute the stat on.
+	* Enable check_mtime usage again
+	* Use snprintf the right way. See #290
+	* Add a call to sched_yield after a failed spinlock to prevent
+	  deadlock conditions. This should fix #381 and is a real fix for #340.
+	  Instead of using a fake select as yield, a check is added to disable
+	  spinlocks on systems that do not have sched_yield.
+	* Fix spinlocks on Solaris with Sun Compiler. #325
 
-2010-02-04	Hans Rakers <hans at react.nl>
+2010-02-02  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Fixed linking of ZEND_DECLARE_INHERITED_CLASS_DELAYED across
-		  bb's in the optimizer. This fixes bug #399
+	* Fix two compiler warnings
 
-2010-02-03	Bart Vanbrabant <bart at vanbrabant.eu>
+2010-02-01  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Use snprintf the right way. See #290
-		* Add a call to sched_yield after a failed spinlock to prevent
-		deadlock conditions. This should fix #381 and is a real fix for #340.
-		Instead of using a fake select as yield, a check is added to disable
-		spinlocks on systems that do not have sched_yield.
-		* Fix spinlocks on Solaris with Sun Compiler. #325
+	* A retab on eaccelerator.c
+	* Remove caching based on inodes
+	* Reimplement eaccelerator_stat to speed it up: the new ea_stat is
+	  almost twice as fast as the old version with inodes. The tests were
+	  done on a file that includes 10k empty files.
+	* Increment version to 1.0-dev
 
-2010-01-22	Bart Vanbrabant <bart at vanbrabant.eu>
+2010-01-22  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Release 0.9.6-rc2
+	* Release 0.9.6-rc2
 
-2010-01-21	Hans Rakers <hans at react.nl>
+2010-01-21  Hans Rakers <hans at react.nl>
 
-		* Set op_array->early_binding in a later stage.
-		  This fixes ticket #394
+	* Set op_array->early_binding in a later stage.
+	  This fixes ticket #394
 
-2010-01-20	Hans Rakers <hans at react.nl>
+2010-01-20  Hans Rakers <hans at react.nl>
 
-		* Some more work on delayed early binding. This fixes
-		  ticket #388
-		* Some reformatting in ea_dasm.c
-		* Win32 VC6 project file updated
+	* Some more work on delayed early binding. This fixes
+	  ticket #388
+	* Some reformatting in ea_dasm.c
+	* Win32 VC6 project file updated
 
-2010-01-19	Bart Vanbrabant <bart at vanbrabant.eu>
+2010-01-19  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Remove obsolete documentation
-		* Update year in copyright
+	* Remove obsolete documentation
+	* Update year in copyright
 
-2010-01-19	Hans Rakers <hans at react.nl>
+2010-01-19  Hans Rakers <hans at react.nl>
 
-		* Implemented ZEND_GOTO
-		* Implemented delayed early binding for php-5.3. This
-		  solves ticket #146 (Problems with require_once with
-		  circular dependencies) for everyone using php-5.3.
-		  See http://marc.info/?l=php-internals&m=120539866910125&w=2
-		  for more info on this.
-		* Fixed ticket #386 (Crash using const & php-5.3)
-		* Fixed a bunch of other php-5.3 related issues found by
-		  using the test suite and all php-5.3 Zend engine tests
-		* Win32 project files updated
-		* Win32 ZTS fixes
+	* Implemented ZEND_GOTO
+	* Implemented delayed early binding for php-5.3. This
+	  solves ticket #146 (Problems with require_once with
+	  circular dependencies) for everyone using php-5.3.
+	  See http://marc.info/?l=php-internals&m=120539866910125&w=2
+	  for more info on this.
+	* Fixed ticket #386 (Crash using const & php-5.3)
+	* Fixed a bunch of other php-5.3 related issues found by
+	  using the test suite and all php-5.3 Zend engine tests
+	* Win32 project files updated
+	* Win32 ZTS fixes
 
-2009-12-23	Hans Rakers <hans at react.nl>
+2009-12-23  Hans Rakers <hans at react.nl>
 
-		* Fixed ticket #383 (crash on ZEND_ADD_INTERFACE)
-		* check_mtime can now be enabled/disabled through the web
-		  interface as requested in ticket #32
-		* Shortened some variable names
-		* ZEND_JMP_SET support
+	* Fixed ticket #383 (crash on ZEND_ADD_INTERFACE)
+	* check_mtime can now be enabled/disabled through the web
+	  interface as requested in ticket #32
+	* Shortened some variable names
+	* ZEND_JMP_SET support
 
-2009-12-01	Hans Rakers <hans at react.nl>
+2009-12-01  Hans Rakers <hans at react.nl>
 
-		* Win32 compilation fixes (compiles in VC++ 2008)
-		* Updated VC++ project file to VC++ 2008 format
+	* Win32 compilation fixes (compiles in VC++ 2008)
+	* Updated VC++ project file to VC++ 2008 format
 
-2009-11-30	Hans Rakers <hans at react.nl>
+2009-11-30  Hans Rakers <hans at react.nl>
 
-		* Added a whole bunch of standard functions to
-		  opt_result_is_numeric()
-		* init allocated memblocks with memset instead of a for loop
-		  in reassign_registers()
-		* Fix in build_cfg for PHP 5.3 UCLASS znodes. These are
-		  handled differently in 5.3 due to namespaces.
-		* Some tweaks and additions to ea_dasm.c
-		* Some quick and dirty tweaks to dasm.php to sync looks with
-		  control.php
-		* Fixed ordering of table columns in control.php. This solves
-		  ticket #364
+	* Added a whole bunch of standard functions to
+	  opt_result_is_numeric()
+	* init allocated memblocks with memset instead of a for loop
+	  in reassign_registers()
+	* Fix in build_cfg for PHP 5.3 UCLASS znodes. These are
+	  handled differently in 5.3 due to namespaces.
+	* Some tweaks and additions to ea_dasm.c
+	* Some quick and dirty tweaks to dasm.php to sync looks with
+	  control.php
+	* Fixed ordering of table columns in control.php. This solves
+	  ticket #364
 
-2009-11-25	Hans Rakers <hans at react.nl>
+2009-11-25  Hans Rakers <hans at react.nl>
 
-		* Optimizer and general PHP 5.3 fixes
-		* Some cleanups
+	* Optimizer and general PHP 5.3 fixes
+	* Some cleanups
 
-2009-11-11	Bart Vanbrabant <bart at vanbrabant.eu>
+2009-11-11  Bart Vanbrabant <bart at vanbrabant.eu>
 
-		* Add the optimizer back
+	* Add the optimizer back
 
-2009-11-11	Hans Rakers <hans at react.nl>
+2009-11-11  Hans Rakers <hans at react.nl>
 
-		* PHP 5.3 ZEND_JMP_SET support. Fixes ticket #371
-		* open_basedir bypass fixed. Fixes ticket #104
-		* Fix for ticket #194
-		* Stripped old opcodes from opcode.c and added new ones
+	* PHP 5.3 ZEND_JMP_SET support. Fixes ticket #371
+	* open_basedir bypass fixed. Fixes ticket #104
+	* Fix for ticket #194
+	* Stripped old opcodes from opcode.c and added new ones
 
-2009-07-14	Bart Vanbrabant <bart at vanbrabant.eu>
+2009-07-14  Bart Vanbrabant <bart at vanbrabant.eu>
 	
-		* Fix two PHP 5.3 bugs
-		* Remove the optimizer
-		* Remove the user cache functions
-
-2009-05-06	Bart Vanbrabant <bart at vanbrabant.eu>
-
-		* Remove code that is only needed for php < 5
-		* Rebase to code to minimal PHP 5.1
-		* Update support for PHP 5.3
-		* Remove have_sched_yield check in config.m4. This is not used
-		  anywhere and and causes some compilation errors.
-		* Apply patch from ticket [324]
+	* Fix two PHP 5.3 bugs
+	* Remove the optimizer
+	* Remove the user cache functions
+
+2009-05-06  Bart Vanbrabant <bart at vanbrabant.eu>
+
+	* Remove code that is only needed for php < 5
+	* Rebase to code to minimal PHP 5.1
+	* Update support for PHP 5.3
+	* Remove have_sched_yield check in config.m4. This is not used
+	  anywhere and and causes some compilation errors.
+	* Apply patch from ticket [324]
 
 2008-06-20  Bart Vanbrabant <bart.vanbrabant at zoeloelip.be>
 
@@ -150,11 +267,11 @@
 2008-06-18  Bart Vanbrabant <bart.vanbrabant at zoeloelip.be>
 	
         * Add patch from ticket 232: removes an unlock that isn't
-		  needed there.
+	  needed there.
 
 2008-02-12  Bart Vanbrabant <bart.vanbrabant at zoeloelip.be>
 		
-		* Add new opcodes introduced in PHP 5.3
+	* Add new opcodes introduced in PHP 5.3
 
 2007-08-20  Hans Rakers <hans at react.nl>
 
diff -Naur orig/config.m4 patched/config.m4
--- orig/config.m4	2009-11-11 14:20:35.000000000 +0100
+++ patched/config.m4	2012-08-16 15:34:36.000000000 +0200
@@ -19,14 +19,14 @@
 [  --enable-eaccelerator                    Enable eaccelerator support])
 
 AC_ARG_WITH(eaccelerator-crash-detection,
-[  --without-eaccelerator-crash-detection   Do not include eaccelerator crash detection],[
+[  --without-eaccelerator-crash-detection   Do not include eAccelerator crash detection],[
   eaccelerator_crash_detection=$withval
 ],[
   eaccelerator_crash_detection=yes
 ])
 
 AC_ARG_WITH(eaccelerator-optimizer,
-[  --without-eaccelerator-optimizer         Do not include eaccelerator optimizer],[
+[  --without-eaccelerator-optimizer         Do not include the eAccelerator optimizer],[
   eaccelerator_optimizer=$withval
 ],[
   eaccelerator_optimizer=yes
@@ -39,6 +39,13 @@
   eaccelerator_info=yes
 ])
 
+AC_ARG_WITH(eaccelerator-doc-comment-inclusion,
+[  --without-eaccelerator-doc-comment-inclusion  If you want eAccelerator to strip doc-comments from internal php structures.],[
+    enable_doc_comment_inclusion=$withval
+],[
+    enable_doc_comment_inclusion=yes
+])
+
 AC_ARG_WITH(eaccelerator-disassembler,
 [  --with-eaccelerator-disassembler         Include disassembler],[
   eaccelerator_disassembler=$withval
@@ -46,15 +53,8 @@
   eaccelerator_disassemmbler=no
 ])
 
-AC_ARG_WITH(eaccelerator-use-inode,
-[  --without-eaccelerator-use-inode         Don't use inodes to determine hash keys (never used on win32)],[
-  eaccelerator_inode=$withval
-],[
-  eaccelerator_inode=yes
-])
-
 AC_ARG_WITH(eaccelerator-debug,
-[  --with-eaccelerator-debug                Enable the debug code so eaccelerator logs verbose.],[
+[  --with-eaccelerator-debug                Enable the debug code so eAccelerator logs verbose.],[
   eaccelerator_debug=$withval
 ],[
   eaccelerator_debug=no
@@ -67,13 +67,6 @@
   ea_userid=0
 ])
 
-AC_ARG_WITH(eaccelerator-doc-comment-inclusion,
-[  --with-eaccelerator-doc-comment-inclusion  If you want eAccelerator to retain doc-comments in  internal php structures.],[
-    enable_doc_comment_inclusion=$withval
-],[
-    enable_doc_comment_inclusion=no
-])
-
 dnl PHP_BUILD_SHARED
 if test "$PHP_EACCELERATOR" != "no"; then
   PHP_EXTENSION(eaccelerator, $ext_shared)
@@ -95,9 +88,6 @@
   if test "$eaccelerator_disassembler" = "yes"; then
     AC_DEFINE(WITH_EACCELERATOR_DISASSEMBLER, 1, [Define if you like to explore Zend bytecode])
   fi
-  if test "$eaccelerator_inode" = "yes"; then
-    AC_DEFINE(WITH_EACCELERATOR_USE_INODE, 1, [Undef if you don't wan't to use inodes to determine hash keys])
-  fi
   if test "$eaccelerator_debug" = "yes"; then
     AC_DEFINE(DEBUG, 1, [Undef when you want to enable eaccelerator debug code])
   fi
@@ -318,10 +308,7 @@
   fi
   AC_MSG_RESULT([$msg])
   if test "$msg" = "no" ; then
-    AC_MSG_ERROR([eaccelerator cannot semaphores type, which is required])
+    AC_MSG_ERROR([eaccelerator cannot determine semaphore type, which is required])
   fi
 
-  AC_CHECK_FUNC(mprotect,[
-      AC_DEFINE(HAVE_MPROTECT, 1, [Define if ou have mprotect function])
-    ])
 fi
diff -Naur orig/control.php patched/control.php
--- orig/control.php	2010-01-19 16:49:13.000000000 +0100
+++ patched/control.php	2012-08-16 15:34:36.000000000 +0200
@@ -3,7 +3,7 @@
    	+-----------------------------------------------------------------------+
    	| eAccelerator control panel                                           	|
    	+-----------------------------------------------------------------------+
-   	| Copyright (c) 2004-2010 eAccelerator                                 	|
+   	| Copyright (c) 2004-2012 eAccelerator                                 	|
 	| http://eaccelerator.net                                              	|
    	+-----------------------------------------------------------------------+
    	| This source file is subject to version 3.0 of the PHP license,       	|
@@ -14,6 +14,8 @@
 	| obtain it through the world-wide-web, please send a note to          	|
 	| license@php.net so we can mail you a copy immediately.             	|
 	+-----------------------------------------------------------------------+
+
+	$Id: $
 */
 
 /*** CONFIG ***/
diff -Naur orig/dasm.php patched/dasm.php
--- orig/dasm.php	2010-01-19 16:49:13.000000000 +0100
+++ patched/dasm.php	2012-08-16 15:34:36.000000000 +0200
@@ -3,8 +3,8 @@
    +----------------------------------------------------------------------+
    | eAccelerator control panel                                           |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004-2010 eAccelerator								  |
-   | http://eaccelerator.net											  |
+   | Copyright (c) 2004-2012 eAccelerator                                 |
+   | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This source file is subject to version 2.00 of the Zend license,     |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -15,7 +15,7 @@
    | license@zend.com so we can mail you a copy immediately.              |
    +----------------------------------------------------------------------+
 
-   $ Id: $
+   $Id: $
 
 /** config **/
 $auth = true;		// Set to false to disable authentication
diff -Naur orig/debug.c patched/debug.c
--- orig/debug.c	2010-01-19 16:49:13.000000000 +0100
+++ patched/debug.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -44,8 +44,9 @@
 void ea_debug_init (TSRMLS_D)
 {
     F_fp = fopen (EAG(ea_log_file), "a");
-    if (!F_fp)
+    if (!F_fp) {
         F_fp = stderr;
+    }
     file_no = fileno(F_fp);
 }
 
@@ -55,8 +56,9 @@
 void ea_debug_shutdown ()
 {
     fflush (F_fp);
-    if (F_fp != stderr)
+    if (F_fp != stderr) {
         fclose (F_fp);
+    }
     F_fp = NULL;
 }
 
@@ -76,12 +78,12 @@
         va_end (args);
 
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_EX);
+            EACCELERATOR_FLOCK(file_no, LOCK_EX);
         }
         fputs (output_buf, F_fp);
         fflush (F_fp);
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_UN);
+            EACCELERATOR_FLOCK(file_no, LOCK_UN);
         }
     }
 }
@@ -103,7 +105,7 @@
     fflush (stderr);
 }
 
-/* 
+/*
  * All these functions aren't compiled when eA isn't compiled with DEBUG. They
  * are replaced with function with no body, so it's optimized away by the compiler.
  * Even if the debug level is ok.
@@ -121,14 +123,14 @@
         va_start (args, format);
         vsnprintf (output_buf, sizeof (output_buf), format, args);
         va_end (args);
-        
+
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_EX);
+            EACCELERATOR_FLOCK(file_no, LOCK_EX);
         }
         fputs (output_buf, F_fp);
         fflush (F_fp);
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_UN);
+            EACCELERATOR_FLOCK(file_no, LOCK_UN);
         }
     }
 }
@@ -140,12 +142,12 @@
 {
     if (debug_level & ea_debug) {
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_EX);
+            EACCELERATOR_FLOCK(file_no, LOCK_EX);
         }
         fputs (message, F_fp);
         fflush (F_fp);
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_UN);
+            EACCELERATOR_FLOCK(file_no, LOCK_UN);
         }
     }
 }
@@ -153,19 +155,24 @@
 /**
  * Print a binary message
  */
-void ea_debug_binary_print (long debug_level, char *p, int len)
+void ea_debug_binary_print (long debug_level, const char *p, int len)
 {
     if (ea_debug & debug_level) {
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_EX);
+            EACCELERATOR_FLOCK(file_no, LOCK_EX);
         }
         while (len--) {
-            fputc (*p++, F_fp);
+            if (*p == 0) {
+                fputs ("\\0", F_fp);
+            } else {
+                fputc (*p, F_fp);
+            }
+            p++;
         }
         fputc ('\n', F_fp);
         fflush (F_fp);
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_UN);
+            EACCELERATOR_FLOCK(file_no, LOCK_UN);
         }
     }
 }
@@ -182,7 +189,7 @@
         b = ht->pListHead;
 
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_EX);
+            EACCELERATOR_FLOCK(file_no, LOCK_EX);
         }
         fputs(p, F_fp);
         fflush(F_fp);
@@ -194,7 +201,7 @@
             i++;
         }
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_UN);
+            EACCELERATOR_FLOCK(file_no, LOCK_UN);
         }
     }
 }
@@ -206,16 +213,16 @@
 {
 #ifdef DEBUG /* This ifdef is still req'd because xpad is N/A in a non-debug compile */
     if (ea_debug & debug_level) {
-		int i;
+        int i;
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_EX);
+            EACCELERATOR_FLOCK(file_no, LOCK_EX);
         }
         i = EAG (xpad);
         while (i-- > 0) {
             fputc ('\t', F_fp);
         }
         if (F_fp != stderr) {
-        	EACCELERATOR_FLOCK(file_no, LOCK_UN);
+            EACCELERATOR_FLOCK(file_no, LOCK_UN);
         }
     }
 #endif
@@ -241,21 +248,21 @@
  */
 void ea_debug_hash_display(HashTable * ht)
 {
-	Bucket *p;
-	uint i;
+    Bucket *p;
+    uint i;
 
-	fprintf(F_fp, "ht->nTableSize: %d\n", ht->nTableSize);
-	fprintf(F_fp, "ht->nNumOfElements: %d\n", ht->nNumOfElements);
+    fprintf(F_fp, "ht->nTableSize: %d\n", ht->nTableSize);
+    fprintf(F_fp, "ht->nNumOfElements: %d\n", ht->nNumOfElements);
 
-	for (i = 0; i < ht->nTableSize; i++) {
-		p = ht->arBuckets[i];
-		while (p != NULL) {
-			fprintf(F_fp, "\t%s <==> 0x%lX\n", p->arKey, p->h);
-			p = p->pNext;
-		}
-	}
+    for (i = 0; i < ht->nTableSize; i++) {
+        p = ht->arBuckets[i];
+        while (p != NULL) {
+            fprintf(F_fp, "\t%s <==> 0x%lX\n", p->arKey, p->h);
+            p = p->pNext;
+        }
+    }
 
-	fflush(F_fp);
+    fflush(F_fp);
 }
 
 /*
@@ -267,10 +274,15 @@
     fprintf(F_fp, "\tparent: '%s'\n", ce->parent);
     fprintf(F_fp, "\ttype: %d\n", ce->type);
     fprintf(F_fp, "\tfunction_table: %u entries\n", ce->function_table.nNumOfElements);
-    fprintf(F_fp, "\tdefault_properties: %u entries\n", ce->default_properties.nNumOfElements);
     fprintf(F_fp, "\tproperties_info: %u entries\n", ce->properties_info.nNumOfElements);
+#ifdef ZEND_ENGINE_2_4
+    fprintf(F_fp, "\tdefault_properties: %u entries\n", ce->default_properties_count);
+    fprintf(F_fp, "\tdefault_static_members: %u entries\n", ce->default_static_members_count);
+#else
+    fprintf(F_fp, "\tdefault_properties: %u entries\n", ce->default_properties.nNumOfElements);
     fprintf(F_fp, "\tdefault_static_members: %u entries\n", ce->default_static_members.nNumOfElements);
     fprintf(F_fp, "\tstatic_members: %u entries\n", ce->static_members->nNumOfElements);
+#endif
     fprintf(F_fp, "\tconstants_Table: %u entries\n", ce->constants_table.nNumOfElements);
     fprintf(F_fp, "\tce_flags: %u\n", ce->ce_flags);
     fprintf(F_fp, "\tnum_interfaces: %u\n", ce->num_interfaces);
@@ -293,21 +305,46 @@
     fprintf(F_fp, "\tparent: '%s'\n", (ce->parent == NULL) ? "none" : ce->parent->name);
     fprintf(F_fp, "\ttype: %d\n", ce->type);
     fprintf(F_fp, "\tfunction_table: %u entries\n", ce->function_table.nNumOfElements);
-    fprintf(F_fp, "\tdefault_properties: %u entries\n", ce->default_properties.nNumOfElements);
     fprintf(F_fp, "\tproperties_info: %u entries\n", ce->properties_info.nNumOfElements);
+#  ifdef ZEND_ENGINE_2_4
+    fprintf(F_fp, "\tdefault_properties: %u entries\n", ce->default_properties_count);
+    fprintf(F_fp, "\tdefault_static_members: %u entries\n", ce->default_static_members_count);
+#  else
+    fprintf(F_fp, "\tdefault_properties: %u entries\n", ce->default_properties.nNumOfElements);
     fprintf(F_fp, "\tdefault_static_members: %u entries\n", ce->default_static_members.nNumOfElements);
     fprintf(F_fp, "\tstatic_members: %u entries\n", ce->static_members->nNumOfElements);
+#  endif
     fprintf(F_fp, "\tconstants_Table: %u entries\n", ce->constants_table.nNumOfElements);
     fprintf(F_fp, "\tce_flags: %u\n", ce->ce_flags);
     fprintf(F_fp, "\tnum_interfaces: %u\n", ce->num_interfaces);
+#  ifdef ZEND_ENGINE_2_4
+    fprintf(F_fp, "\tfilename: %s\n", ce->info.user.filename);
+    fprintf(F_fp, "\tline_start: %u\n", ce->info.user.line_start);
+    fprintf(F_fp, "\tline_end: %u\n", ce->info.user.line_end);
+#  else
     fprintf(F_fp, "\tfilename: %s\n", ce->filename);
     fprintf(F_fp, "\tline_start: %u\n", ce->line_start);
     fprintf(F_fp, "\tline_end: %u\n", ce->line_end);
+#  endif
 #  ifdef INCLUDE_DOC_COMMENTS
+#    ifdef ZEND_ENGINE_2_4
+    fprintf(F_fp, "\tdoc_comment: %s\n", ce->info.user.doc_comment);
+    fprintf(F_fp, "\tdoc_comment_len: %u\n", ce->info.user.doc_comment_len);
+#    else
     fprintf(F_fp, "\tdoc_comment: %s\n", ce->doc_comment);
     fprintf(F_fp, "\tdoc_comment_len: %u\n", ce->doc_comment_len);
+#    endif
 #  endif
     fflush(F_fp);
 }
 
 #endif /* #ifdef HAVE_EACCELERATOR */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim>600: expandtab sw=4 ts=4 sts=4 fdm=marker
+ * vim<600: expandtab sw=4 ts=4 sts=4
+ */
diff -Naur orig/debug.h patched/debug.h
--- orig/debug.h	2010-01-19 16:49:13.000000000 +0100
+++ patched/debug.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -58,9 +58,9 @@
 /* print information about the file that's loaded or cached */
 #define EA_LOG	 		(1<<0L)
 
-/* print debugging information, mostly about the storing and restoring of a 
+/* print debugging information, mostly about the storing and restoring of a
  * script's data structures. Gives you detailed information about what eA is
- * doing 
+ * doing
  */
 #define EA_DEBUG		(1<<1L)
 
@@ -79,7 +79,7 @@
 void ea_debug_error (char *format, ...);
 void ea_debug_pad (long debug_level TSRMLS_DC);
 void ea_debug_log (char *format, ...);
-void ea_debug_binary_print (long debug_level, char *p, int len);
+void ea_debug_binary_print (long debug_level, const char *p, int len);
 void ea_debug_put (long debug_level, char *message);
 void ea_debug_log_hashkeys (char *p, HashTable * ht);
 
@@ -91,3 +91,12 @@
 void ea_debug_dump_zend_class_entry(zend_class_entry *ce);
 
 #endif /* INCLUDED_DEBUG_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim>600: expandtab sw=4 ts=4 sts=4 fdm=marker
+ * vim<600: expandtab sw=4 ts=4 sts=4
+ */
diff -Naur orig/eaccelerator.c patched/eaccelerator.c
--- orig/eaccelerator.c	2010-05-31 22:21:14.000000000 +0200
+++ patched/eaccelerator.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id: eaccelerator.c 415 2010-05-31 20:21:14Z bart $
+   $Id: eaccelerator.c 426 2010-07-28 09:41:24Z bart $
 */
 
 #include "eaccelerator.h"
@@ -78,13 +78,12 @@
 
 /* Globals (common for each process/thread) */
 static long ea_shm_size = 0;
-long ea_shm_max = 0;
 static long ea_shm_ttl = 0;
 static long ea_shm_prune_period = 0;
 extern long ea_debug;
 zend_bool ea_scripts_shm_only = 0;
 
-eaccelerator_mm* ea_mm_instance = NULL;
+eaccelerator_mm *ea_mm_instance = NULL;
 static int ea_is_zend_extension = 0;
 static int ea_is_extension      = 0;
 zend_extension* ZendOptimizer = NULL;
@@ -119,197 +118,177 @@
 static ea_cache_entry* hash_find_mm(const char  *key,
                                     struct stat *buf,
                                     int         *nreloads,
-                                    time_t      ttl TSRMLS_DC) {
-  unsigned int hv, slot;
-  ea_cache_entry *p, *q;
+                                    time_t      ttl TSRMLS_DC)
+{
+    unsigned int hv, slot;
+    ea_cache_entry *p, *q;
 
-#ifdef EACCELERATOR_USE_INODE
-  hv = buf->st_dev + buf->st_ino;
-#else
-  hv = zend_get_hash_value((char *)key, strlen(key));
-#endif
-  slot = hv & EA_HASH_MAX;
+    hv = zend_get_hash_value((char *)key, strlen(key));
+    slot = hv & EA_HASH_MAX;
 
-  EACCELERATOR_LOCK_RW();
-  q = NULL;
-  p = ea_mm_instance->hash[slot];
-  while (p != NULL) {
-#ifdef EACCELERATOR_USE_INODE
-    if (p->st_dev == buf->st_dev && p->st_ino == buf->st_ino) {
-      struct stat buf2;
-      if ((EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled &&
-          (buf->st_mtime != p->mtime || buf->st_size != p->filesize)) ||
-          (strcmp(p->realfilename, key) != 0 &&
-           (stat(p->realfilename,&buf2) != 0 ||
-           buf2.st_dev != buf->st_dev ||
-           buf2.st_ino != buf->st_ino))) {
-#else
-    if ((p->hv == hv) && (strcmp(p->realfilename, key) == 0)) {
-      if (EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled &&
-          (buf->st_mtime != p->mtime || buf->st_size != p->filesize)) {
-#endif
-        /* key is invalid. Remove it. */
-        *nreloads = p->nreloads+1;
-        if (q == NULL) {
-          ea_mm_instance->hash[slot] = p->next;
-        } else {
-          q->next = p->next;
+    EACCELERATOR_LOCK_RW();
+    q = NULL;
+    p = ea_mm_instance->hash[slot];
+    while (p != NULL) {
+        if ((p->hv == hv) && (strcmp(p->realfilename, key) == 0)) {
+            if (EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled &&
+                    (buf->st_mtime != p->mtime || buf->st_size != p->filesize)) {
+                /* key is invalid. Remove it. */
+                *nreloads = p->nreloads+1;
+                if (q == NULL) {
+                    ea_mm_instance->hash[slot] = p->next;
+                } else {
+                    q->next = p->next;
+                }
+                ea_mm_instance->hash_cnt--;
+                if (p->use_cnt > 0) {
+                    /* key is used by other process/thread. Schedule it for removal */
+                    p->removed = 1;
+                    p->next = ea_mm_instance->removed;
+                    ea_mm_instance->removed = p;
+                    ea_mm_instance->rem_cnt++;
+                    EACCELERATOR_UNLOCK_RW();
+                    return NULL;
+                } else {
+                    /* key is unused. Remove it. */
+                    eaccelerator_free_nolock(p);
+                    EACCELERATOR_UNLOCK_RW();
+                    return NULL;
+                }
+            } else {
+                /* key is valid */
+                p->nhits++;
+                p->use_cnt++;
+                p->ttl = ttl;
+                EACCELERATOR_UNLOCK_RW();
+                return p;
+            }
         }
-        ea_mm_instance->hash_cnt--;
-        if (p->use_cnt > 0) {
-          /* key is used by other process/thread. Schedule it for removal */
-          p->removed = 1;
-          p->next = ea_mm_instance->removed;
-          ea_mm_instance->removed = p;
-          ea_mm_instance->rem_cnt++;
-          EACCELERATOR_UNLOCK_RW();
-          return NULL;
-        } else {
-          /* key is unused. Remove it. */
-          eaccelerator_free_nolock(p);
-          EACCELERATOR_UNLOCK_RW();
-          return NULL;
-        }
-      } else {
-        /* key is valid */
-        p->nhits++;
-        p->use_cnt++;
-        p->ttl = ttl;
-        EACCELERATOR_UNLOCK_RW();
-        return p;
-      }
+        q = p;
+        p = p->next;
     }
-    q = p;
-    p = p->next;
-  }
-  EACCELERATOR_UNLOCK_RW();
-  return NULL;
+    EACCELERATOR_UNLOCK_RW();
+    return NULL;
 }
 
 /* Add a new entry to the hashtable */
-static void hash_add_mm(ea_cache_entry *x) {
-  ea_cache_entry *p,*q;
-  unsigned int slot;
-#ifdef EACCELERATOR_USE_INODE
-  slot = (x->st_dev + x->st_ino) & EA_HASH_MAX;
-#else
-  x->hv = zend_get_hash_value(x->realfilename, strlen(x->realfilename));
-  slot = x->hv & EA_HASH_MAX;
-#endif
-
-  EACCELERATOR_LOCK_RW();
-  x->next = ea_mm_instance->hash[slot];
-  ea_mm_instance->hash[slot] = x;
-  ea_mm_instance->hash_cnt++;
-  q = x;
-  p = x->next;
-  while (p != NULL) {
-#ifdef EACCELERATOR_USE_INODE
-    if ((p->st_dev == x->st_dev) && (p->st_ino == x->st_ino)) {
-#else
-    if ((p->hv == x->hv) &&
-        (strcmp(p->realfilename, x->realfilename) == 0)) {
-#endif
-      q->next = p->next;
-      ea_mm_instance->hash_cnt--;
-      ea_mm_instance->hash[slot]->nreloads += p->nreloads;
-      if (p->use_cnt > 0) {
-        /* key is used by other process/thread. Shedule it to remove */
-        p->removed = 1;
-        p->next = ea_mm_instance->removed;
-        ea_mm_instance->removed = p;
-        ea_mm_instance->rem_cnt++;
-        EACCELERATOR_UNLOCK_RW();
-        return;
-      } else {
-        /* key is unused. Remove it. */
-        eaccelerator_free_nolock(p);
-        EACCELERATOR_UNLOCK_RW();
-        return;
-      }
+static void hash_add_mm(ea_cache_entry *x)
+{
+    ea_cache_entry *p,*q;
+    unsigned int slot;
+    x->hv = zend_get_hash_value(x->realfilename, strlen(x->realfilename));
+    slot = x->hv & EA_HASH_MAX;
+
+    EACCELERATOR_LOCK_RW();
+    x->next = ea_mm_instance->hash[slot];
+    ea_mm_instance->hash[slot] = x;
+    ea_mm_instance->hash_cnt++;
+    q = x;
+    p = x->next;
+    while (p != NULL) {
+        if ((p->hv == x->hv) &&
+                (strcmp(p->realfilename, x->realfilename) == 0)) {
+            q->next = p->next;
+            ea_mm_instance->hash_cnt--;
+            ea_mm_instance->hash[slot]->nreloads += p->nreloads;
+            if (p->use_cnt > 0) {
+                /* key is used by other process/thread. Shedule it to remove */
+                p->removed = 1;
+                p->next = ea_mm_instance->removed;
+                ea_mm_instance->removed = p;
+                ea_mm_instance->rem_cnt++;
+                EACCELERATOR_UNLOCK_RW();
+                return;
+            } else {
+                /* key is unused. Remove it. */
+                eaccelerator_free_nolock(p);
+                EACCELERATOR_UNLOCK_RW();
+                return;
+            }
+        }
+        q = p;
+        p = p->next;
     }
-    q = p;
-    p = p->next;
-  }
-  EACCELERATOR_UNLOCK_RW();
+    EACCELERATOR_UNLOCK_RW();
 }
 
 /* Initialise the shared memory */
-static int init_mm(TSRMLS_D) {
-  pid_t  owner = getpid();
-  MM     *mm;
-  size_t total;
-  char   mm_path[MAXPATHLEN];
+static int init_mm(TSRMLS_D)
+{
+    pid_t  owner = getpid();
+    MM     *mm;
+    size_t total;
+    char   mm_path[MAXPATHLEN];
 
 #ifdef ZEND_WIN32
     snprintf(mm_path, MAXPATHLEN, "%s.%s", EACCELERATOR_MM_FILE, sapi_module.name);
 #else
     snprintf(mm_path, MAXPATHLEN, "%s.%s%d", EACCELERATOR_MM_FILE, sapi_module.name, owner);
 #endif
-/*  snprintf(mm_path, MAXPATHLEN, "%s.%s%d", EACCELERATOR_MM_FILE, sapi_module.name, geteuid());*/
-  if ((ea_mm_instance = (eaccelerator_mm*)mm_attach(ea_shm_size*1024*1024, mm_path)) != NULL) {
+    /*  snprintf(mm_path, MAXPATHLEN, "%s.%s%d", EACCELERATOR_MM_FILE, sapi_module.name, geteuid());*/
+    if ((ea_mm_instance = (eaccelerator_mm*)mm_attach(ea_shm_size*1024*1024, mm_path)) != NULL) {
 #ifdef ZTS
-    ea_mutex = tsrm_mutex_alloc();
+        ea_mutex = tsrm_mutex_alloc();
 #endif
-    return SUCCESS;
-  }
-  mm = mm_create(ea_shm_size*1024*1024, mm_path);
-  if (!mm) {
-    return FAILURE;
-  }
+        return SUCCESS;
+    }
+    mm = mm_create(ea_shm_size*1024*1024, mm_path);
+    if (!mm) {
+        return FAILURE;
+    }
 #ifdef ZEND_WIN32
-  DBG(ea_debug_printf, (EA_DEBUG, "init_mm [%d]\n", owner));
+    DBG(ea_debug_printf, (EA_DEBUG, "init_mm [%d]\n", owner));
 #else
-  DBG(ea_debug_printf, (EA_DEBUG, "init_mm [%d,%d]\n", owner, getppid()));
+    DBG(ea_debug_printf, (EA_DEBUG, "init_mm [%d,%d]\n", owner, getppid()));
 #endif
 #ifdef ZTS
-  ea_mutex = tsrm_mutex_alloc();
+    ea_mutex = tsrm_mutex_alloc();
 #endif
-  total = mm_available(mm);
-  ea_mm_instance = mm_malloc_lock(mm, sizeof(*ea_mm_instance));
-  if (!ea_mm_instance) {
-    return FAILURE;
-  }
-  mm_set_attach(mm, ea_mm_instance);
-  memset(ea_mm_instance, 0, sizeof(*ea_mm_instance));
-  ea_mm_instance->owner = owner;
-  ea_mm_instance->mm    = mm;
-  ea_mm_instance->total = total;
-  ea_mm_instance->hash_cnt = 0;
-  ea_mm_instance->rem_cnt  = 0;
-  ea_mm_instance->enabled = 1;
-  ea_mm_instance->optimizer_enabled = 1;
-  ea_mm_instance->check_mtime_enabled = 1;
-  ea_mm_instance->removed = NULL;
-  ea_mm_instance->locks = NULL;
-  ea_mm_instance->last_prune = time(NULL);	/* this time() call is harmless since this is init phase */
-  EACCELERATOR_PROTECT();
-  return SUCCESS;
+    total = mm_available(mm);
+    ea_mm_instance = mm_malloc_lock(mm, sizeof(eaccelerator_mm));
+    if (!ea_mm_instance) {
+        return FAILURE;
+    }
+    mm_set_attach(mm, ea_mm_instance);
+    memset(ea_mm_instance, 0, sizeof(eaccelerator_mm));
+    ea_mm_instance->owner = owner;
+    ea_mm_instance->mm    = mm;
+    ea_mm_instance->total = total;
+    ea_mm_instance->hash_cnt = 0;
+    ea_mm_instance->rem_cnt  = 0;
+    ea_mm_instance->enabled = 1;
+    ea_mm_instance->optimizer_enabled = 1;
+    ea_mm_instance->check_mtime_enabled = 1;
+    ea_mm_instance->removed = NULL;
+    ea_mm_instance->cache_dir_uid = 0;
+    ea_mm_instance->last_prune = time(NULL);	/* this time() call is harmless since this is init phase */
+    return SUCCESS;
 }
 
 /* Clean up the shared memory */
-static void shutdown_mm(TSRMLS_D) {
-  if (ea_mm_instance) {
+static void shutdown_mm(TSRMLS_D)
+{
+    if (ea_mm_instance) {
 #ifdef ZEND_WIN32
-    if (ea_mm_instance->owner == getpid()) {
+        if (ea_mm_instance->owner == getpid()) {
 #else
-    if (getpgrp() == getpid()) {
+        if (getpgrp() == getpid()) {
 #endif
-      MM *mm = ea_mm_instance->mm;
+            MM *mm = ea_mm_instance->mm;
 #ifdef ZEND_WIN32
-      DBG(ea_debug_printf, (EA_DEBUG, "shutdown_mm [%d]\n", getpid()));
+            DBG(ea_debug_printf, (EA_DEBUG, "shutdown_mm [%d]\n", getpid()));
 #else
-      DBG(ea_debug_printf, (EA_DEBUG, "shutdown_mm [%d,%d]\n", getpid(), getppid()));
+            DBG(ea_debug_printf, (EA_DEBUG, "shutdown_mm [%d,%d]\n", getpid(), getppid()));
 #endif
 #ifdef ZTS
-      tsrm_mutex_free(ea_mutex);
+            tsrm_mutex_free(ea_mutex);
 #endif
-      if (mm) {
-        mm_destroy(mm);
-      }
-      ea_mm_instance = NULL;
+            if (mm) {
+                mm_destroy(mm);
+            }
+            ea_mm_instance = NULL;
+        }
     }
-  }
 }
 
 void encode_version(const char *str, int *version, int *extra)
@@ -375,27 +354,27 @@
         unsigned int type = ((extra >> 28) & 0xf);
         extra = (extra & 0x0fffffff);
         switch (type) {
-            case 1:
-                snprintf(&str[number], len, "-rev%u", extra);
-                break;
-            case 2:
-                snprintf(&str[number], len, "-rc%u", extra);
-                break;
-            case 3:
-                snprintf(&str[number], len, "-beta%u", extra);
-                break;
-            case 15:
-                if ((int)len >= number + 5) {
-                    str[number] = '-';
-                    str[number + 1] = (extra >> 21) & 0x7f;
-                    str[number + 2] = (extra >> 14) & 0x7f;
-                    str[number + 3] = (extra >> 7) & 0x7f;
-                    str[number + 4] = extra & 0x7f;
-                    str[number + 5] = '\0';
-                }
-                break;
-            default:
-                break;
+        case 1:
+            snprintf(&str[number], len, "-rev%u", extra);
+            break;
+        case 2:
+            snprintf(&str[number], len, "-rc%u", extra);
+            break;
+        case 3:
+            snprintf(&str[number], len, "-beta%u", extra);
+            break;
+        case 15:
+            if ((int)len >= number + 5) {
+                str[number] = '-';
+                str[number + 1] = (extra >> 21) & 0x7f;
+                str[number + 2] = (extra >> 14) & 0x7f;
+                str[number + 3] = (extra >> 7) & 0x7f;
+                str[number + 4] = extra & 0x7f;
+                str[number + 5] = '\0';
+            }
+            break;
+        default:
+            break;
         }
     }
 }
@@ -403,178 +382,148 @@
 
 static char num2hex[] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
 
-#ifdef EACCELERATOR_USE_INODE
-static int eaccelerator_inode_key(char* s, dev_t dev, ino_t ino TSRMLS_DC) {
-  int n, i;
-  snprintf(s, MAXPATHLEN-1, "%s/", EAG(cache_dir));
-  n = strlen(s);
-  for (i = 1; i <= EACCELERATOR_HASH_LEVEL && n < MAXPATHLEN - 1; i++) {
-    s[n++] = num2hex[(ino >> (i << 2)) & 0xf]; // (ino / (i * 4))
-    s[n++] = '/';
-  }
-  s[n] = 0;
-  strlcat(s, "eaccelerator-", MAXPATHLEN-1);
-  n += sizeof("eaccelerator-") - 1;
-  while (dev > 0) {
-    if (n >= MAXPATHLEN) return 0;
-    s[n++] = (dev % 10) +'0';
-    dev /= 10;
-  }
-  if (n >= MAXPATHLEN) return 0;
-  s[n++] = '.';
-  while (ino > 0) {
-    if (n >= MAXPATHLEN) return 0;
-    s[n++] = (ino % 10) +'0';
-    ino /= 10;
-  }
-  if (n >= MAXPATHLEN) return 0;
-  s[n++] = '\000';
-  return 1;
-}
-#endif
-
 /* Function to create a hash key when filenames are used */
-int eaccelerator_md5(char* s, const char* prefix, const char* key TSRMLS_DC) {
-  char md5str[33];
-  PHP_MD5_CTX context;
-  unsigned char digest[16];
-  int i;
-  int n;
-
-  md5str[0] = '\0';
-  PHP_MD5Init(&context);
-  PHP_MD5Update(&context, (unsigned char*)key, strlen(key));
-  PHP_MD5Final(digest, &context);
-  make_digest(md5str, digest);
-  snprintf(s, MAXPATHLEN-1, "%s/", EAG(cache_dir));
-  n = strlen(s);
-  for (i = 0; i < EACCELERATOR_HASH_LEVEL && n < MAXPATHLEN - 1; i++) {
-    s[n++] = md5str[i];
-    s[n++] = '/';
-  }
-  s[n] = 0;
-  snprintf(&s[n], MAXPATHLEN-1-n, "%s%s", prefix, md5str);
-  return 1;
+int eaccelerator_md5(char* s, const char* prefix, const char* key TSRMLS_DC)
+{
+    char md5str[33];
+    PHP_MD5_CTX context;
+    unsigned char digest[16];
+    int i;
+    int n;
+
+    md5str[0] = '\0';
+    PHP_MD5Init(&context);
+    PHP_MD5Update(&context, (unsigned char*)key, strlen(key));
+    PHP_MD5Final(digest, &context);
+    make_digest(md5str, digest);
+    snprintf(s, MAXPATHLEN-1, "%s/%d/", EAG(cache_dir), ea_mm_instance->cache_dir_uid);
+    n = strlen(s);
+    for (i = 0; i < EACCELERATOR_HASH_LEVEL && n < MAXPATHLEN - 1; i++) {
+        s[n++] = md5str[i];
+        s[n++] = '/';
+    }
+    s[n] = 0;
+    snprintf(&s[n], MAXPATHLEN-1-n, "%s%s", prefix, md5str);
+    return 1;
 }
 
 /* Remove expired keys, content and scripts from the memory cache */
-void eaccelerator_prune(time_t t) {
-  unsigned int i;
+void eaccelerator_prune(time_t t)
+{
+    unsigned int i;
 
-  EACCELERATOR_LOCK_RW();
-  ea_mm_instance->last_prune = t;
-  for (i = 0; i < EA_HASH_SIZE; i++) {
-    ea_cache_entry **p = &ea_mm_instance->hash[i];
-    while (*p != NULL) {
-      struct stat buf;
-      if (((*p)->ttl != 0 && (*p)->ttl < t && (*p)->use_cnt <= 0) ||
-          stat((*p)->realfilename,&buf) != 0 ||
-#ifdef EACCELERATOR_USE_INODE
-          (*p)->st_dev != buf.st_dev ||
-          (*p)->st_ino != buf.st_ino ||
-#endif
-          (*p)->mtime != buf.st_mtime ||
-          (*p)->filesize != buf.st_size) {
-        ea_cache_entry *r = *p;
-        *p = (*p)->next;
-        ea_mm_instance->hash_cnt--;
-        eaccelerator_free_nolock(r);
-      } else {
-        p = &(*p)->next;
-      }
+    EACCELERATOR_LOCK_RW();
+    ea_mm_instance->last_prune = t;
+    for (i = 0; i < EA_HASH_SIZE; i++) {
+        ea_cache_entry **p = &ea_mm_instance->hash[i];
+        while (*p != NULL) {
+            struct stat buf;
+            if (((*p)->ttl != 0 && (*p)->ttl < t && (*p)->use_cnt <= 0) ||
+                    stat((*p)->realfilename,&buf) != 0 ||
+                    (*p)->mtime != buf.st_mtime ||
+                    (*p)->filesize != buf.st_size) {
+                ea_cache_entry *r = *p;
+                *p = (*p)->next;
+                ea_mm_instance->hash_cnt--;
+                eaccelerator_free_nolock(r);
+            } else {
+                p = &(*p)->next;
+            }
+        }
     }
-  }
-  EACCELERATOR_UNLOCK_RW();
+    EACCELERATOR_UNLOCK_RW();
 }
 
 /* Allocate a new cache chunk */
-void* eaccelerator_malloc2(size_t size TSRMLS_DC) {
-  void *p = NULL;
+void* eaccelerator_malloc2(size_t size TSRMLS_DC)
+{
+    void *p = NULL;
 
-  if (ea_shm_prune_period > 0) {
-    if (EAG(req_start) - ea_mm_instance->last_prune > ea_shm_prune_period) {
-      eaccelerator_prune(EAG(req_start));
-      p = eaccelerator_malloc(size);
+    if (ea_shm_prune_period > 0) {
+        if (EAG(req_start) - ea_mm_instance->last_prune > ea_shm_prune_period) {
+            eaccelerator_prune(EAG(req_start));
+            p = eaccelerator_malloc(size);
+        }
     }
-  }
-  return p;
+    return p;
 }
 
 #define EACCELERATOR_CRC32(crc, ch)   (crc = (crc >> 8) ^ crc32tab[(crc ^ (ch)) & 0xff])
 
 static const unsigned int crc32tab[256] = {
-  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
-  0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
-  0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
-  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
-  0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
-  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
-  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
-  0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
-  0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
-  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
-  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
-  0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
-  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
-  0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
-  0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
-  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
-  0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
-  0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
-  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
-  0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
-  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
-  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
-  0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
-  0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
-  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
-  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
-  0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
-  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
-  0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
-  0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
-  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
-  0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
-  0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
-  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
-  0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
-  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
-  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
-  0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
-  0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
-  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
-  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
-  0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
-  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
-  0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
-  0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
-  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
-  0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
-  0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
-  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
-  0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
-  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
-  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
-  0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
-  0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
-  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
-  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
-  0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
-  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
-  0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
-  0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
-  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
-  0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
-  0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
-  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
+    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
+    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
+    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
+    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
+    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
+    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
+    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
+    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
+    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
+    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
+    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
+    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
+    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
+    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
+    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
+    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
+    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
+    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
+    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
+    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
+    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
+    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
+    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
+    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
+    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
+    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
+    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
+    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
+    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
+    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
+    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
+    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
+    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
+    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
+    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
+    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
+    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
+    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
+    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
+    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
+    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
+    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
 };
 
-unsigned int eaccelerator_crc32(const char *p, size_t n) {
-  unsigned int crc = ~0;
-  for (; n--; ++p) {
-    EACCELERATOR_CRC32(crc, *p);
-  }
-  return ~crc;
+unsigned int eaccelerator_crc32(const char *p, size_t n)
+{
+    unsigned int crc = ~0;
+    for (; n--; ++p) {
+        EACCELERATOR_CRC32(crc, *p);
+    }
+    return ~crc;
 }
 
 /******************************************************************************/
@@ -586,514 +535,579 @@
 inline int check_header(ea_file_header *hdr)
 {
 #ifdef DEBUG
-  char current[255];
-  char cache[255];
+    char current[255];
+    char cache[255];
 #endif
-	
-  if (strncmp(hdr->magic, EA_MAGIC, 8) != 0) {
+
+    if (strncmp(hdr->magic, EA_MAGIC, 8) != 0) {
 #ifdef DEBUG
-    ea_debug_printf(EA_DEBUG, "Magic header mismatch.");
+        ea_debug_printf(EA_DEBUG, "Magic header mismatch.");
 #endif
-	return 0;	
-  }
-  if (hdr->eaccelerator_version[0] != binary_eaccelerator_version[0] 
-      || hdr->eaccelerator_version[1] != binary_eaccelerator_version[1]) {
+        return 0;
+    }
+    if (hdr->eaccelerator_version[0] != binary_eaccelerator_version[0]
+            || hdr->eaccelerator_version[1] != binary_eaccelerator_version[1]) {
 #ifdef DEBUG
-    decode_version(hdr->eaccelerator_version[0], hdr->eaccelerator_version[1], cache, 255);
-    decode_version(binary_eaccelerator_version[0], binary_eaccelerator_version[1], current, 255);
-    ea_debug_printf(EA_DEBUG, "eAccelerator version mismatch, cache file %s and current version %s\n", cache, current);
+        decode_version(hdr->eaccelerator_version[0], hdr->eaccelerator_version[1], cache, 255);
+        decode_version(binary_eaccelerator_version[0], binary_eaccelerator_version[1], current, 255);
+        ea_debug_printf(EA_DEBUG, "eAccelerator version mismatch, cache file %s and current version %s\n", cache, current);
 #endif
-    return 0;
-  }
-  if (hdr->zend_version[0] != binary_zend_version[0] 
-      || hdr->zend_version[1] != binary_zend_version[1]) {
+        return 0;
+    }
+    if (hdr->zend_version[0] != binary_zend_version[0]
+            || hdr->zend_version[1] != binary_zend_version[1]) {
 #ifdef DEBUG
-    decode_version(hdr->zend_version[0], hdr->zend_version[1], cache, 255);
-    decode_version(binary_zend_version[0], binary_zend_version[1], current, 255);
-    ea_debug_printf(EA_DEBUG, "Zend version mismatch, cache file %s and current version %s\n", cache, current);
+        decode_version(hdr->zend_version[0], hdr->zend_version[1], cache, 255);
+        decode_version(binary_zend_version[0], binary_zend_version[1], current, 255);
+        ea_debug_printf(EA_DEBUG, "Zend version mismatch, cache file %s and current version %s\n", cache, current);
 #endif
-    return 0;
-  }
-  if (hdr->php_version[0] != binary_php_version[0] 
-      || hdr->php_version[1] != binary_php_version[1]) {
+        return 0;
+    }
+    if (hdr->php_version[0] != binary_php_version[0]
+            || hdr->php_version[1] != binary_php_version[1]) {
 #ifdef DEBUG
-    decode_version(hdr->php_version[0], hdr->php_version[1], cache, 255);
-    decode_version(binary_php_version[0], binary_php_version[1], current, 255);
-    ea_debug_printf(EA_DEBUG, "PHP version mismatch, cache file %s and current version %s\n", cache, current);
+        decode_version(hdr->php_version[0], hdr->php_version[1], cache, 255);
+        decode_version(binary_php_version[0], binary_php_version[1], current, 255);
+        ea_debug_printf(EA_DEBUG, "PHP version mismatch, cache file %s and current version %s\n", cache, current);
 #endif
-    return 0;
-  }
-  return 1;
+        return 0;
+    }
+    return 1;
 }
 
 /* A function to create the header for a cache file.
  */
 inline void init_header(ea_file_header *hdr)
 {
-  strncpy(hdr->magic, EA_MAGIC, 8);
-  hdr->eaccelerator_version[0] = binary_eaccelerator_version[0];
-  hdr->eaccelerator_version[1] = binary_eaccelerator_version[1];
-  hdr->zend_version[0] = binary_zend_version[0];
-  hdr->zend_version[1] = binary_zend_version[1];
-  hdr->php_version[0] = binary_php_version[0];	
-  hdr->php_version[1] = binary_php_version[1];
+    strncpy(hdr->magic, EA_MAGIC, 8);
+    hdr->eaccelerator_version[0] = binary_eaccelerator_version[0];
+    hdr->eaccelerator_version[1] = binary_eaccelerator_version[1];
+    hdr->zend_version[0] = binary_zend_version[0];
+    hdr->zend_version[1] = binary_zend_version[1];
+    hdr->php_version[0] = binary_php_version[0];
+    hdr->php_version[1] = binary_php_version[1];
 }
 /* Retrieve a cache entry from the cache directory */
-static ea_cache_entry* hash_find_file(const char  *key, struct stat *buf TSRMLS_DC) {
-  int f;
-  char s[MAXPATHLEN];
-  ea_file_header hdr;
-  ea_cache_entry *p;
-  int use_shm = 1;
-
-#ifdef EACCELERATOR_USE_INODE
-  struct stat buf2;
-
-  if (!eaccelerator_inode_key(s, buf->st_dev, buf->st_ino TSRMLS_CC)) {
-    return NULL;
-  }
-#else
-  if (!eaccelerator_md5(s, "/eaccelerator-", key TSRMLS_CC)) {
-    return NULL;
-  }
-#endif
-
-  if ((f = open(s, O_RDONLY | O_BINARY)) > 0) {
-    EACCELERATOR_FLOCK(f, LOCK_SH);
-    if (read(f, &hdr, sizeof(hdr)) != sizeof(hdr)) {
-      EACCELERATOR_FLOCK(f, LOCK_UN);
-      close(f);
-      return NULL;
-    }
-    if (!check_header(&hdr)) {
-      EACCELERATOR_FLOCK(f, LOCK_UN);
-      close(f);
-      unlink(s);
-      return NULL;
-    }
-    p = eaccelerator_malloc(hdr.size);
-    if (p == NULL) {
-      p = eaccelerator_malloc2(hdr.size TSRMLS_CC);
-    }
-    if (p == NULL) {
-      p = emalloc(hdr.size);
-      use_shm = 0;
-    }
-    if (p == NULL) {
-      EACCELERATOR_FLOCK(f, LOCK_UN);
-      close(f);
-      return NULL;
-    }
-    if (read(f, p, hdr.size) != hdr.size ||
-        p->size != hdr.size ||
-        hdr.crc32 != eaccelerator_crc32((const char*)p,p->size)) {
-      EACCELERATOR_FLOCK(f, LOCK_UN);
-      close(f);
-      unlink(s);
-      if (use_shm) eaccelerator_free(p); else efree(p);
-			DBG(ea_debug_printf, (EA_DEBUG, "cache file is corrupted\n"));
-      return NULL;
-    }
-    EACCELERATOR_FLOCK(f, LOCK_UN);
-    close(f);
-#ifdef EACCELERATOR_USE_INODE
-    if (p->st_dev != buf->st_dev || p->st_ino != buf->st_ino) {
-#else
-    if (strcmp(key,p->realfilename) != 0) {
-#endif
-      if (use_shm) eaccelerator_free(p); else efree(p);
-      return NULL;
-    }
-    if ((EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled &&
-        (buf->st_mtime != p->mtime || buf->st_size != p->filesize))
-#ifdef EACCELERATOR_USE_INODE
-        ||
-        (strcmp(p->realfilename, key) != 0 &&
-         (stat(p->realfilename,&buf2) != 0 ||
-         buf2.st_dev != buf->st_dev ||
-         buf2.st_ino != buf->st_ino))
-#endif
-       ) {
-      /* key is invalid. Remove it. */
-      if (use_shm) eaccelerator_free(p); else efree(p);
-      unlink(s);
-      return NULL;
-    }
-    eaccelerator_fixup(p TSRMLS_CC);
-    if (use_shm) {
-      p->nhits    = 1;
-      p->nreloads = 1;
-      p->use_cnt  = 1;
-      p->removed  = 0;
-      if (ea_shm_ttl > 0) {
-        p->ttl = EAG(req_start) + ea_shm_ttl;
-      } else {
-        p->ttl = 0;
-      }
-      p->ts       = hdr.ts;	/* get cached item creation timestamp from cache file */
-      hash_add_mm(p);
-    } else {
-      p->use_cnt  = 0;
-      p->removed  = 1;
+static ea_cache_entry* hash_find_file(const char  *key, struct stat *buf TSRMLS_DC)
+{
+    int f;
+    char s[MAXPATHLEN];
+    ea_file_header hdr;
+    ea_cache_entry *p = NULL;
+    int use_shm = 1;
+
+    if (!eaccelerator_md5(s, "/eaccelerator-", key TSRMLS_CC)) {
+        return NULL;
+    }
+
+    if ((f = open(s, O_RDONLY | O_BINARY)) > 0) {
+        EACCELERATOR_FLOCK(f, LOCK_SH);
+        if (read(f, &hdr, sizeof(hdr)) != sizeof(hdr)) {
+            EACCELERATOR_FLOCK(f, LOCK_UN);
+            close(f);
+            return NULL;
+        }
+        if (!check_header(&hdr)) {
+            EACCELERATOR_FLOCK(f, LOCK_UN);
+            close(f);
+            unlink(s);
+            return NULL;
+        }
+        p = eaccelerator_malloc(hdr.size);
+        if (p == NULL) {
+            p = eaccelerator_malloc2(hdr.size TSRMLS_CC);
+        }
+        if (p == NULL) {
+            p = emalloc(hdr.size);
+            use_shm = 0;
+        }
+        if (p == NULL) {
+            EACCELERATOR_FLOCK(f, LOCK_UN);
+            close(f);
+            return NULL;
+        }
+        if (read(f, p, hdr.size) != hdr.size ||
+                p->size != hdr.size ||
+                hdr.crc32 != eaccelerator_crc32((const char*)p,p->size)) {
+            EACCELERATOR_FLOCK(f, LOCK_UN);
+            close(f);
+            unlink(s);
+            if (use_shm) {
+                eaccelerator_free(p);
+            } else {
+                efree(p);
+            }
+            DBG(ea_debug_printf, (EA_DEBUG, "cache file is corrupted\n"));
+            return NULL;
+        }
+        EACCELERATOR_FLOCK(f, LOCK_UN);
+        close(f);
+        if (strcmp(key,p->realfilename) != 0) {
+            if (use_shm) {
+                eaccelerator_free(p);
+            } else {
+                efree(p);
+            }
+            return NULL;
+        }
+        if ((EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled &&
+                (buf->st_mtime != p->mtime || buf->st_size != p->filesize))
+           ) {
+            /* key is invalid. Remove it. */
+            if (use_shm) {
+                eaccelerator_free(p);
+            } else {
+                efree(p);
+            }
+            unlink(s);
+            return NULL;
+        }
+        eaccelerator_fixup(p TSRMLS_CC);
+        if (use_shm) {
+            p->nhits    = 1;
+            p->nreloads = 1;
+            p->use_cnt  = 1;
+            p->removed  = 0;
+            if (ea_shm_ttl > 0) {
+                p->ttl = EAG(req_start) + ea_shm_ttl;
+            } else {
+                p->ttl = 0;
+            }
+            p->ts       = hdr.ts;	/* get cached item creation timestamp from cache file */
+            hash_add_mm(p);
+        } else {
+            p->use_cnt  = 0;
+            p->removed  = 1;
+        }
+        mm_check_mem(p);
+        return p;
     }
-    mm_check_mem(p); 
-    return p;
-  }
-  return NULL;
+    return NULL;
 }
 
 /* Add a cache entry to the cache directory */
-static int hash_add_file(ea_cache_entry *p TSRMLS_DC) {
-  int f;
-  int ret = 0;
-  char s[MAXPATHLEN];
-  ea_file_header hdr;
+static int hash_add_file(ea_cache_entry *p TSRMLS_DC)
+{
+    int f;
+    int ret = 0;
+    char s[MAXPATHLEN];
+    ea_file_header hdr;
 
-#ifdef EACCELERATOR_USE_INODE
-  if (!eaccelerator_inode_key(s, p->st_dev, p->st_ino TSRMLS_CC)) {
-    return 0;
-  }
-#else
-  if (!eaccelerator_md5(s, "/eaccelerator-", p->realfilename TSRMLS_CC)) {
-    return 0;
-  }
-#endif
+    if (!eaccelerator_md5(s, "/eaccelerator-", p->realfilename TSRMLS_CC)) {
+        return 0;
+    }
 
-  unlink(s);
-  f = open(s, O_CREAT | O_WRONLY | O_EXCL | O_BINARY, S_IRUSR | S_IWUSR);
-  if (f > 0) {
-    EACCELERATOR_FLOCK(f, LOCK_EX);
-    init_header(&hdr);
-    hdr.size  = p->size;
-    hdr.mtime = p->mtime;
-    hdr.ts    = p->ts;
-    p->next = p;
-    hdr.crc32 = eaccelerator_crc32((const char*)p,p->size);
-    ret = (write(f, &hdr, sizeof(hdr)) == sizeof(hdr));
-    if (ret) ret = (write(f, p, p->size) == p->size);
-    EACCELERATOR_FLOCK(f, LOCK_UN);
-    close(f);
-  } else {
-    ea_debug_log("EACCELERATOR: Open for write failed for \"%s\": %s\n", s, strerror(errno));
-  }
-  return ret;
+    unlink(s);
+    f = open(s, O_CREAT | O_WRONLY | O_EXCL | O_BINARY, S_IRUSR | S_IWUSR);
+    if (f > 0) {
+        EACCELERATOR_FLOCK(f, LOCK_EX);
+        init_header(&hdr);
+        hdr.size  = p->size;
+        hdr.mtime = p->mtime;
+        hdr.ts    = p->ts;
+        p->next = p;
+        hdr.crc32 = eaccelerator_crc32((const char*)p,p->size);
+        ret = (write(f, &hdr, sizeof(hdr)) == sizeof(hdr));
+        if (ret) {
+            ret = (write(f, p, p->size) == p->size);
+        }
+        EACCELERATOR_FLOCK(f, LOCK_UN);
+        close(f);
+    } else {
+        ea_debug_log("EACCELERATOR: Open for write failed for \"%s\": %s\n", s, strerror(errno));
+    }
+    return ret;
 }
 
 /* called after succesful compilation, from eaccelerator_compile file */
 /* Adds the data from the compilation of the script to the cache */
 static int eaccelerator_store(char* key, struct stat *buf, int nreloads,
-                         zend_op_array* op_array,
-                         Bucket* f, Bucket *c TSRMLS_DC) {
-  ea_cache_entry *p;
-  int len = strlen(key);
-  int use_shm = 1;
-  int ret = 0;
-  int size = 0;
-  void *data = NULL;
-
-  zend_try {
-    size = calc_size(key, op_array, f, c TSRMLS_CC);
-  } zend_catch {
-    size =  0;
-  } zend_end_try();
-  if (size == 0) {
-    return 0;
-  }
+                              zend_op_array* op_array,
+                              Bucket* f, Bucket *c TSRMLS_DC)
+{
+    ea_cache_entry *p;
+    int len = strlen(key);
+    int use_shm = 1;
+    int ret = 0;
+    int size = 0;
+    void *data = NULL;
 
-  DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-  DBG(ea_debug_printf, (EA_DEBUG, "[%d] eaccelerator_store:  returned %d, mm=%x\n", getpid(), size, ea_mm_instance->mm));
-  
-  EACCELERATOR_UNPROTECT();
-  EAG(mem) = eaccelerator_malloc(size);
-  if (EAG(mem) == NULL) {
-    EAG(mem) = eaccelerator_malloc2(size TSRMLS_CC);
-  }
-  if (!EAG(mem) && !ea_scripts_shm_only) {
-    EACCELERATOR_PROTECT();
-    EAG(mem) = emalloc(size);
-    use_shm = 0;
-  }
-  if (EAG(mem)) {
-    data = EAG(mem);
-    memset(EAG(mem), 0, size);
-		p = (ea_cache_entry *)EAG(mem);
-    eaccelerator_store_int(p, key, len, op_array, f, c TSRMLS_CC);
-    p->mtime    = buf->st_mtime;
-    p->ts       = EAG(req_start);
-    p->filesize = buf->st_size;
-    p->size     = size;
-    p->nreloads = nreloads;
-#ifdef EACCELERATOR_USE_INODE
-    p->st_dev   = buf->st_dev;
-    p->st_ino   = buf->st_ino;
-#endif
-    if (use_shm) {
-      if (ea_shm_ttl > 0) {
-        p->ttl = EAG(req_start) + ea_shm_ttl;
-      } else {
-        p->ttl = 0;
-      }
-      if (!ea_scripts_shm_only) {
-        hash_add_file(p TSRMLS_CC);
-      }
-      hash_add_mm(p);
-      EACCELERATOR_PROTECT();
-      ret = 1;
-      mm_check_mem(data);
-    } else {
-      ret =  hash_add_file(p TSRMLS_CC);
-      efree(p);
+    zend_try {
+        size = calc_size(key, op_array, f, c TSRMLS_CC);
+    } zend_catch {
+        size =  0;
+    } zend_end_try();
+    if (size == 0) {
+        return 0;
     }
-  }
-  return ret;
+
+    EAG(mem) = eaccelerator_malloc(size);
+    if (EAG(mem) == NULL) {
+        EAG(mem) = eaccelerator_malloc2(size TSRMLS_CC);
+    }
+    if (!EAG(mem) && !ea_scripts_shm_only) {
+        EAG(mem) = emalloc(size);
+        use_shm = 0;
+    }
+    if (EAG(mem)) {
+        data = EAG(mem);
+        memset(EAG(mem), 0, size);
+        p = (ea_cache_entry *)EAG(mem);
+        eaccelerator_store_int(p, key, len, op_array, f, c TSRMLS_CC);
+        p->mtime    = buf->st_mtime;
+        p->ts       = EAG(req_start);
+        p->filesize = buf->st_size;
+        p->size     = size;
+        p->nreloads = nreloads;
+        if (use_shm) {
+            if (ea_shm_ttl > 0) {
+                p->ttl = EAG(req_start) + ea_shm_ttl;
+            } else {
+                p->ttl = 0;
+            }
+            if (!ea_scripts_shm_only) {
+                hash_add_file(p TSRMLS_CC);
+            }
+            hash_add_mm(p);
+            ret = 1;
+            mm_check_mem(data);
+        } else {
+            ret =  hash_add_file(p TSRMLS_CC);
+            efree(p);
+        }
+    }
+    return ret;
 }
 
-/* Try to restore a file from the cache. If the file isn't found in memory, the 
+/* Try to restore a file from the cache. If the file isn't found in memory, the
    the disk cache is checked */
 static zend_op_array* eaccelerator_restore(char *realname, struct stat *buf,
-                                      int *nreloads, time_t compile_time TSRMLS_DC) {
-  ea_cache_entry *p;
-  zend_op_array *op_array = NULL;
-
-  *nreloads = 1;
-  EACCELERATOR_UNPROTECT();
-  p = hash_find_mm(realname, buf, nreloads, ((ea_shm_ttl > 0)?(compile_time + ea_shm_ttl):0) TSRMLS_CC);
-  if (p == NULL && !ea_scripts_shm_only) {
-    p = hash_find_file(realname, buf TSRMLS_CC);
-  }
-  EACCELERATOR_PROTECT();
-  if (p != NULL && p->op_array != NULL) {
-    /* only restore file when open_basedir allows it */
-    if (php_check_open_basedir(realname TSRMLS_CC)) {
-      return NULL;
-    }		
-    EAG(class_entry) = NULL;
-    op_array = restore_op_array(NULL, p->op_array TSRMLS_CC);
-    if (op_array != NULL) {
-      ea_fc_entry *e;
-      ea_used_entry *used = emalloc(sizeof(ea_used_entry));
-      used->entry  = p;
-      used->next   = (ea_used_entry*)EAG(used_entries);
-      EAG(used_entries) = (void*)used;
-      EAG(mem) = op_array->filename;
-			/* only restore the classes and functions when we restore this script 
-			 * for the first time. 
-			 */
-      if (!zend_hash_exists(&EAG(restored), p->realfilename, strlen(p->realfilename))) {
-				for (e = p->c_head; e!=NULL; e = e->next) {
-          restore_class(e TSRMLS_CC);
-        }
-        for (e = p->f_head; e!=NULL; e = e->next) {
-          restore_function(e TSRMLS_CC);
-        }
-				zend_hash_add(&EAG(restored), p->realfilename, strlen(p->realfilename), NULL, 0, NULL);  
-			}
-			EAG(mem) = p->realfilename;
-    }
+        int *nreloads, time_t compile_time TSRMLS_DC)
+{
+    ea_cache_entry *p;
+    zend_op_array *op_array = NULL;
+
+    *nreloads = 1;
+    p = hash_find_mm(realname, buf, nreloads, ((ea_shm_ttl > 0)?(compile_time + ea_shm_ttl):0) TSRMLS_CC);
+    if (p == NULL && !ea_scripts_shm_only) {
+        p = hash_find_file(realname, buf TSRMLS_CC);
+    }
+    if (p != NULL && p->op_array != NULL) {
+        /* only restore file when open_basedir allows it */
+        if (PG(open_basedir) && php_check_open_basedir(p->realfilename TSRMLS_CC)) {
+            return NULL;
+        }
+        EAG(class_entry) = NULL;
+        op_array = restore_op_array(NULL, p->op_array TSRMLS_CC);
+        if (op_array != NULL) {
+            ea_fc_entry *e;
+            ea_used_entry *used = emalloc(sizeof(ea_used_entry));
+            used->entry  = p;
+            used->next   = (ea_used_entry*)EAG(used_entries);
+            EAG(used_entries) = (void*)used;
+            EAG(mem) = (char*)op_array->filename;
+            /* only restore the classes and functions when we restore this script
+             * for the first time.
+             */
+            if (!zend_hash_exists(&EAG(restored), p->realfilename, strlen(p->realfilename))) {
+                for (e = p->c_head; e!=NULL; e = e->next) {
+                    restore_class(e TSRMLS_CC);
+                }
+                for (e = p->f_head; e!=NULL; e = e->next) {
+                    restore_function(e TSRMLS_CC);
+                }
+                zend_hash_add(&EAG(restored), p->realfilename, strlen(p->realfilename), NULL, 0, NULL);
+            }
+            EAG(mem) = p->realfilename;
+        }
 #ifdef ZEND_COMPILE_DELAYED_BINDING
-    zend_do_delayed_early_binding(op_array TSRMLS_CC);
+        zend_do_delayed_early_binding(op_array TSRMLS_CC);
 #endif
-  }
-  return op_array;
+    }
+    return op_array;
 }
 
+/*
+ * Returns the realpath for given filename according to include path
+ */
+static char *ea_resolve_path(const char *filename, int filename_length, const char *path TSRMLS_DC)
+{
+    char resolved_path[MAXPATHLEN];
+    char trypath[MAXPATHLEN];
+    const char *ptr, *end, *p;
+    char *actual_path;
+    php_stream_wrapper *wrapper;
+
+    if (!filename) {
+        return NULL;
+    }
+
+    /* Don't resolve paths which contain protocol (except of file://) */
+    for (p = filename; isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'; p++) {
+        ;
+    }
+    if ((*p == ':') && (p - filename > 1) && (p[1] == '/') && (p[2] == '/')) {
+        wrapper = php_stream_locate_url_wrapper(filename, &actual_path, STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
+        if (wrapper == &php_plain_files_wrapper) {
+            if (tsrm_realpath(actual_path, resolved_path TSRMLS_CC)) {
+                return estrdup(resolved_path);
+            }
+        }
+        return NULL;
+    }
 
-static int eaccelerator_stat(zend_file_handle *file_handle,
-                        char* realname, struct stat* buf TSRMLS_DC) {
-#ifdef EACCELERATOR_USE_INODE
-#  ifndef ZEND_WIN32
-  if (file_handle->type == ZEND_HANDLE_FP && file_handle->handle.fp != NULL) {
-    if (fstat(fileno(file_handle->handle.fp), buf) == 0 && S_ISREG(buf->st_mode)) {
-      if (file_handle->opened_path != NULL) {
-        strcpy(realname, file_handle->opened_path);
-      }
-      return 0;
+    if ((*filename == '.' &&
+            (IS_SLASH(filename[1]) ||
+             ((filename[1] == '.') && IS_SLASH(filename[2])))) ||
+            IS_ABSOLUTE_PATH(filename, filename_length) ||
+            !path ||
+            !*path) {
+        if (tsrm_realpath(filename, resolved_path TSRMLS_CC)) {
+            return estrdup(resolved_path);
+        } else {
+            return NULL;
+        }
     }
-  } else
-#  endif
-  if (file_handle->opened_path != NULL) {
-    if (stat(file_handle->opened_path, buf) == 0 && S_ISREG(buf->st_mode)) {
-       strcpy(realname,file_handle->opened_path);
-       return 0;
-    }
-  } else if (PG(include_path) == NULL || 
-				 file_handle->filename[0] == '.' ||
-             IS_SLASH(file_handle->filename[0]) ||
-             IS_ABSOLUTE_PATH(file_handle->filename,strlen(file_handle->filename))) {
-    if (stat(file_handle->filename, buf) == 0 && S_ISREG(buf->st_mode)) {
-       return 0;
-    }
-  } else {
-    char* ptr = PG(include_path);
-    char* end;
-    int   len;
-    char  tryname[MAXPATHLEN];
-    int   filename_len = strlen(file_handle->filename);
 
+    ptr = path;
     while (ptr && *ptr) {
-      end = strchr(ptr, DEFAULT_DIR_SEPARATOR);
-      if (end != NULL) {
-        len = end - ptr;
-        end++;
-      } else {
-        len = strlen(ptr);
-        end = ptr + len;
-      }
-      if (len + filename_len + 2 < MAXPATHLEN) {
-        memcpy(tryname, ptr, len);
-        tryname[len] = '/';
-        memcpy(tryname + len + 1, file_handle->filename, filename_len);
-        tryname[len + filename_len + 1] = '\0';
-        if (stat(tryname, buf) == 0 && S_ISREG(buf->st_mode)) {
-          return 0;
-        }
-      }
-      ptr = end;
-    }
-
-	if (zend_is_executing(TSRMLS_C)) {
-        int tryname_length;
-		strncpy(tryname, zend_get_executed_filename(TSRMLS_C), MAXPATHLEN);
-		tryname[MAXPATHLEN - 1] = 0;
-		tryname_length = strlen(tryname);
-
-		while (tryname_length >= 0 && !IS_SLASH(tryname[tryname_length])) {
-			tryname_length--;
-		}
-		if (tryname_length > 0 && tryname[0] != '[' // [no active file]
-			&& tryname_length + filename_len + 1 < MAXPATHLEN)
-		{
-			strncpy(tryname + tryname_length + 1, file_handle->filename, filename_len + 1);
-			if (stat(tryname, buf) == 0 && S_ISREG(buf->st_mode)) {
-				return 0;
-			}
-		}
-	}
-  }
-  return -1;
+        /* Check for stream wrapper */
+        int is_stream_wrapper = 0;
+
+        for (p = ptr; isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'; p++) {
+            ;
+        }
+        if ((*p == ':') && (p - ptr > 1) && (p[1] == '/') && (p[2] == '/')) {
+            /* .:// or ..:// is not a stream wrapper */
+            if (p[-1] != '.' || p[-2] != '.' || p - 2 != ptr) {
+                p += 3;
+                is_stream_wrapper = 1;
+            }
+        }
+        end = strchr(p, DEFAULT_DIR_SEPARATOR);
+        if (end) {
+            if ((end-ptr) + 1 + filename_length + 1 >= MAXPATHLEN) {
+                ptr = end + 1;
+                continue;
+            }
+            memcpy(trypath, ptr, end-ptr);
+            trypath[end-ptr] = '/';
+            memcpy(trypath+(end-ptr)+1, filename, filename_length+1);
+            ptr = end+1;
+        } else {
+            int len = strlen(ptr);
+
+            if (len + 1 + filename_length + 1 >= MAXPATHLEN) {
+                break;
+            }
+            memcpy(trypath, ptr, len);
+            trypath[len] = '/';
+            memcpy(trypath+len+1, filename, filename_length+1);
+            ptr = NULL;
+        }
+        actual_path = trypath;
+        if (is_stream_wrapper) {
+            wrapper = php_stream_locate_url_wrapper(trypath, &actual_path, STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
+            if (!wrapper) {
+                continue;
+            } else if (wrapper != &php_plain_files_wrapper) {
+                if (wrapper->wops->url_stat) {
+                    php_stream_statbuf ssb;
+
+                    if (SUCCESS == wrapper->wops->url_stat(wrapper, trypath, 0, &ssb, NULL TSRMLS_CC)) {
+                        return estrdup(trypath);
+                    }
+                }
+                continue;
+            }
+        }
+        if (tsrm_realpath(actual_path, resolved_path TSRMLS_CC)) {
+            return estrdup(resolved_path);
+        }
+    } /* end provided path */
+
+    /* check in calling scripts' current working directory as a fall back case
+     */
+    if (zend_is_executing(TSRMLS_C)) {
+#ifdef ZEND_ENGINE_2_4
+        const char *exec_fname = zend_get_executed_filename(TSRMLS_C);
 #else
-  if (file_handle->opened_path != NULL) {
-    strcpy(realname,file_handle->opened_path);
-#  ifndef ZEND_WIN32
-    if (file_handle->type == ZEND_HANDLE_FP && file_handle->handle.fp != NULL) {
-      if (!EAG(check_mtime_enabled) && !ea_mm_instance->check_mtime_enabled) {
-        return 0;
-      } else if (fstat(fileno(file_handle->handle.fp), buf) == 0 && S_ISREG(buf->st_mode)) {
-        return 0;
-      } else {
-        return -1;
-      }
-    } else {
-      if (!EAG(check_mtime_enabled) && !ea_mm_instance->check_mtime_enabled) {
-        return 0;
-      } else if (stat(realname, buf) == 0 && S_ISREG(buf->st_mode)) {
-        return 0;
-      } else {
-        return -1;
-      }
-    }
-#  else
-    if (!EAG(check_mtime_enabled) && !ea_mm_instance->check_mtime_enabled) {
-      return 0;
-    } else if (stat(realname, buf) == 0 && S_ISREG(buf->st_mode)) {
-      return 0;
-    } else {
-      return -1;
+        char *exec_fname = zend_get_executed_filename(TSRMLS_C);
+#endif
+        int exec_fname_length = strlen(exec_fname);
+
+        while ((--exec_fname_length >= 0) && !IS_SLASH(exec_fname[exec_fname_length])) {
+            ;
+        }
+        if (exec_fname && exec_fname[0] != '[' &&
+                exec_fname_length > 0 &&
+                exec_fname_length + 1 + filename_length + 1 < MAXPATHLEN) {
+            memcpy(trypath, exec_fname, exec_fname_length + 1);
+            memcpy(trypath+exec_fname_length + 1, filename, filename_length+1);
+            actual_path = trypath;
+
+            /* Check for stream wrapper */
+            for (p = trypath; isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'; p++) {
+                ;
+            }
+            if ((*p == ':') && (p - trypath > 1) && (p[1] == '/') && (p[2] == '/')) {
+                wrapper = php_stream_locate_url_wrapper(trypath, &actual_path, STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
+                if (!wrapper) {
+                    return NULL;
+                } else if (wrapper != &php_plain_files_wrapper) {
+                    if (wrapper->wops->url_stat) {
+                        php_stream_statbuf ssb;
+
+                        if (SUCCESS == wrapper->wops->url_stat(wrapper, trypath, 0, &ssb, NULL TSRMLS_CC)) {
+                            return estrdup(trypath);
+                        }
+                    }
+                    return NULL;
+                }
+            }
+
+            if (tsrm_realpath(actual_path, resolved_path TSRMLS_CC)) {
+                return estrdup(resolved_path);
+            }
+        }
     }
-#  endif
-  } else if (file_handle->filename == NULL) {
-    return -1;
-  } else if (PG(include_path) == NULL || 
-             file_handle->filename[0] == '.' ||
-             IS_SLASH(file_handle->filename[0]) ||
-             IS_ABSOLUTE_PATH(file_handle->filename,strlen(file_handle->filename))) {
-    if (VCWD_REALPATH(file_handle->filename, realname)) {
-      if (!EAG(check_mtime_enabled) && !ea_mm_instance->check_mtime_enabled) {
-        return 0;
-      } else if (stat(realname, buf) == 0 && S_ISREG(buf->st_mode)) {
+
+    return NULL;
+}
+
+/**
+ * Get the real filename of the file represented by the given file_handle.
+ * If unable to determine the realfilename this function returns 0, otherwise
+ * it returns 1.
+ *
+ * realfilename should be MAXPATHLEN long.
+ */
+static int ea_get_realname(zend_file_handle *file_handle, char* realname TSRMLS_DC)
+{
+    // at least one of these should have value
+    if (file_handle->opened_path == NULL && file_handle->filename == NULL) {
         return 0;
-      } else {
-        return -1;
-      }
-    }
-  } else {
-    char* ptr = PG(include_path);
-    char* end;
-    int   len;
-    char  tryname[MAXPATHLEN];
-    int   filename_len = strlen(file_handle->filename);
+    }
 
-    while (ptr && *ptr) {
-      end = strchr(ptr, DEFAULT_DIR_SEPARATOR);
-      if (end != NULL) {
-        len = end - ptr;
-        end++;
-      } else {
-        len = strlen(ptr);
-        end = ptr + len;
-      }
-      if (len+filename_len+2 < MAXPATHLEN) {
-        memcpy(tryname, ptr, len);
-        tryname[len] = '/';
-        memcpy(tryname + len + 1, file_handle->filename, filename_len);
-        tryname[len + filename_len + 1] = '\0';
-        if (VCWD_REALPATH(tryname, realname)) {
-#  ifdef ZEND_WIN32
-          if (stat(realname, buf) == 0 && S_ISREG(buf->st_mode)) {
-            return 0;
-          }
-#  else
-          if (!EAG(check_mtime_enabled) && !ea_mm_instance->check_mtime_enabled) {
-            return 0;
-          } else if (stat(realname, buf) == 0 && S_ISREG(buf->st_mode)) {
+    if (file_handle->opened_path != NULL) {
+        strcpy(realname, file_handle->opened_path);
+        return 1;
+    }
+
+    if (PG(include_path) == NULL ||
+            file_handle->filename[0] == '.' ||
+            IS_SLASH(file_handle->filename[0]) ||
+            IS_ABSOLUTE_PATH(file_handle->filename, strlen(file_handle->filename))) {
+
+        return VCWD_REALPATH(file_handle->filename, realname) != NULL;
+    } else {
+        int filename_len = strlen(file_handle->filename);
+        char* temp_name = ea_resolve_path(file_handle->filename, filename_len, PG(include_path) TSRMLS_CC);
+
+        if (temp_name == NULL) {
             return 0;
-          } else {
-            return -1;
-          }
-#  endif
         }
-      }
-      ptr = end;
+
+        strcpy(realname, temp_name);
+        efree(temp_name);
+        return 1;
     }
-  }
-  return -1;
+
+    return 0;
+}
+
+static int ea_get_phar_name(const char* filename, size_t filename_len, char* phar_name)
+{
+    size_t i = 0;
+
+    for (i = sizeof("phar://"); i < filename_len - sizeof(".phar"); ++i) {
+        if (filename[i] == '.' && filename[i + 1] == 'p' && filename[i + 2] == 'h' &&
+                filename[i + 3] == 'a' && filename[i + 4] == 'r') {
+            int copy_len = (i - sizeof("phar://") + sizeof(".phar"));
+            if (copy_len >= MAXPATHLEN - 1) {
+                return 0;
+            }
+            memcpy(phar_name, &filename[sizeof("phar://") - 1], copy_len);
+            phar_name[copy_len] = '\0';
+            return 1;
+        }
+    }
+    return 0;
+}
+
+/*
+ * Stat the file that belongs to file_handle. It puts result of the stat call
+ * in buf and the real filename in realname.
+ *
+ * Returns 0 when the stat failed or if unable to perform a stat call. If successful
+ * it returns 1
+ */
+static int eaccelerator_stat(zend_file_handle *file_handle,
+                             char* realname, struct stat* buf TSRMLS_DC)
+{
+    if (!ea_get_realname(file_handle, realname TSRMLS_CC)) {
+#ifdef ZEND_ENGINE_2_3
+        if (strncmp(file_handle->filename, "phar://", sizeof("phar://"))) {
+            // Determine the name of the phar archive and use this filename to do the
+            // stat call. Return filename as realname.
+            char phar_name[MAXPATHLEN];
+            size_t filename_len = strlen(file_handle->filename);
+
+            if (!ea_get_phar_name(file_handle->filename, filename_len, phar_name)) {
+                return 0;
+            }
+            // TODO: resolve this problem
+            if (filename_len >= MAXPATHLEN) {
+                return 0;
+            }
+            strcpy(realname, file_handle->filename);
+            return (stat(phar_name, buf) == 0 && S_ISREG(buf->st_mode));
+        }
 #endif
+        return 0;
+    }
+
+
+    if (EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled) {
+        return (stat(realname, buf) == 0 && S_ISREG(buf->st_mode));
+    }
+    return 1;
 }
 
 static int ea_match(struct ea_pattern_t *list, const char *path)
 {
-	struct ea_pattern_t *p;
-	char result, positive;
+    struct ea_pattern_t *p;
+    char result, positive;
 
-	// apply all patterns
-	//  - when not patterns are given, *accept*
-	//  - when a pattern with a ! matches, *reject*
-	//  - when no negative pattern matches and a positive pattern match, *accept*
-	//  - when no negative pattern matches and there are no possitive patterns, *accept*
-	//  - *reject*
-
-	if (list == NULL) {
-		// there are no patterns, accept
-		return 1;
-	}
-
-	result = 0; // there are patterns, so if no positive pattern matches, reject
-	positive = 0;
-	p = list;
-	while (p != NULL) {
-		if (p->pattern[0] == '!') {
-		  if ((fnmatch((const char *)(p->pattern + 1), path, 0) == 0)) {
-				// a negative pattern matches, accept
-				return 0;
-			}
-		} else {
-			result |= (fnmatch((const char *)p->pattern, path, 0) == 0);
-			positive = 1;
-		}
-		p = p->next;
-	}
+    // apply all patterns
+    //  - when not patterns are given, *accept*
+    //  - when a pattern with a ! matches, *reject*
+    //  - when no negative pattern matches and a positive pattern match, *accept*
+    //  - when no negative pattern matches and there are no possitive patterns, *accept*
+    //  - *reject*
+
+    if (list == NULL) {
+        // there are no patterns, accept
+        return 1;
+    }
+
+    result = 0; // there are patterns, so if no positive pattern matches, reject
+    positive = 0;
+    p = list;
+    while (p != NULL) {
+        if (p->pattern[0] == '!') {
+            if ((fnmatch((const char *)(p->pattern + 1), path, 0) == 0)) {
+                // a negative pattern matches, accept
+                return 0;
+            }
+        } else {
+            result |= (fnmatch((const char *)p->pattern, path, 0) == 0);
+            positive = 1;
+        }
+        p = p->next;
+    }
 
-  return result | !positive;
+    return result | !positive;
 }
 
 /* copy of zend_class_add_ref, the linker isn't able to link to it any more
@@ -1102,7 +1116,7 @@
  */
 void ea_class_add_ref(zend_class_entry **ce)
 {
-	    (*ce)->refcount++;
+    (*ce)->refcount++;
 }
 
 /*
@@ -1112,362 +1126,361 @@
  * This function is called again for each PHP file included in the
  * main PHP file.
  */
-ZEND_DLEXPORT zend_op_array* eaccelerator_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC) {
-  zend_op_array *t;
-  struct stat buf;
-  char  realname[MAXPATHLEN];
-  int   nreloads;
-  int stat_result = 0;
+ZEND_DLEXPORT zend_op_array* eaccelerator_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC)
+{
+    zend_op_array *t;
+    struct stat buf;
+    char  realname[MAXPATHLEN];
+    int   nreloads;
+    int stat_result = 0;
 #ifdef DEBUG
-  struct timeval tv_start;
+    struct timeval tv_start;
 #endif
-  int ok_to_cache = 0;
+    int ok_to_cache = 0;
 #ifdef ZEND_ENGINE_2_3
-  zend_uint orig_compiler_options;
+    zend_uint orig_compiler_options;
 #endif
 
-#ifdef EACCELERATOR_USE_INODE
-  realname[0] = '\000';
-#endif
-
-  DBG(ea_debug_start_time, (&tv_start));
-  DBG(ea_debug_printf, (EA_DEBUG, "[%d] Enter COMPILE\n",getpid()));
-  DBG(ea_debug_printf, (EA_DEBUG, "[%d] compile_file: \"%s\"\n",getpid(), file_handle->filename));
+    DBG(ea_debug_start_time, (&tv_start));
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Enter COMPILE\n",getpid()));
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] compile_file: \"%s\"\n",getpid(), file_handle->filename));
 #ifdef DEBUG
-  EAG(xpad)+=2;
+    EAG(xpad)+=2;
 #endif
 
-  stat_result = eaccelerator_stat(file_handle, realname, &buf TSRMLS_CC);
+    stat_result = eaccelerator_stat(file_handle, realname, &buf TSRMLS_CC);
 
-  ok_to_cache = ea_match(EAG(pattern_list), file_handle->filename);
+    ok_to_cache = ea_match(EAG(pattern_list), file_handle->filename);
 
-  // eAccelerator isn't working, so just compile the file
-  if (!EAG(enabled) || (ea_mm_instance == NULL) || 
-      !ea_mm_instance->enabled || file_handle == NULL ||
-      file_handle->filename == NULL || stat_result != 0 || !ok_to_cache) {
-    DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: compiling\n", getpid()));
-    t = ea_saved_zend_compile_file(file_handle, type TSRMLS_CC);
-    DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: end (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
-    DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: end\n", getpid()));
+    // eAccelerator isn't working, so just compile the file
+    if (!EAG(enabled) || (ea_mm_instance == NULL) ||
+            !ea_mm_instance->enabled || file_handle == NULL ||
+            file_handle->filename == NULL || stat_result == 0 || !ok_to_cache) {
+        DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: compiling\n", getpid()));
+        t = ea_saved_zend_compile_file(file_handle, type TSRMLS_CC);
+        DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: end (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
+        DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: end\n", getpid()));
 #ifdef DEBUG
-    EAG(xpad)-=2;
+        EAG(xpad)-=2;
 #endif
-    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave COMPILE\n", getpid()));
-    return t;
-  }
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave COMPILE\n", getpid()));
+        return t;
+    }
 
-  if (buf.st_mtime >= EAG(req_start) && ea_debug > 0) {
-	ea_debug_log("EACCELERATOR: Warning: \"%s\" is cached but it's mtime is in the future.\n", file_handle->filename);
-  }
-
-  t = eaccelerator_restore(realname, &buf, &nreloads, EAG(req_start) TSRMLS_CC);
-
-// segv74: really cheap work around to auto_global problem.
-//         it makes just in time to every time.
-  zend_is_auto_global("_GET", sizeof("_GET")-1 TSRMLS_CC);
-  zend_is_auto_global("_POST", sizeof("_POST")-1 TSRMLS_CC);
-  zend_is_auto_global("_COOKIE", sizeof("_COOKIE")-1 TSRMLS_CC);
-  zend_is_auto_global("_SERVER", sizeof("_SERVER")-1 TSRMLS_CC);
-  zend_is_auto_global("_ENV", sizeof("_ENV")-1 TSRMLS_CC);
-  zend_is_auto_global("_REQUEST", sizeof("_REQUEST")-1 TSRMLS_CC);
-  zend_is_auto_global("_FILES", sizeof("_FILES")-1 TSRMLS_CC);
+    if (buf.st_mtime >= EAG(req_start) && ea_debug > 0) {
+        ea_debug_log("EACCELERATOR: Warning: \"%s\" is cached but it's mtime is in the future.\n", file_handle->filename);
+    }
 
-  if (t != NULL) { // restore from cache
-#ifdef DEBUG
-    ea_debug_log("[%d] EACCELERATOR hit: \"%s\"\n", getpid(), t->filename);
-#else
-    ea_debug_log("EACCELERATOR hit: \"%s\"\n", t->filename);
-#endif
+    t = eaccelerator_restore(realname, &buf, &nreloads, EAG(req_start) TSRMLS_CC);
 
-    zend_llist_add_element(&CG(open_files), file_handle);
-    if (file_handle->opened_path == NULL && file_handle->type != ZEND_HANDLE_STREAM) {
-      file_handle->handle.stream.handle = (void*)1;
-      file_handle->opened_path = EAG(mem);	/* EAG(mem) = p->realfilename from eaccelerator_restore here */
-    }
+    /* segv74: really cheap work around to auto_global problem.
+               it makes just in time to every time.
+       hrak: TODO this is a really lame hack which totally breaks auto_globals_jit
+    */
 
-    DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: restored (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
-    DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: restored\n", getpid()));
-#ifdef DEBUG
-    EAG(xpad)-=2;
+    zend_is_auto_global("_GET", sizeof("_GET")-1 TSRMLS_CC);
+    zend_is_auto_global("_POST", sizeof("_POST")-1 TSRMLS_CC);
+    zend_is_auto_global("_COOKIE", sizeof("_COOKIE")-1 TSRMLS_CC);
+    zend_is_auto_global("_SERVER", sizeof("_SERVER")-1 TSRMLS_CC);
+    zend_is_auto_global("_ENV", sizeof("_ENV")-1 TSRMLS_CC);
+    zend_is_auto_global("_REQUEST", sizeof("_REQUEST")-1 TSRMLS_CC);
+    zend_is_auto_global("_FILES", sizeof("_FILES")-1 TSRMLS_CC);
+#ifdef ZEND_ENGINE_2_4
+    zend_is_auto_global("GLOBALS", sizeof("GLOBALS")-1 TSRMLS_CC);
 #endif
-    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave COMPILE\n", getpid()));
 
-    return t;
+    if (t != NULL) { // restore from cache
+#ifdef DEBUG
+        ea_debug_log("[%d] EACCELERATOR hit: \"%s\"\n", getpid(), t->filename);
+#else
+        ea_debug_log("EACCELERATOR hit: \"%s\"\n", t->filename);
+#endif
 
-  } else { // not in cache or must be recompiled
-		Bucket *function_table_tail;
-		Bucket *class_table_tail;
-		HashTable* orig_function_table;
-		HashTable* orig_class_table;
-		HashTable* orig_eg_class_table = NULL;
-		HashTable tmp_function_table;
-		HashTable tmp_class_table;
-		zend_function tmp_func;
-		zend_class_entry tmp_class;
-		int ea_bailout;
+        zend_llist_add_element(&CG(open_files), file_handle);
+        if (file_handle->opened_path == NULL && file_handle->type != ZEND_HANDLE_STREAM) {
+            file_handle->handle.stream.handle = (void*)1;
+            file_handle->opened_path = EAG(mem);	/* EAG(mem) = p->realfilename from eaccelerator_restore here */
+        }
 
+        DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: restored (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
+        DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: restored\n", getpid()));
 #ifdef DEBUG
-    ea_debug_printf(EA_DEBUG, "\t[%d] compile_file: marking\n", getpid());
-    if (CG(class_table) != EG(class_table)) {
-      ea_debug_printf(EA_DEBUG, "\t[%d] oops, CG(class_table)[%08x] != EG(class_table)[%08x]\n", getpid(), CG(class_table), EG(class_table));
-      ea_debug_log_hashkeys("CG(class_table)\n", CG(class_table));
-      ea_debug_log_hashkeys("EG(class_table)\n", EG(class_table));
-    } else {
-      ea_debug_printf(EA_DEBUG, "\t[%d] OKAY. That what I thought, CG(class_table)[%08x] == EG(class_table)[%08x]\n", getpid(), CG(class_table), EG(class_table));
-      ea_debug_log_hashkeys("CG(class_table)\n", CG(class_table));
-    }
+        EAG(xpad)-=2;
 #endif
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave COMPILE\n", getpid()));
 
-    zend_hash_init_ex(&tmp_function_table, 100, NULL, ZEND_FUNCTION_DTOR, 1, 0);
-    zend_hash_copy(&tmp_function_table, &ea_global_function_table, NULL, &tmp_func, sizeof(zend_function));
-    orig_function_table = CG(function_table);
-    CG(function_table) = &tmp_function_table;
+        return t;
 
-    zend_hash_init_ex(&tmp_class_table, 10, NULL, ZEND_CLASS_DTOR, 1, 0);
-		zend_hash_copy(&tmp_class_table, &ea_global_class_table, (copy_ctor_func_t)ea_class_add_ref, &tmp_class, sizeof(zend_class_entry *));
+    } else { // not in cache or must be recompiled
+        Bucket *function_table_tail;
+        Bucket *class_table_tail;
+        HashTable* orig_function_table;
+        HashTable* orig_class_table;
+        HashTable* orig_eg_class_table = NULL;
+        HashTable tmp_function_table;
+        HashTable tmp_class_table;
+        zend_function tmp_func;
+        zend_class_entry tmp_class;
+        int ea_bailout;
+
+        zend_hash_init_ex(&tmp_function_table, 100, NULL, ZEND_FUNCTION_DTOR, 1, 0);
+        zend_hash_copy(&tmp_function_table, &ea_global_function_table, NULL, &tmp_func, sizeof(zend_function));
+        orig_function_table = CG(function_table);
+        CG(function_table) = &tmp_function_table;
+
+        zend_hash_init_ex(&tmp_class_table, 10, NULL, ZEND_CLASS_DTOR, 1, 0);
+        zend_hash_copy(&tmp_class_table, &ea_global_class_table, (copy_ctor_func_t)ea_class_add_ref, &tmp_class, sizeof(zend_class_entry *));
+
+        orig_class_table = CG(class_table);;
+        CG(class_table) = &tmp_class_table;
+        orig_eg_class_table = EG(class_table);;
+        EG(class_table) = &tmp_class_table;
+
+        /* Storing global pre-compiled functions and classes */
+        function_table_tail = CG(function_table)->pListTail;
+        class_table_tail = CG(class_table)->pListTail;
 
-    orig_class_table = CG(class_table);;
-    CG(class_table) = &tmp_class_table;
-    orig_eg_class_table = EG(class_table);;
-    EG(class_table) = &tmp_class_table;
+        DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: compiling (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
 
-    /* Storing global pre-compiled functions and classes */
-    function_table_tail = CG(function_table)->pListTail;
-    class_table_tail = CG(class_table)->pListTail;
-
-    DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: compiling (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
-    
-		if (EAG(optimizer_enabled) && ea_mm_instance->optimizer_enabled) {
-		  EAG(compiler) = 1;
-		}
+        if (EAG(optimizer_enabled) && ea_mm_instance->optimizer_enabled) {
+            EAG(compiler) = 1;
+        }
 
-	/* try to compile the script */
-    ea_bailout = 0;
-    zend_try {
+        /* try to compile the script */
+        ea_bailout = 0;
+        zend_try {
 #ifdef ZEND_ENGINE_2_3
-      orig_compiler_options = CG(compiler_options);
-      CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES | ZEND_COMPILE_DELAYED_BINDING;  
+            orig_compiler_options = CG(compiler_options);
+            CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES | ZEND_COMPILE_DELAYED_BINDING;
 #endif
-      t = ea_saved_zend_compile_file(file_handle, type TSRMLS_CC);
+            t = ea_saved_zend_compile_file(file_handle, type TSRMLS_CC);
 #ifdef ZEND_ENGINE_2_3
-      CG(compiler_options) = orig_compiler_options;
+            CG(compiler_options) = orig_compiler_options;
 #endif
-    } zend_catch {
-      CG(function_table) = orig_function_table;
-      CG(class_table) = orig_class_table;
-      EG(class_table) = orig_eg_class_table;
-      ea_bailout = 1;
-    } zend_end_try();
-    if (ea_bailout) {
-      zend_bailout();
-    }
-    DBG(ea_debug_log_hashkeys, ("class_table\n", CG(class_table)));
-
-    EAG(compiler) = 0;
-    if (t != NULL && file_handle->opened_path != NULL && ((EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled) ||
-         ((stat(file_handle->opened_path, &buf) == 0) && S_ISREG(buf.st_mode)))) {
+        } zend_catch {
+            CG(function_table) = orig_function_table;
+            CG(class_table) = orig_class_table;
+            EG(class_table) = orig_eg_class_table;
+            ea_bailout = 1;
+        } zend_end_try();
+        if (ea_bailout) {
+            zend_bailout();
+        }
+        DBG(ea_debug_log_hashkeys, ("class_table\n", CG(class_table)));
 
-      DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: storing in cache (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
-      DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: storing in cache\n", getpid()));
-      function_table_tail = function_table_tail ? function_table_tail->pListNext : CG(function_table)->pListHead;
-      class_table_tail = class_table_tail ? class_table_tail->pListNext : CG(class_table)->pListHead;
+        EAG(compiler) = 0;
+        if (t != NULL && file_handle->opened_path != NULL && ((EAG(check_mtime_enabled) && ea_mm_instance->check_mtime_enabled) ||
+                ((stat(file_handle->opened_path, &buf) == 0) && S_ISREG(buf.st_mode)))) {
+
+            DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: storing in cache (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
+            DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: storing in cache\n", getpid()));
+            function_table_tail = function_table_tail ? function_table_tail->pListNext : CG(function_table)->pListHead;
+            class_table_tail = class_table_tail ? class_table_tail->pListNext : CG(class_table)->pListHead;
 
-      if (eaccelerator_store(file_handle->opened_path, &buf, nreloads, t, function_table_tail, class_table_tail TSRMLS_CC)) {
+            if (eaccelerator_store(file_handle->opened_path, &buf, nreloads, t, function_table_tail, class_table_tail TSRMLS_CC)) {
 #ifdef DEBUG
-        ea_debug_log("[%d] EACCELERATOR %s: \"%s\"\n", getpid(), (nreloads == 1) ? "cached" : "re-cached", file_handle->opened_path);
+                ea_debug_log("[%d] EACCELERATOR %s: \"%s\"\n", getpid(), (nreloads == 1) ? "cached" : "re-cached", file_handle->opened_path);
 #else
-        ea_debug_log("EACCELERATOR %s: \"%s\"\n", (nreloads == 1) ? "cached" : "re-cached", file_handle->opened_path);
+                ea_debug_log("EACCELERATOR %s: \"%s\"\n", (nreloads == 1) ? "cached" : "re-cached", file_handle->opened_path);
 #endif
-      } else {
+            } else {
 #ifdef DEBUG
-        ea_debug_log("[%d] EACCELERATOR can't cache: \"%s\"\n", getpid(), file_handle->opened_path);
+                ea_debug_log("[%d] EACCELERATOR can't cache: \"%s\"\n", getpid(), file_handle->opened_path);
 #else
-        ea_debug_log("EACCELERATOR can't cache: \"%s\"\n", file_handle->opened_path);
+                ea_debug_log("EACCELERATOR can't cache: \"%s\"\n", file_handle->opened_path);
 #endif
-      }
-    } else {
-      function_table_tail = function_table_tail ? function_table_tail->pListNext : CG(function_table)->pListHead;
-      class_table_tail = class_table_tail ? class_table_tail->pListNext : CG(class_table)->pListHead;
+            }
+        } else {
+            function_table_tail = function_table_tail ? function_table_tail->pListNext : CG(function_table)->pListHead;
+            class_table_tail = class_table_tail ? class_table_tail->pListNext : CG(class_table)->pListHead;
+        }
+        CG(function_table) = orig_function_table;
+        CG(class_table) = orig_class_table;
+        EG(class_table) = orig_eg_class_table;
+
+        while (function_table_tail != NULL) {
+            zend_op_array *op_array = (zend_op_array*)function_table_tail->pData;
+            if (op_array->type == ZEND_USER_FUNCTION) {
+                if (zend_hash_add(CG(function_table), function_table_tail->arKey, function_table_tail->nKeyLength, op_array,
+                                  sizeof(zend_op_array), NULL) == FAILURE && function_table_tail->arKey[0] != '\000') {
+                    CG(in_compilation) = 1;
+                    CG(compiled_filename) = file_handle->opened_path;
+                    CG(zend_lineno) = op_array->line_start;
+                    zend_error(E_ERROR, "Cannot redeclare %s()", function_table_tail->arKey);
+                }
+            }
+            function_table_tail = function_table_tail->pListNext;
+        }
+
+        while (class_table_tail != NULL) {
+            zend_class_entry **ce = (zend_class_entry**)class_table_tail->pData;
+            if ((*ce)->type == ZEND_USER_CLASS) {
+                if (zend_hash_add(CG(class_table), class_table_tail->arKey, class_table_tail->nKeyLength,
+                                  ce, sizeof(zend_class_entry*), NULL) == FAILURE && class_table_tail->arKey[0] != '\000') {
+                    CG(in_compilation) = 1;
+                    CG(compiled_filename) = file_handle->opened_path;
+#ifdef ZEND_ENGINE_2_4
+                    CG(zend_lineno) = (*ce)->info.user.line_start;
+#else
+                    CG(zend_lineno) = (*ce)->line_start;
+#endif
+                    zend_error(E_ERROR, "Cannot redeclare class %s", class_table_tail->arKey);
+                }
+            }
+            class_table_tail = class_table_tail->pListNext;
+        }
+        tmp_function_table.pDestructor = NULL;
+        tmp_class_table.pDestructor = NULL;
+        zend_hash_destroy(&tmp_function_table);
+        zend_hash_destroy(&tmp_class_table);
     }
-    CG(function_table) = orig_function_table;
-    CG(class_table) = orig_class_table;
-    EG(class_table) = orig_eg_class_table;
-    DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] restoring CG(class_table)[%08x] != EG(class_table)[%08x]\n", 
-                getpid(), CG(class_table), EG(class_table)));
-    while (function_table_tail != NULL) {
-      zend_op_array *op_array = (zend_op_array*)function_table_tail->pData;
-      if (op_array->type == ZEND_USER_FUNCTION) {
-        if (zend_hash_add(CG(function_table), function_table_tail->arKey, function_table_tail->nKeyLength, op_array, 
-                    sizeof(zend_op_array), NULL) == FAILURE && function_table_tail->arKey[0] != '\000') {
-          CG(in_compilation) = 1;
-          CG(compiled_filename) = file_handle->opened_path;
-          CG(zend_lineno) = op_array->line_start;
-          zend_error(E_ERROR, "Cannot redeclare %s()", function_table_tail->arKey);
-        }
-      }
-      function_table_tail = function_table_tail->pListNext;
-    }
-    while (class_table_tail != NULL) {
-      zend_class_entry **ce = (zend_class_entry**)class_table_tail->pData;
-      if ((*ce)->type == ZEND_USER_CLASS) {
-        if (zend_hash_add(CG(class_table), class_table_tail->arKey, class_table_tail->nKeyLength, 
-                    ce, sizeof(zend_class_entry*), NULL) == FAILURE && class_table_tail->arKey[0] != '\000') {
-          CG(in_compilation) = 1;
-          CG(compiled_filename) = file_handle->opened_path;
-          CG(zend_lineno) = (*ce)->line_start;
-          zend_error(E_ERROR, "Cannot redeclare class %s", class_table_tail->arKey);
-        }
-      }
-      class_table_tail = class_table_tail->pListNext;
-    }
-    tmp_function_table.pDestructor = NULL;
-    tmp_class_table.pDestructor = NULL;
-    zend_hash_destroy(&tmp_function_table);
-    zend_hash_destroy(&tmp_class_table);
-  }
-  DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: end (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
-  DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: end\n", getpid()));
+    DBG(ea_debug_printf, (EA_TEST_PERFORMANCE, "\t[%d] compile_file: end (%ld)\n", getpid(), ea_debug_elapsed_time(&tv_start)));
+    DBG(ea_debug_printf, (EA_DEBUG, "\t[%d] compile_file: end\n", getpid()));
 #ifdef DEBUG
-  EAG(xpad)-=2;
+    EAG(xpad)-=2;
+#endif
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave COMPILE\n", getpid()));
+#ifdef ZEND_COMPILE_DELAYED_BINDING
+    zend_do_delayed_early_binding(t TSRMLS_CC);
 #endif
-  DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave COMPILE\n", getpid()));
-  #ifdef ZEND_COMPILE_DELAYED_BINDING
-      zend_do_delayed_early_binding(t TSRMLS_CC);
-  #endif
-  return t;
+    return t;
 }
 
 #ifdef DEBUG
 static void profile_execute(zend_op_array *op_array TSRMLS_DC)
 {
-  int i;
-  struct timeval tv_start;
-  long usec;
-
-  for (i=0;i<EAG(profile_level);i++)
-    DBG(ea_debug_put, (EA_PROFILE_OPCODES, "  "));
-  ea_debug_printf(EA_PROFILE_OPCODES, "enter profile_execute: %s:%s\n", op_array->filename, op_array->function_name);
-  ea_debug_start_time(&tv_start);
-  EAG(self_time)[EAG(profile_level)] = 0;
-  EAG(profile_level)++;
-  ea_debug_printf(EA_PROFILE_OPCODES, "About to enter zend_execute...\n");
-  ea_saved_zend_execute(op_array TSRMLS_CC);
-  ea_debug_printf(EA_PROFILE_OPCODES, "Finished zend_execute...\n");
-  usec = ea_debug_elapsed_time(&tv_start);
-  EAG(profile_level)--;
-  if (EAG(profile_level) > 0)
-    EAG(self_time)[EAG(profile_level)-1] += usec;
-  for (i=0;i<EAG(profile_level);i++)
-    DBG(ea_debug_put, (EA_PROFILE_OPCODES, "  "));
-  ea_debug_printf(EA_PROFILE_OPCODES, "leave profile_execute: %s:%s (%ld,%ld)\n", op_array->filename, op_array->function_name, usec, usec-EAG(self_time)[EAG(profile_level)]);
-}
-
-ZEND_DLEXPORT zend_op_array* profile_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC) {
-  zend_op_array *t;
-  int i;
-  struct timeval tv_start;
-  long usec;
-
-  ea_debug_start_time(&tv_start);
-  EAG(self_time)[EAG(profile_level)] = 0;
-  t = eaccelerator_compile_file(file_handle, type TSRMLS_CC);
-  usec = ea_debug_elapsed_time(&tv_start);
-  if (EAG(profile_level) > 0)
-    EAG(self_time)[EAG(profile_level)-1] += usec;
-  for (i=0;i<EAG(profile_level);i++)
-    DBG(ea_debug_put, (EA_PROFILE_OPCODES, "  "));
-  return t;
+    int i;
+    struct timeval tv_start;
+    long usec;
+
+    for (i=0; i<EAG(profile_level); i++) {
+        DBG(ea_debug_put, (EA_PROFILE_OPCODES, "  "));
+    }
+    ea_debug_printf(EA_PROFILE_OPCODES, "enter profile_execute: %s:%s\n", op_array->filename, op_array->function_name);
+    ea_debug_start_time(&tv_start);
+    EAG(self_time)[EAG(profile_level)] = 0;
+    EAG(profile_level)++;
+    ea_debug_printf(EA_PROFILE_OPCODES, "About to enter zend_execute...\n");
+    ea_saved_zend_execute(op_array TSRMLS_CC);
+    ea_debug_printf(EA_PROFILE_OPCODES, "Finished zend_execute...\n");
+    usec = ea_debug_elapsed_time(&tv_start);
+    EAG(profile_level)--;
+    if (EAG(profile_level) > 0) {
+        EAG(self_time)[EAG(profile_level)-1] += usec;
+    }
+    for (i=0; i<EAG(profile_level); i++) {
+        DBG(ea_debug_put, (EA_PROFILE_OPCODES, "  "));
+    }
+    ea_debug_printf(EA_PROFILE_OPCODES, "leave profile_execute: %s:%s (%ld,%ld)\n", op_array->filename, op_array->function_name, usec, usec-EAG(self_time)[EAG(profile_level)]);
+}
+
+ZEND_DLEXPORT zend_op_array* profile_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC)
+{
+    zend_op_array *t;
+    int i;
+    struct timeval tv_start;
+    long usec;
+
+    ea_debug_start_time(&tv_start);
+    EAG(self_time)[EAG(profile_level)] = 0;
+    t = eaccelerator_compile_file(file_handle, type TSRMLS_CC);
+    usec = ea_debug_elapsed_time(&tv_start);
+    if (EAG(profile_level) > 0) {
+        EAG(self_time)[EAG(profile_level)-1] += usec;
+    }
+    for (i=0; i<EAG(profile_level); i++) {
+        DBG(ea_debug_put, (EA_PROFILE_OPCODES, "  "));
+    }
+    return t;
 }
 
 #endif  /* DEBUG */
 
 /* Format Bytes */
-void format_size(char* s, unsigned int size, int legend) {
-  unsigned int i = 0;
-  unsigned int n = 0;
-  char ch;
-  do {
-    if ((n != 0) && (n % 3 == 0)) {
-      s[i++] = ',';
-    }
-    s[i++] = (char)((int)'0' + (size % 10));
-    n++;
-    size = size / 10;
-  } while (size != 0);
-  s[i] = '\0';
-  n = 0; i--;
-  while (n < i) {
-    ch = s[n];
-    s[n] = s[i];
-    s[i] = ch;
-    n++, i--;
-  }
-  if (legend) {
-    strcat(s, " Bytes");
-  }
+void format_size(char* s, unsigned int size, int legend)
+{
+    unsigned int i = 0;
+    unsigned int n = 0;
+    char ch;
+    do {
+        if ((n != 0) && (n % 3 == 0)) {
+            s[i++] = ',';
+        }
+        s[i++] = (char)((int)'0' + (size % 10));
+        n++;
+        size = size / 10;
+    } while (size != 0);
+    s[i] = '\0';
+    n = 0;
+    i--;
+    while (n < i) {
+        ch = s[n];
+        s[n] = s[i];
+        s[i] = ch;
+        n++, i--;
+    }
+    if (legend) {
+        strcat(s, " Bytes");
+    }
 }
 
 /* eAccelerator entry for phpinfo() */
-PHP_MINFO_FUNCTION(eaccelerator) {
-  char s[32];
+PHP_MINFO_FUNCTION(eaccelerator)
+{
+    char s[32];
 
-  php_info_print_table_start();
-  php_info_print_table_header(2, "eAccelerator support", "enabled");
-  php_info_print_table_row(2, "Version", EACCELERATOR_VERSION);
-  php_info_print_table_row(2, "Caching Enabled", (EAG(enabled) && (ea_mm_instance != NULL) && 
-              ea_mm_instance->enabled)?"true":"false");
-  php_info_print_table_row(2, "Optimizer Enabled", (EAG(optimizer_enabled) && 
-						  (ea_mm_instance != NULL) && ea_mm_instance->optimizer_enabled)?"true":"false");
-  php_info_print_table_row(2, "Check mtime Enabled", (EAG(check_mtime_enabled) && 
-						  (ea_mm_instance != NULL) && ea_mm_instance->check_mtime_enabled)?"true":"false");
-  if (ea_mm_instance != NULL) {
-    size_t available;
-    EACCELERATOR_UNPROTECT();
-    available = mm_available(ea_mm_instance->mm);
-    EACCELERATOR_LOCK_RD();
-    EACCELERATOR_PROTECT();
-    format_size(s, ea_mm_instance->total, 1);
-    php_info_print_table_row(2, "Memory Size", s);
-    format_size(s, available, 1);
-    php_info_print_table_row(2, "Memory Available", s);
-    format_size(s, ea_mm_instance->total - available, 1);
-    php_info_print_table_row(2, "Memory Allocated", s);
-    snprintf(s, 32, "%u", ea_mm_instance->hash_cnt);
-    php_info_print_table_row(2, "Cached Scripts", s);
-    snprintf(s, 32, "%u", ea_mm_instance->rem_cnt);
-    php_info_print_table_row(2, "Removed Scripts", s);
-    EACCELERATOR_UNPROTECT();
-    EACCELERATOR_UNLOCK_RD();
-    EACCELERATOR_PROTECT();
-  }
-  php_info_print_table_end();
+    php_info_print_table_start();
+    php_info_print_table_header(2, "eAccelerator support", "enabled");
+    php_info_print_table_row(2, "Version", EACCELERATOR_VERSION);
+    php_info_print_table_row(2, "Caching Enabled", (EAG(enabled) && (ea_mm_instance != NULL) &&
+                             ea_mm_instance->enabled)?"true":"false");
+    php_info_print_table_row(2, "Optimizer Enabled", (EAG(optimizer_enabled) &&
+                             (ea_mm_instance != NULL) && ea_mm_instance->optimizer_enabled)?"true":"false");
+    php_info_print_table_row(2, "Check mtime Enabled", (EAG(check_mtime_enabled) &&
+                             (ea_mm_instance != NULL) && ea_mm_instance->check_mtime_enabled)?"true":"false");
+    if (ea_mm_instance != NULL) {
+        size_t available;
+        available = mm_available(ea_mm_instance->mm);
+        EACCELERATOR_LOCK_RD();
+        format_size(s, ea_mm_instance->total, 1);
+        php_info_print_table_row(2, "Memory Size", s);
+        format_size(s, available, 1);
+        php_info_print_table_row(2, "Memory Available", s);
+        format_size(s, ea_mm_instance->total - available, 1);
+        php_info_print_table_row(2, "Memory Allocated", s);
+        snprintf(s, 32, "%u", ea_mm_instance->hash_cnt);
+        php_info_print_table_row(2, "Cached Scripts", s);
+        snprintf(s, 32, "%u", ea_mm_instance->rem_cnt);
+        php_info_print_table_row(2, "Removed Scripts", s);
+        EACCELERATOR_UNLOCK_RD();
+    }
+    php_info_print_table_end();
 
-  DISPLAY_INI_ENTRIES();
+    DISPLAY_INI_ENTRIES();
 }
 
-/* 
+/*
  * Parse a list of filters which is seperated by a " "
  */
-static struct ea_pattern_t *ea_parse_filter(char *filter)
-{
-	char *saveptr = NULL, *token = NULL;
-	struct ea_pattern_t *list_head = NULL, *p = NULL;
-	size_t len;
-
-	// tokenize the filter string on a space
-	while ((token = php_strtok_r(filter, " ", &saveptr)) != NULL) {
-		filter = NULL;
-		list_head = malloc(sizeof(struct ea_pattern_t));
-		memset(list_head, 0, sizeof(struct ea_pattern_t));
-
-		len = strlen(token);
-		list_head->pattern = malloc(len + 1);
-		strncpy(list_head->pattern, token, len + 1); 
-		list_head->next = p;
-		p = list_head;
-	}
+static struct ea_pattern_t *ea_parse_filter(char *filter) {
+    char *saveptr = NULL, *token = NULL;
+    struct ea_pattern_t *list_head = NULL, *p = NULL;
+    size_t len;
+
+    // tokenize the filter string on a space
+    while ((token = php_strtok_r(filter, " ", &saveptr)) != NULL) {
+        filter = NULL;
+        list_head = malloc(sizeof(struct ea_pattern_t));
+        memset(list_head, 0, sizeof(struct ea_pattern_t));
+
+        len = strlen(token);
+        list_head->pattern = malloc(len + 1);
+        strncpy(list_head->pattern, token, len + 1);
+        list_head->next = p;
+        p = list_head;
+    }
 
-	return list_head;
+    return list_head;
 }
 
 /******************************************************************************/
@@ -1477,32 +1490,34 @@
  *  - standard php module,
  *  - zend extension.
  */
-PHP_INI_MH(eaccelerator_filter) {
-  EAG(pattern_list) = ea_parse_filter(new_value);
-  return SUCCESS;
-}
-
-static PHP_INI_MH(eaccelerator_OnUpdateLong) {
-  long *p = (long*)mh_arg1;
-  *p = zend_atoi(new_value, new_value_length);
-  return SUCCESS;
-}
-
-static PHP_INI_MH(eaccelerator_OnUpdateBool) {
-  zend_bool *p = (zend_bool*)mh_arg1;
-  if (strncasecmp("on", new_value, sizeof("on"))) {
-    *p = (zend_bool) atoi(new_value);
-  } else {
-    *p = (zend_bool) 1;
-  }
-  return SUCCESS;
+PHP_INI_MH(eaccelerator_filter)
+{
+    EAG(pattern_list) = ea_parse_filter(new_value);
+    return SUCCESS;
+}
+
+static PHP_INI_MH(eaccelerator_OnUpdateLong)
+{
+    long *p = (long*)mh_arg1;
+    *p = zend_atoi(new_value, new_value_length);
+    return SUCCESS;
+}
+
+static PHP_INI_MH(eaccelerator_OnUpdateBool)
+{
+    zend_bool *p = (zend_bool*)mh_arg1;
+    if (strncasecmp("on", new_value, sizeof("on"))) {
+        *p = (zend_bool) atoi(new_value);
+    } else {
+        *p = (zend_bool) 1;
+    }
+    return SUCCESS;
 }
 
 PHP_INI_BEGIN()
 STD_PHP_INI_ENTRY("eaccelerator.enable",         "1", PHP_INI_ALL, OnUpdateBool, enabled, zend_eaccelerator_globals, eaccelerator_globals)
 STD_PHP_INI_ENTRY("eaccelerator.optimizer",      "1", PHP_INI_ALL, OnUpdateBool, optimizer_enabled, zend_eaccelerator_globals, eaccelerator_globals)
 ZEND_INI_ENTRY1("eaccelerator.shm_size",        "0", PHP_INI_SYSTEM, eaccelerator_OnUpdateLong, &ea_shm_size)
-ZEND_INI_ENTRY1("eaccelerator.shm_max",         "0", PHP_INI_SYSTEM, eaccelerator_OnUpdateLong, &ea_shm_max)
 ZEND_INI_ENTRY1("eaccelerator.shm_ttl",         "0", PHP_INI_SYSTEM, eaccelerator_OnUpdateLong, &ea_shm_ttl)
 ZEND_INI_ENTRY1("eaccelerator.shm_prune_period", "0", PHP_INI_SYSTEM, eaccelerator_OnUpdateLong, &ea_shm_prune_period)
 ZEND_INI_ENTRY1("eaccelerator.debug",           "1", PHP_INI_SYSTEM, eaccelerator_OnUpdateLong, &ea_debug)
@@ -1516,435 +1531,508 @@
 PHP_INI_ENTRY("eaccelerator.filter",             "",  PHP_INI_ALL, eaccelerator_filter)
 PHP_INI_END()
 
-static void eaccelerator_clean_request(TSRMLS_D) {
-  ea_used_entry  *p = (ea_used_entry*)EAG(used_entries);
-  if (ea_mm_instance != NULL) {
-    EACCELERATOR_UNPROTECT();
-    if (p != NULL || ea_mm_instance->locks != NULL) {
-      EACCELERATOR_LOCK_RW();
-      while (p != NULL) {
-        p->entry->use_cnt--;
-        if (p->entry->removed && p->entry->use_cnt <= 0) {
-          if (ea_mm_instance->removed == p->entry) {
-            ea_mm_instance->removed = p->entry->next;
-            ea_mm_instance->rem_cnt--;
-            eaccelerator_free_nolock(p->entry);
-            p->entry = NULL;
-          } else {
-            ea_cache_entry *q = ea_mm_instance->removed;
-            while (q != NULL && q->next != p->entry) {
-              q = q->next;
-            }
-            if (q != NULL) {
-              q->next = p->entry->next;
-              ea_mm_instance->rem_cnt--;
-              eaccelerator_free_nolock(p->entry);
-              p->entry = NULL;
+static void eaccelerator_clean_request(TSRMLS_D)
+{
+    ea_used_entry  *p = (ea_used_entry*)EAG(used_entries);
+    if (ea_mm_instance != NULL) {
+        if (p != NULL) {
+            EACCELERATOR_LOCK_RW();
+            while (p != NULL) {
+                p->entry->use_cnt--;
+                if (p->entry->removed && p->entry->use_cnt <= 0) {
+                    if (ea_mm_instance->removed == p->entry) {
+                        ea_mm_instance->removed = p->entry->next;
+                        ea_mm_instance->rem_cnt--;
+                        eaccelerator_free_nolock(p->entry);
+                        p->entry = NULL;
+                    } else {
+                        ea_cache_entry *q = ea_mm_instance->removed;
+                        while (q != NULL && q->next != p->entry) {
+                            q = q->next;
+                        }
+                        if (q != NULL) {
+                            q->next = p->entry->next;
+                            ea_mm_instance->rem_cnt--;
+                            eaccelerator_free_nolock(p->entry);
+                            p->entry = NULL;
+                        }
+                    }
+                }
+                p = p->next;
             }
-          }
+            EACCELERATOR_UNLOCK_RW();
         }
-        p = p->next;
-      }
-      if (ea_mm_instance->locks != NULL) {
-        pid_t    pid    = getpid();
-#ifdef ZTS
-        THREAD_T thread = tsrm_thread_id();
-#endif
-        ea_lock_entry** p = &ea_mm_instance->locks;
-        while ((*p) != NULL) {
-#ifdef ZTS
-          if ((*p)->pid == pid && (*p)->thread == thread) {
-#else
-          if ((*p)->pid == pid) {
-#endif
-            ea_lock_entry* x = *p;
-            *p = (*p)->next;
-            eaccelerator_free_nolock(x);
-          } else {
-            p = &(*p)->next;
-          }
+        p = (ea_used_entry*)EAG(used_entries);
+        while (p != NULL) {
+            ea_used_entry* r = p;
+            p = p->next;
+            if (r->entry != NULL && r->entry->use_cnt < 0) {
+                eaccelerator_free(r->entry);
+            }
+            efree(r);
         }
-      }
-      EACCELERATOR_UNLOCK_RW();
     }
-    EACCELERATOR_PROTECT();
-    p = (ea_used_entry*)EAG(used_entries);
-    while (p != NULL) {
-      ea_used_entry* r = p;
-      p = p->next;
-      if (r->entry != NULL && r->entry->use_cnt < 0) {
-        eaccelerator_free(r->entry);
-      }
-      efree(r);
-    }
-  }
-  EAG(used_entries) = NULL;
-  EAG(in_request) = 0;
+    EAG(used_entries) = NULL;
+    EAG(in_request) = 0;
 }
 
 /* signal handlers */
 #ifdef WITH_EACCELERATOR_CRASH_DETECTION
-static void eaccelerator_crash_handler(int dummy) {
-  struct tm *loctime;
+static void eaccelerator_crash_handler(int dummy)
+{
+    struct tm *loctime;
 
-  TSRMLS_FETCH();
-  fflush(stdout);
-  fflush(stderr);
+    TSRMLS_FETCH();
+    fflush(stdout);
+    fflush(stderr);
 #ifdef SIGSEGV
-  if (EAG(original_sigsegv_handler) != eaccelerator_crash_handler) {
-    signal(SIGSEGV, EAG(original_sigsegv_handler));
-  } else {
-    signal(SIGSEGV, SIG_DFL);
-  }
+    if (EAG(original_sigsegv_handler) != eaccelerator_crash_handler) {
+        signal(SIGSEGV, EAG(original_sigsegv_handler));
+    } else {
+        signal(SIGSEGV, SIG_DFL);
+    }
 #endif
 #ifdef SIGFPE
-  if (EAG(original_sigfpe_handler) != eaccelerator_crash_handler) {
-    signal(SIGFPE, EAG(original_sigfpe_handler));
-  } else {
-    signal(SIGFPE, SIG_DFL);
-  }
+    if (EAG(original_sigfpe_handler) != eaccelerator_crash_handler) {
+        signal(SIGFPE, EAG(original_sigfpe_handler));
+    } else {
+        signal(SIGFPE, SIG_DFL);
+    }
 #endif
 #ifdef SIGBUS
-  if (EAG(original_sigbus_handler) != eaccelerator_crash_handler) {
-    signal(SIGBUS, EAG(original_sigbus_handler));
-  } else {
-    signal(SIGBUS, SIG_DFL);
-  }
+    if (EAG(original_sigbus_handler) != eaccelerator_crash_handler) {
+        signal(SIGBUS, EAG(original_sigbus_handler));
+    } else {
+        signal(SIGBUS, SIG_DFL);
+    }
 #endif
 #ifdef SIGILL
-  if (EAG(original_sigill_handler) != eaccelerator_crash_handler) {
-    signal(SIGILL, EAG(original_sigill_handler));
-  } else {
-    signal(SIGILL, SIG_DFL);
-  }
+    if (EAG(original_sigill_handler) != eaccelerator_crash_handler) {
+        signal(SIGILL, EAG(original_sigill_handler));
+    } else {
+        signal(SIGILL, SIG_DFL);
+    }
 #endif
 #ifdef SIGABRT
-  if (EAG(original_sigabrt_handler) != eaccelerator_crash_handler) {
-    signal(SIGABRT, EAG(original_sigabrt_handler));
-  } else {
-    signal(SIGABRT, SIG_DFL);
-  }
-#endif
-  eaccelerator_clean_request(TSRMLS_C);
-
-  loctime = localtime(&EAG(req_start));
-
-  if (EG(active_op_array)) {
-    fprintf(stderr, "[%s] [notice] EACCELERATOR(%d): PHP crashed on opline %ld of %s() at %s:%u\n\n",
-      asctime(loctime),
-      getpid(),
-      (long)(active_opline-EG(active_op_array)->opcodes),
-      get_active_function_name(TSRMLS_C),
-      zend_get_executed_filename(TSRMLS_C),
-      zend_get_executed_lineno(TSRMLS_C));
-  } else {
-    fprintf(stderr, "[%s] [notice] EACCELERATOR(%d): PHP crashed\n\n", asctime(loctime), getpid());
-  }
+    if (EAG(original_sigabrt_handler) != eaccelerator_crash_handler) {
+        signal(SIGABRT, EAG(original_sigabrt_handler));
+    } else {
+        signal(SIGABRT, SIG_DFL);
+    }
+#endif
+    eaccelerator_clean_request(TSRMLS_C);
+
+    loctime = localtime(&EAG(req_start));
+
+    if (EG(active_op_array)) {
+        fprintf(stderr, "[%s] [notice] EACCELERATOR(%d): PHP crashed on opline %ld of %s() at %s:%u\n\n",
+                asctime(loctime),
+                getpid(),
+                (long)(active_opline-EG(active_op_array)->opcodes),
+                get_active_function_name(TSRMLS_C),
+                zend_get_executed_filename(TSRMLS_C),
+                zend_get_executed_lineno(TSRMLS_C));
+    } else {
+        fprintf(stderr, "[%s] [notice] EACCELERATOR(%d): PHP crashed\n\n", asctime(loctime), getpid());
+    }
 #if !defined(WIN32) && !defined(NETWARE)
-  kill(getpid(), dummy);
+    kill(getpid(), dummy);
 #else
-  raise(dummy);
+    raise(dummy);
 #endif
 }
 #endif
 
 static void eaccelerator_init_globals(zend_eaccelerator_globals *eag)
 {
-	eag->used_entries = NULL;
-	eag->enabled = 1;
-	eag->cache_dir = NULL;
-	eag->optimizer_enabled = 1;
-	eag->check_mtime_enabled = 1;
-	eag->compiler = 0;
-	eag->ea_log_file = '\000';
-	eag->in_request = 0;
-	eag->allowed_admin_path= NULL;
-	eag->pattern_list = NULL;
+    eag->used_entries = NULL;
+    eag->enabled = 1;
+    eag->cache_dir = NULL;
+    eag->optimizer_enabled = 1;
+    eag->check_mtime_enabled = 1;
+    eag->compiler = 0;
+    eag->ea_log_file = '\000';
+    eag->in_request = 0;
+    eag->allowed_admin_path= NULL;
+    eag->pattern_list = NULL;
 }
 
 static void eaccelerator_globals_dtor(zend_eaccelerator_globals *eag)
 {
-	struct ea_pattern_t *p, *q;
+    struct ea_pattern_t *p, *q;
 
-	/* free the list of patterns */
-	p = eag->pattern_list;
-	while (p != NULL) {
-		q = p->next;
-		free(p->pattern);
-		free(p);
-		p = q;
-	}
-	eag->pattern_list = NULL;
+    /* free the list of patterns */
+    p = eag->pattern_list;
+    while (p != NULL) {
+        q = p->next;
+        free(p->pattern);
+        free(p);
+        p = q;
+    }
+    eag->pattern_list = NULL;
 }
 
 static void register_eaccelerator_as_zend_extension();
 
-static int eaccelerator_check_php_version(TSRMLS_D) {
-  zval v;
-  int ret = 0;
-  if (zend_get_constant("PHP_VERSION", sizeof("PHP_VERSION")-1, &v TSRMLS_CC)) {
-    if (Z_TYPE(v) == IS_STRING &&
-        Z_STRLEN(v) == sizeof(PHP_VERSION)-1 &&
-        strcmp(Z_STRVAL(v),PHP_VERSION) == 0) {
-      ret = 1;
+static int eaccelerator_check_php_version(TSRMLS_D)
+{
+    zval v;
+    int ret = 0;
+    if (zend_get_constant("PHP_VERSION", sizeof("PHP_VERSION")-1, &v TSRMLS_CC)) {
+        if (Z_TYPE(v) == IS_STRING &&
+                Z_STRLEN(v) == sizeof(PHP_VERSION)-1 &&
+                strcmp(Z_STRVAL(v),PHP_VERSION) == 0) {
+            ret = 1;
+        } else {
+            ea_debug_error("[%s] This build of \"%s\" was compiled for PHP version %s. Rebuild it for your PHP version (%s) or download precompiled binaries.\n",
+                           EACCELERATOR_EXTENSION_NAME, EACCELERATOR_EXTENSION_NAME,PHP_VERSION,Z_STRVAL(v));
+        }
+        zval_dtor(&v);
     } else {
-      ea_debug_error("[%s] This build of \"%s\" was compiled for PHP version %s. Rebuild it for your PHP version (%s) or download precompiled binaries.\n", 
-					EACCELERATOR_EXTENSION_NAME, EACCELERATOR_EXTENSION_NAME,PHP_VERSION,Z_STRVAL(v));
+        ea_debug_error("[%s] This build of \"%s\" was compiled for PHP version %s. Rebuild it for your PHP version.\n",
+                       EACCELERATOR_EXTENSION_NAME, EACCELERATOR_EXTENSION_NAME, PHP_VERSION);
     }
-    zval_dtor(&v);
-  } else {
-    ea_debug_error("[%s] This build of \"%s\" was compiled for PHP version %s. Rebuild it for your PHP version.\n",
-				EACCELERATOR_EXTENSION_NAME, EACCELERATOR_EXTENSION_NAME, PHP_VERSION);
-  }
-  return ret;
+    return ret;
 }
 
-static void make_hash_dirs(char *fullpath, int lvl) {
-  int j;
-  int n = strlen(fullpath);
-  mode_t old_umask = umask(0);
-  
-  if (lvl < 1)
-    return;
-  if (fullpath[n-1] != '/')
-    fullpath[n++] = '/';
-  
-  for (j = 0; j < 16; j++) {
-    fullpath[n] = num2hex[j];       
-    fullpath[n+1] = 0;
-    mkdir(fullpath, 0777);
-    make_hash_dirs(fullpath, lvl-1);
-  }
-  fullpath[n+2] = 0;
-  umask(old_umask);
+/*
+ * Create a hash directory
+ */
+static void make_hash_dirs(char *fullpath, int lvl)
+{
+    int j;
+    int n = strlen(fullpath);
+
+    //ea_debug_error("Creating hash in %s at level %d\n", fullpath, lvl);
+
+    if (lvl < 1) {
+        return;
+    }
+
+    if (fullpath[n-1] != '/') {
+        fullpath[n++] = '/';
+    }
+
+    for (j = 0; j < 16; j++) {
+        fullpath[n] = num2hex[j];
+        fullpath[n+1] = 0;
+        mkdir(fullpath, 0700);
+        make_hash_dirs(fullpath, lvl-1);
+    }
+    fullpath[n+2] = 0;
 }
 
+/*
+ * Initialise the cache directory for use
+ */
+static void init_cache_dir(const char *cache_path)
+{
+    char fullpath[MAXPATHLEN];
+    uid_t uid = getuid();
+    mode_t old_umask = umask(077);
+    struct stat buffer;
+
+    snprintf(fullpath, MAXPATHLEN-1, "%s/%d/", cache_path, uid);
+    if (lstat(fullpath, &buffer) != 0) {
+        // error, create the directory
+        if (mkdir(fullpath, 0700) != 0) {
+            ea_debug_error("Unable to create cachedir %s\n", fullpath);
+            return;
+        }
+    } else if (!S_ISDIR(buffer.st_mode)) {
+        // not a directory
+        ea_debug_error("Cachedir %s exists but is not a directory\n",
+                       fullpath);
+        return;
+    }
+
+    // create the hashed dirs
+    make_hash_dirs(fullpath, EACCELERATOR_HASH_LEVEL);
+
+    umask(old_umask);
 
-PHP_MINIT_FUNCTION(eaccelerator) {
-  char fullpath[MAXPATHLEN];
+    ea_mm_instance->cache_dir_uid = uid;
+}
 
-  if (type == MODULE_PERSISTENT) {
+/*
+ * Check if the cache dir exists and is world-writable so the forked process
+ * can create the cache directories
+ */
+static void check_cache_dir(const char *cache_path)
+{
+    struct stat buffer;
+    mode_t old_umask = umask(0);
+
+    int status = stat(cache_path, &buffer);
+
+    if (status == 0) {
+        // check permissions
+        if (buffer.st_mode != 777) {
+            status = chmod(cache_path, 0777);
+            if (status < 0) {
+                ea_debug_error(
+                    "eAccelerator: Unable to change cache directory %s permissions\n",
+                    cache_path);
+            }
+        }
+    } else {
+        // create the cache directory if possible
+        status = mkdir(cache_path, 0777);
+        if (status < 0) {
+            ea_debug_error("eAccelerator: Unable to create cache directory %s\n", cache_path);
+        }
+    }
+
+    umask(old_umask);
+}
+
+PHP_MINIT_FUNCTION(eaccelerator)
+{
+    if (type == MODULE_PERSISTENT) {
 #ifndef ZEND_WIN32
-    if (strcmp(sapi_module.name,"apache") == 0) {
-      if (getpid() != getpgrp()) {
+        if (strcmp(sapi_module.name,"apache") == 0) {
+            if (getpid() != getpgrp()) {
+                return SUCCESS;
+            }
+        }
+#endif
+    }
+    if (!eaccelerator_check_php_version(TSRMLS_C)) {
+        /*
+        	 * do not return FAILURE, because it causes PHP to completely fail.
+        	 * Just disable eAccelerator instead of making eA fail starting php
+        	 */
         return SUCCESS;
-      }
     }
-#endif
-  }
-  if (!eaccelerator_check_php_version(TSRMLS_C)) {
-    /* 
-		 * do not return FAILURE, because it causes PHP to completely fail.
-		 * Just disable eAccelerator instead of making eA fail starting php
-		 */
-    return SUCCESS;
-  }
-  ZEND_INIT_MODULE_GLOBALS(eaccelerator, eaccelerator_init_globals, NULL);
-  REGISTER_INI_ENTRIES();
-  REGISTER_STRING_CONSTANT("EACCELERATOR_VERSION", EACCELERATOR_VERSION, CONST_CS | CONST_PERSISTENT);
-  REGISTER_LONG_CONSTANT("EACCELERATOR_SHM_AND_DISK", ea_shm_and_disk, CONST_CS | CONST_PERSISTENT);
-  REGISTER_LONG_CONSTANT("EACCELERATOR_SHM", ea_shm, CONST_CS | CONST_PERSISTENT);
-  REGISTER_LONG_CONSTANT("EACCELERATOR_SHM_ONLY", ea_shm_only, CONST_CS | CONST_PERSISTENT);
-  REGISTER_LONG_CONSTANT("EACCELERATOR_DISK_ONLY", ea_disk_only, CONST_CS | CONST_PERSISTENT);
-  REGISTER_LONG_CONSTANT("EACCELERATOR_NONE", ea_none, CONST_CS | CONST_PERSISTENT);
-  encode_version(EACCELERATOR_VERSION, &binary_eaccelerator_version[0], &binary_eaccelerator_version[1]);
-  encode_version(PHP_VERSION, &binary_php_version[0], &binary_php_version[1]);
-  encode_version(ZEND_VERSION, &binary_zend_version[0], &binary_zend_version[1]);
-  ea_is_extension = 1;
+    ZEND_INIT_MODULE_GLOBALS(eaccelerator, eaccelerator_init_globals, NULL);
+    REGISTER_INI_ENTRIES();
+    REGISTER_STRING_CONSTANT("EACCELERATOR_VERSION", EACCELERATOR_VERSION, CONST_CS | CONST_PERSISTENT);
+    REGISTER_LONG_CONSTANT("EACCELERATOR_SHM_AND_DISK", ea_shm_and_disk, CONST_CS | CONST_PERSISTENT);
+    REGISTER_LONG_CONSTANT("EACCELERATOR_SHM", ea_shm, CONST_CS | CONST_PERSISTENT);
+    REGISTER_LONG_CONSTANT("EACCELERATOR_SHM_ONLY", ea_shm_only, CONST_CS | CONST_PERSISTENT);
+    REGISTER_LONG_CONSTANT("EACCELERATOR_DISK_ONLY", ea_disk_only, CONST_CS | CONST_PERSISTENT);
+    REGISTER_LONG_CONSTANT("EACCELERATOR_NONE", ea_none, CONST_CS | CONST_PERSISTENT);
+    encode_version(EACCELERATOR_VERSION, &binary_eaccelerator_version[0], &binary_eaccelerator_version[1]);
+    encode_version(PHP_VERSION, &binary_php_version[0], &binary_php_version[1]);
+    encode_version(ZEND_VERSION, &binary_zend_version[0], &binary_zend_version[1]);
+    ea_is_extension = 1;
 
-  ea_debug_init(TSRMLS_C);
+    ea_debug_init(TSRMLS_C);
 
-  if(!ea_scripts_shm_only) {
-    snprintf(fullpath, MAXPATHLEN-1, "%s/", EAG(cache_dir));
-    make_hash_dirs(fullpath, EACCELERATOR_HASH_LEVEL);
-  }
-
-  if (type == MODULE_PERSISTENT &&
-      strcmp(sapi_module.name, "cgi") != 0 &&
-      strcmp(sapi_module.name, "cli") != 0) {
-    DBG(ea_debug_put, (EA_DEBUG, "\n=======================================\n"));
-    DBG(ea_debug_printf, (EA_DEBUG, "[%d] EACCELERATOR STARTED\n", getpid()));
-    DBG(ea_debug_put, (EA_DEBUG, "=======================================\n"));
-
-    if (init_mm(TSRMLS_C) == FAILURE) {
-      zend_error(E_CORE_WARNING,"[%s] Can not create shared memory area", EACCELERATOR_EXTENSION_NAME);
-      return FAILURE;
+#ifndef ZEND_WIN32
+    if (!ea_scripts_shm_only) {
+        check_cache_dir(EAG(cache_dir));
     }
-    ea_saved_zend_compile_file = zend_compile_file;
+#endif
+
+    if (type == MODULE_PERSISTENT &&
+            strcmp(sapi_module.name, "cgi") != 0 &&
+            strcmp(sapi_module.name, "cli") != 0) {
+        DBG(ea_debug_put, (EA_DEBUG, "\n=======================================\n"));
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] EACCELERATOR STARTED\n", getpid()));
+        DBG(ea_debug_put, (EA_DEBUG, "=======================================\n"));
+
+        if (init_mm(TSRMLS_C) == FAILURE) {
+            zend_error(E_CORE_WARNING,"[%s] Can not create shared memory area", EACCELERATOR_EXTENSION_NAME);
+            return FAILURE;
+        }
+        ea_saved_zend_compile_file = zend_compile_file;
 
 #ifdef DEBUG
-    zend_compile_file = profile_compile_file;
-    ea_saved_zend_execute = zend_execute;
-    zend_execute = profile_execute;
+        zend_compile_file = profile_compile_file;
+        ea_saved_zend_execute = zend_execute;
+        zend_execute = profile_execute;
 #else
-    zend_compile_file = eaccelerator_compile_file;
+        zend_compile_file = eaccelerator_compile_file;
 #endif
-  }
-  
-  if (!ea_is_zend_extension) {
-    register_eaccelerator_as_zend_extension();
-  }
-  
-  /* cache the properties_info destructor */
-  properties_info_dtor = get_zend_destroy_property_info(TSRMLS_C);
-  return SUCCESS;
-}
+    }
+
+    if (!ea_is_zend_extension) {
+        register_eaccelerator_as_zend_extension();
+    }
 
-PHP_MSHUTDOWN_FUNCTION(eaccelerator) {
-  if (ea_mm_instance == NULL || !ea_is_extension) {
+    /* cache the properties_info destructor */
+    properties_info_dtor = get_zend_destroy_property_info(TSRMLS_C);
     return SUCCESS;
-  }
-  zend_compile_file = ea_saved_zend_compile_file;
-  shutdown_mm(TSRMLS_C);
-  DBG(ea_debug_put, (EA_DEBUG, "========================================\n"));
-  DBG(ea_debug_printf, (EA_DEBUG, "[%d] EACCELERATOR STOPPED\n", getpid()));
-  DBG(ea_debug_put, (EA_DEBUG, "========================================\n\n"));
-  ea_debug_shutdown();
-  UNREGISTER_INI_ENTRIES();
+}
+
+PHP_MSHUTDOWN_FUNCTION(eaccelerator)
+{
+    if (ea_mm_instance == NULL || !ea_is_extension) {
+        return SUCCESS;
+    }
+    zend_compile_file = ea_saved_zend_compile_file;
+    shutdown_mm(TSRMLS_C);
+    DBG(ea_debug_put, (EA_DEBUG, "========================================\n"));
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] EACCELERATOR STOPPED\n", getpid()));
+    DBG(ea_debug_put, (EA_DEBUG, "========================================\n\n"));
+    ea_debug_shutdown();
+    UNREGISTER_INI_ENTRIES();
 #ifdef ZTS
-  ts_free_id(eaccelerator_globals_id);
+    ts_free_id(eaccelerator_globals_id);
 #else
-  eaccelerator_globals_dtor(&eaccelerator_globals TSRMLS_CC);
+    eaccelerator_globals_dtor(&eaccelerator_globals TSRMLS_CC);
 #endif
-  ea_is_zend_extension = 0;
-  ea_is_extension = 0;
-  return SUCCESS;
+    ea_is_zend_extension = 0;
+    ea_is_extension = 0;
+    return SUCCESS;
 }
 
 PHP_RINIT_FUNCTION(eaccelerator)
 {
-	if (ea_mm_instance == NULL) {
-		return SUCCESS;
-	}
-
-	DBG(ea_debug_printf, (EA_DEBUG, "[%d] Enter RINIT\n",getpid()));
-	DBG(ea_debug_put, (EA_PROFILE_OPCODES, "\n========================================\n"));
-
-	EAG(in_request) = 1;
-	EAG(used_entries) = NULL;
-	EAG(compiler) = 0;
-	EAG(refcount_helper) = 1;
-	EAG(req_start) = sapi_get_request_time(TSRMLS_C);	/* record request start time for later use */
+    if (ea_mm_instance == NULL) {
+        return SUCCESS;
+    }
 
-	zend_hash_init(&EAG(restored), 0, NULL, NULL, 0);
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Enter RINIT\n",getpid()));
+    DBG(ea_debug_put, (EA_PROFILE_OPCODES, "\n========================================\n"));
+
+    EAG(in_request) = 1;
+    EAG(used_entries) = NULL;
+    EAG(compiler) = 0;
+    EAG(refcount_helper) = 1;
+    EAG(req_start) = sapi_get_request_time(TSRMLS_C);	/* record request start time for later use */
+
+    zend_hash_init(&EAG(restored), 0, NULL, NULL, 0);
 
 #ifdef DEBUG
-	EAG(xpad) = 0;
-	EAG(profile_level) = 0;
+    EAG(xpad) = 0;
+    EAG(profile_level) = 0;
 #endif
 
 #ifdef WITH_EACCELERATOR_CRASH_DETECTION
 #ifdef SIGSEGV
-	EAG(original_sigsegv_handler) = signal(SIGSEGV, eaccelerator_crash_handler);
+    EAG(original_sigsegv_handler) = signal(SIGSEGV, eaccelerator_crash_handler);
 #endif
 #ifdef SIGFPE
-	EAG(original_sigfpe_handler) = signal(SIGFPE, eaccelerator_crash_handler);
+    EAG(original_sigfpe_handler) = signal(SIGFPE, eaccelerator_crash_handler);
 #endif
 #ifdef SIGBUS
-	EAG(original_sigbus_handler) = signal(SIGBUS, eaccelerator_crash_handler);
+    EAG(original_sigbus_handler) = signal(SIGBUS, eaccelerator_crash_handler);
 #endif
 #ifdef SIGILL
-	EAG(original_sigill_handler) = signal(SIGILL, eaccelerator_crash_handler);
+    EAG(original_sigill_handler) = signal(SIGILL, eaccelerator_crash_handler);
 #endif
 #ifdef SIGABRT
-	EAG(original_sigabrt_handler) = signal(SIGABRT, eaccelerator_crash_handler);
+    EAG(original_sigabrt_handler) = signal(SIGABRT, eaccelerator_crash_handler);
+#endif
 #endif
+
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave RINIT\n",getpid()));
+
+#ifndef ZEND_WIN32
+    if (!ea_scripts_shm_only && ea_mm_instance->cache_dir_uid != getuid()) {
+        // lock this operation with a global eA lock and do the check again
+        // to avoid multiple calls during startup
+        EACCELERATOR_LOCK_RW();
+        if (ea_mm_instance->cache_dir_uid != getuid()) {
+            init_cache_dir(EAG(cache_dir));
+        }
+        EACCELERATOR_UNLOCK();
+    }
+#else
+    if(!ea_scripts_shm_only) {
+        char fullpath[MAXPATHLEN];
+
+        snprintf(fullpath, MAXPATHLEN-1, "%s/", EAG(cache_dir));
+        make_hash_dirs(fullpath, EACCELERATOR_HASH_LEVEL);
+    }
 #endif
 
-	DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave RINIT\n",getpid()));
-	
-	return SUCCESS;
+    return SUCCESS;
 }
 
 PHP_RSHUTDOWN_FUNCTION(eaccelerator)
 {
-	if (ea_mm_instance == NULL) {
-		return SUCCESS;
-	}
-	zend_hash_destroy(&EAG(restored));
+    if (ea_mm_instance == NULL) {
+        return SUCCESS;
+    }
+    zend_hash_destroy(&EAG(restored));
 #ifdef WITH_EACCELERATOR_CRASH_DETECTION
 #ifdef SIGSEGV
-	if (EAG(original_sigsegv_handler) != eaccelerator_crash_handler) {
-		signal(SIGSEGV, EAG(original_sigsegv_handler));
-	} else {
-		signal(SIGSEGV, SIG_DFL);
-	}
+    if (EAG(original_sigsegv_handler) != eaccelerator_crash_handler) {
+        signal(SIGSEGV, EAG(original_sigsegv_handler));
+    } else {
+        signal(SIGSEGV, SIG_DFL);
+    }
 #endif
 #ifdef SIGFPE
-	if (EAG(original_sigfpe_handler) != eaccelerator_crash_handler) {
-		signal(SIGFPE, EAG(original_sigfpe_handler));
-	} else {
-		signal(SIGFPE, SIG_DFL);
-	}
+    if (EAG(original_sigfpe_handler) != eaccelerator_crash_handler) {
+        signal(SIGFPE, EAG(original_sigfpe_handler));
+    } else {
+        signal(SIGFPE, SIG_DFL);
+    }
 #endif
 #ifdef SIGBUS
-	if (EAG(original_sigbus_handler) != eaccelerator_crash_handler) {
-		signal(SIGBUS, EAG(original_sigbus_handler));
-	} else {
-		signal(SIGBUS, SIG_DFL);
-	}
+    if (EAG(original_sigbus_handler) != eaccelerator_crash_handler) {
+        signal(SIGBUS, EAG(original_sigbus_handler));
+    } else {
+        signal(SIGBUS, SIG_DFL);
+    }
 #endif
 #ifdef SIGILL
-	if (EAG(original_sigill_handler) != eaccelerator_crash_handler) {
-		signal(SIGILL, EAG(original_sigill_handler));
-	} else {
-		signal(SIGILL, SIG_DFL);
-	}
+    if (EAG(original_sigill_handler) != eaccelerator_crash_handler) {
+        signal(SIGILL, EAG(original_sigill_handler));
+    } else {
+        signal(SIGILL, SIG_DFL);
+    }
 #endif
 #ifdef SIGABRT
-	if (EAG(original_sigabrt_handler) != eaccelerator_crash_handler) {
-		signal(SIGABRT, EAG(original_sigabrt_handler));
-	} else {
-		signal(SIGABRT, SIG_DFL);
-	}
+    if (EAG(original_sigabrt_handler) != eaccelerator_crash_handler) {
+        signal(SIGABRT, EAG(original_sigabrt_handler));
+    } else {
+        signal(SIGABRT, SIG_DFL);
+    }
 #endif
 #endif
-	DBG(ea_debug_printf, (EA_DEBUG, "[%d] Enter RSHUTDOWN\n",getpid()));
-	eaccelerator_clean_request(TSRMLS_C);
-	DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave RSHUTDOWN\n",getpid()));
-	return SUCCESS;
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Enter RSHUTDOWN\n",getpid()));
+    eaccelerator_clean_request(TSRMLS_C);
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] Leave RSHUTDOWN\n",getpid()));
+    return SUCCESS;
 }
 
 ZEND_BEGIN_ARG_INFO(eaccelerator_second_arg_force_ref, 0)
-  ZEND_ARG_PASS_INFO(0)
-  ZEND_ARG_PASS_INFO(1)
+ZEND_ARG_PASS_INFO(0)
+ZEND_ARG_PASS_INFO(1)
 ZEND_END_ARG_INFO();
 
-function_entry eaccelerator_functions[] = {
+zend_function_entry eaccelerator_functions[] = {
 #ifdef WITH_EACCELERATOR_INFO
-  PHP_FE(eaccelerator_caching, NULL)
-  PHP_FE(eaccelerator_clear, NULL)
-	PHP_FE(eaccelerator_clean, NULL)
-  PHP_FE(eaccelerator_info, NULL)
-  PHP_FE(eaccelerator_purge, NULL)
-  PHP_FE(eaccelerator_cached_scripts, NULL)
-  PHP_FE(eaccelerator_removed_scripts, NULL)
-  PHP_FE(eaccelerator_check_mtime, NULL)
-  #ifdef WITH_EACCELERATOR_OPTIMIZER
+    PHP_FE(eaccelerator_caching, NULL)
+    PHP_FE(eaccelerator_clear, NULL)
+    PHP_FE(eaccelerator_clean, NULL)
+    PHP_FE(eaccelerator_info, NULL)
+    PHP_FE(eaccelerator_purge, NULL)
+    PHP_FE(eaccelerator_cached_scripts, NULL)
+    PHP_FE(eaccelerator_removed_scripts, NULL)
+    PHP_FE(eaccelerator_check_mtime, NULL)
+#ifdef WITH_EACCELERATOR_OPTIMIZER
     PHP_FE(eaccelerator_optimizer, NULL)
-  #endif
+#endif
 #endif
 #ifdef WITH_EACCELERATOR_DISASSEMBLER
-  PHP_FE(eaccelerator_dasm_file, NULL)
+    PHP_FE(eaccelerator_dasm_file, NULL)
 #endif
-  {NULL, NULL, NULL, 0U, 0U}
+    {
+        NULL, NULL, NULL, 0U, 0U
+    }
 };
 
 zend_module_entry eaccelerator_module_entry = {
 #if ZEND_MODULE_API_NO >= 20010901
-  STANDARD_MODULE_HEADER,
+    STANDARD_MODULE_HEADER,
 #endif
-  EACCELERATOR_EXTENSION_NAME,
-  eaccelerator_functions,
-  PHP_MINIT(eaccelerator),
-  PHP_MSHUTDOWN(eaccelerator),
-  PHP_RINIT(eaccelerator),
-  PHP_RSHUTDOWN(eaccelerator),
-  PHP_MINFO(eaccelerator),
+    EACCELERATOR_EXTENSION_NAME,
+    eaccelerator_functions,
+    PHP_MINIT(eaccelerator),
+    PHP_MSHUTDOWN(eaccelerator),
+    PHP_RINIT(eaccelerator),
+    PHP_RSHUTDOWN(eaccelerator),
+    PHP_MINFO(eaccelerator),
 #if ZEND_MODULE_API_NO >= 20010901
-  EACCELERATOR_VERSION,          /* extension version number (string) */
+    EACCELERATOR_VERSION,          /* extension version number (string) */
 #endif
-  STANDARD_MODULE_PROPERTIES
+    STANDARD_MODULE_PROPERTIES
 };
 
 #if defined(COMPILE_DL_EACCELERATOR)
@@ -1955,163 +2043,165 @@
 static zend_llist_element *eaccelerator_el;
 
 static const unsigned char eaccelerator_logo[] = {
-      71,  73,  70,  56,  57,  97,  88,   0,  31,   0, 
-     213,   0,   0, 150, 153, 196, 237, 168,  86, 187, 
-     206, 230,   4,   4,   4, 108, 110, 144,  99, 144, 
-     199, 136, 138, 184,  87,  88, 109, 165, 165, 167, 
-     163, 166, 202, 240, 151,  44, 149,  91,  21, 225, 
-     225, 229,   4,  76, 164, 252, 215, 171, 255, 255, 
-     255, 212, 212, 224, 241, 200, 149, 141, 144, 192, 
-     216, 216, 226, 251, 230, 205, 192, 193, 218, 207, 
-     221, 238, 181, 188, 216, 130, 132, 168, 150, 152, 
-     185, 152, 152, 154, 180, 181, 198, 215, 184, 147, 
-      40, 102, 177, 224, 232, 242, 244, 244, 244, 235, 
-     236, 239, 118, 121, 157, 193, 193, 194, 146, 148, 
-     174, 181, 143,  96, 154, 183, 219, 156, 159, 200, 
-     126, 128, 170, 174, 175, 193,  65,  39,   7, 232, 
-     214, 192, 254, 241, 226, 246, 246, 248, 108,  65, 
-      13, 142, 144, 185, 252, 224, 189, 138, 171, 213, 
-      69, 122, 188, 239, 244, 249,  48,  49,  60, 176, 
-     178, 209, 200, 201, 222, 252, 252, 253, 251, 251, 
-     251, 162, 163, 187, 208, 208, 213, 169, 171, 205, 
-     241, 234, 225, 255, 252, 249, 254, 248, 241, 140, 
-     142, 169, 249, 186, 111,  33, 249,   4,   0,   0, 
-       0,   0,   0,  44,   0,   0,   0,   0,  88,   0, 
-      31,   0,   0,   6, 255,  64, 137, 112,  72,  44, 
-      26, 143, 200, 164, 114, 201,  92,  62, 158, 208, 
-     168, 116,  74, 173,  90, 175, 216, 108,  85, 168, 
-     237, 122, 191,  15,  25, 163, 118, 209, 153,   0, 
-      68, 128,  73, 119, 169,  49, 100,  86,  46, 120, 
-      78, 127, 216,  60,  21,  93,  83,   8, 208,  85, 
-      60,  54,  83, 114, 117, 132,  89,  32,  23,  38, 
-      73,  38, 103,  72,  38,  23,  32,  82, 123, 146, 
-     147,  69, 106,   9,  52,  21,  19,  53, 137, 138, 
-      51,  51, 156, 141,  21, 100,  52,   9, 148, 166, 
-     123,   0, 106, 126,  16,  21, 104,  67, 169, 106, 
-     140,   9,   3, 159, 140,  18, 176, 182,   0,  23, 
-      21, 101,  67,  21,  80,  32,  52, 192,  52,  44, 
-       6,  16,  15,   6,  23,  44,  81,  24,  81,  25, 
-      81, 194,  80,  25,   6,  18,  12,  80,  23,  15, 
-     169,  15, 172, 155, 105,  33,   7,   4, 158,  46, 
-       0,  33,   3,   7,   7,  51,   7, 139, 231, 225, 
-       7,  25, 124,  23,  23,  52, 190,  19,   4, 205, 
-      44,  27,   4,   4,  19,  57,  15,  33,  15,  32, 
-      54,  64, 168, 241,   0,   5,  10,  28, 255,  54, 
-     160, 120, 128, 163, 160,  65,   2,  15, 244, 229, 
-     200, 113, 162,  26,   4,  20, 252,  22, 130, 128, 
-      48,  98, 131,  30,  34,  38, 102, 208,  58,  64, 
-     203,   4,  73, 115,   3,   6, 184, 152,  69,  75, 
-     228,   1,  87,  38,  80, 204,  19, 242, 235,   9, 
-      54,  31,   4,  78, 212, 152, 192, 128,   1,   8, 
-     255,  31,  79,  78, 108,  99, 245, 239,  24,   3, 
-     136,  16,  32, 212, 139,  24,  34,  83,   8,   3, 
-      62,  33, 128,  56,  90,   3,  68, 136,  17, 173, 
-     138, 176,  76,  16, 114,  64,   2, 145,   4,   0, 
-     136, 196, 128, 129,  22, 215, 146,  66,  50, 224, 
-     248,  40,  33, 147,  62,   2,  11,  39, 120, 120, 
-      48, 162,  33,  10,   2,  44,  62,  64, 156, 144, 
-     244,  31, 129,  17,  12,  31, 240, 157, 240,  76, 
-     238, 131,  12,   4, 160, 110,   4,   1, 130, 192, 
-       6,   6,  33, 112, 212,  48, 226, 195, 220,  25, 
-     145,  95, 189, 118,  77,  64,  50, 236, 172,  79, 
-      66,  92, 140,  96,  11,   0,  71,  78,  12,  39, 
-      12, 108, 200,  71,  32,  68, 190,  16,  38,  70, 
-      56,  54, 120,  87,  71, 136,  16,  25,  70,  36, 
-     160, 141,  65,  33,  10,  12,  57,  13,  36, 240, 
-     173,  15,  64,   2,  31,  58, 186, 189,  34,  96, 
-     238,  86,  73,  90, 198,  75, 146,  12,   1, 128, 
-     249, 203, 208,  62,  74,   9,  49,  96,   0,   3, 
-      53,   9,   6,  78, 220,  78, 141, 218, 251, 137, 
-      19, 168, 199, 163, 230,  46, 254, 246, 120, 247, 
-     169, 193, 183, 127, 234,  34,  67,   6,  63,  51, 
-     249, 156,  12,  55, 160, 181,  57, 114, 255, 137, 
-      52,   3, 127,  62,  12, 129,  65, 118,  74, 112, 
-     247,  29, 120, 219,  81, 163, 224, 130, 224,  61, 
-      40, 225, 130,  15, 222, 162,  74,  60, 160, 116, 
-     181,  95,   6,  36, 189, 212, 255, 225, 103,  39, 
-      97, 224,  74, 119, 186, 157,  98, 162,  18, 169, 
-     172,  65,   3,  13,  40, 184, 178, 149,  14,   9, 
-     160,  97,   2,  87,  18, 204, 104,  66,  89,  51, 
-      24,  23, 163,  16,  62, 132, 224, 195,  90,  39, 
-       6, 121, 132,  37,  58, 176, 136, 195,  59,  46, 
-     152, 133,  98, 135, 174,   8, 129, 129, 143,  56, 
-      36, 160,  93,  33,  84,  82,  97,   3,  11,  12, 
-     136, 128,   3,  66, 227,  44,  49,   2, 110,  67, 
-     248, 224, 131,   6,  34,  48, 176, 204,   3, 131, 
-      84, 169, 230,  19,  44, 128, 144, 195,   6,  71, 
-     190, 179,   4,  26,  46, 136, 169,   1,  10,  57, 
-     236, 192,   2,  15,  79, 164, 185, 166, 154,  55, 
-     124, 192, 192, 155,   8, 228,  54, 130,  11, 136, 
-     134,  86, 167, 152,  99,  34, 176,  65,  14,  12, 
-     124,  16,   8,  20, 126,  62, 176,   2,   5,  20, 
-     188, 160, 233, 166, 155,  58, 224, 105,   4,  61, 
-     252,  73,  69, 160,  59,  12,  42,   2,  10,   8, 
-      32, 160, 193, 170, 171, 166, 138, 130,   8, 144, 
-     238, 240,   1, 159, 145,  72,   0,   5,  15,  20, 
-      56,  16,  65,   4,  63,   4, 224, 171,   2,   1, 
-       0, 171, 192, 176, 195,   6,  32, 234,  21, 129, 
-     126,  48,  85,  79, 204,  50,  43, 235,   7,  55, 
-     196,  97, 171, 165, 159, 254, 240, 195, 176,  63, 
-     188, 240,   0, 173,  80, 244, 192, 194, 153,   2, 
-     192, 113, 236, 184, 114, 172,  96, 174, 185, 152, 
-      82, 160, 255, 133,   7,  13,  20, 240, 132,  12, 
-       5, 196,  80, 192,  92,  15, 192,  32, 175,   0, 
-      15,  88,  16, 195, 190,  22, 148, 224, 238,  19, 
-     250, 242,  27, 176, 188, 226, 198, 128, 205, 190, 
-     252, 202,  96, 111,   1, 248,  62, 128, 112,   1, 
-      22,  80, 106, 235,  11,  14,  80, 188, 107, 175, 
-     190, 250, 106,  45, 198,   1, 144, 192, 193,  19, 
-       5,  52, 208,  64,  24,  29, 116,  96, 111,   3, 
-     240,  54,   0,  67, 200,   2,   8, 160,  50,  12, 
-      30, 216,  11, 133, 203,  48, 192,  76,  51,  12, 
-     237,  62, 112,  65, 187,  54, 216, 107, 178,   7, 
-      49, 168,  28,  52, 190, 237, 194,  80, 178, 196, 
-      43, 108,  28, 172,   2,  11, 120, 204, 193, 211, 
-      17, 112, 176, 235, 211,  28, 236, 240,  68,   7, 
-      33, 151, 128, 179, 184,  45,  55,  32,  64, 180, 
-      22, 120, 224, 114, 203,  10, 199,  48, 179, 215, 
-     225, 186,  12, 178, 217,  33, 163,  92, 175, 217, 
-      22, 120, 125, 131,  13, 242,  62, 224, 117, 189, 
-      35, 247,  41, 129,   3, 196,  50, 189,  64,  11, 
-      36, 216,  48, 183,  29,  79,   4,  98, 195, 164, 
-      46, 119,  80, 180, 217, 103,  75, 225, 178, 200, 
-       2, 200, 252, 196, 227, 104, 139,  44, 242,   5, 
-      50,  52, 160,  56,  12, 111,  63, 160, 246,  19, 
-     246, 218,  96, 121, 206, 122, 191, 224, 247, 223, 
-      45, 164, 238, 244, 174, 172,  63, 173, 238,   3, 
-       5, 152,  28,  50, 206,  17,  43,  76, 154,  51, 
-     232,  93,  67,  33, 185, 231, 121, 243,  46,  64, 
-      12,  29,  60,  80, 130, 208, 193, 203, 204,  46, 
-     231,  50,  96, 109, 119, 205,  13, 208, 139, 166, 
-     173,  42, 144, 176,  64,  10, 212,  87, 159, 250, 
-       2, 216, 103, 191, 192,  14, 129, 168, 252, 132, 
-     202,  33,   7,  93, 188, 230, 138, 139, 221,   0, 
-     191,  56, 239, 203, 240, 249,  49,  88, 160, 118, 
-     220,  43, 155, 189, 115, 204, 140, 227, 172, 120, 
-     243, 118, 135, 139, 245, 164, 149,  78,  74, 248, 
-     220, 130, 187, 193, 224,  30,  16,  51, 113, 149, 
-     160,   4,  54, 208,  90,   9, 102,  86,  51,  56, 
-     196, 172, 102,  98, 171,  25,  12,  74, 240,  64, 
-     152, 197, 204,  38,  53, 139,  88, 189,  90, 182, 
-     192, 201, 213, 236,  76,  48, 179, 129,   5,  96, 
-     166, 183, 113, 153,  80,  77,  66,  74, 161,  10, 
-      41,  17,   4,   0,  59,   0 };
- 
-static int eaccelerator_last_startup(zend_extension *extension) {
-  int ret;
-  extension->startup = last_startup;
-  ret = extension->startup(extension);
-  zend_extensions.count++;
-  eaccelerator_el->next = zend_extensions.head;
-  eaccelerator_el->prev = NULL;
-  zend_extensions.head->prev = eaccelerator_el;
-  zend_extensions.head = eaccelerator_el;
-  if (ZendOptimizer) {
-    if ((ZendOptimizer = zend_get_extension("Zend Optimizer")) != NULL) {
-      ZendOptimizer->op_array_handler = NULL;
+    71,  73,  70,  56,  57,  97,  88,   0,  31,   0,
+    213,   0,   0, 150, 153, 196, 237, 168,  86, 187,
+    206, 230,   4,   4,   4, 108, 110, 144,  99, 144,
+    199, 136, 138, 184,  87,  88, 109, 165, 165, 167,
+    163, 166, 202, 240, 151,  44, 149,  91,  21, 225,
+    225, 229,   4,  76, 164, 252, 215, 171, 255, 255,
+    255, 212, 212, 224, 241, 200, 149, 141, 144, 192,
+    216, 216, 226, 251, 230, 205, 192, 193, 218, 207,
+    221, 238, 181, 188, 216, 130, 132, 168, 150, 152,
+    185, 152, 152, 154, 180, 181, 198, 215, 184, 147,
+    40, 102, 177, 224, 232, 242, 244, 244, 244, 235,
+    236, 239, 118, 121, 157, 193, 193, 194, 146, 148,
+    174, 181, 143,  96, 154, 183, 219, 156, 159, 200,
+    126, 128, 170, 174, 175, 193,  65,  39,   7, 232,
+    214, 192, 254, 241, 226, 246, 246, 248, 108,  65,
+    13, 142, 144, 185, 252, 224, 189, 138, 171, 213,
+    69, 122, 188, 239, 244, 249,  48,  49,  60, 176,
+    178, 209, 200, 201, 222, 252, 252, 253, 251, 251,
+    251, 162, 163, 187, 208, 208, 213, 169, 171, 205,
+    241, 234, 225, 255, 252, 249, 254, 248, 241, 140,
+    142, 169, 249, 186, 111,  33, 249,   4,   0,   0,
+    0,   0,   0,  44,   0,   0,   0,   0,  88,   0,
+    31,   0,   0,   6, 255,  64, 137, 112,  72,  44,
+    26, 143, 200, 164, 114, 201,  92,  62, 158, 208,
+    168, 116,  74, 173,  90, 175, 216, 108,  85, 168,
+    237, 122, 191,  15,  25, 163, 118, 209, 153,   0,
+    68, 128,  73, 119, 169,  49, 100,  86,  46, 120,
+    78, 127, 216,  60,  21,  93,  83,   8, 208,  85,
+    60,  54,  83, 114, 117, 132,  89,  32,  23,  38,
+    73,  38, 103,  72,  38,  23,  32,  82, 123, 146,
+    147,  69, 106,   9,  52,  21,  19,  53, 137, 138,
+    51,  51, 156, 141,  21, 100,  52,   9, 148, 166,
+    123,   0, 106, 126,  16,  21, 104,  67, 169, 106,
+    140,   9,   3, 159, 140,  18, 176, 182,   0,  23,
+    21, 101,  67,  21,  80,  32,  52, 192,  52,  44,
+    6,  16,  15,   6,  23,  44,  81,  24,  81,  25,
+    81, 194,  80,  25,   6,  18,  12,  80,  23,  15,
+    169,  15, 172, 155, 105,  33,   7,   4, 158,  46,
+    0,  33,   3,   7,   7,  51,   7, 139, 231, 225,
+    7,  25, 124,  23,  23,  52, 190,  19,   4, 205,
+    44,  27,   4,   4,  19,  57,  15,  33,  15,  32,
+    54,  64, 168, 241,   0,   5,  10,  28, 255,  54,
+    160, 120, 128, 163, 160,  65,   2,  15, 244, 229,
+    200, 113, 162,  26,   4,  20, 252,  22, 130, 128,
+    48,  98, 131,  30,  34,  38, 102, 208,  58,  64,
+    203,   4,  73, 115,   3,   6, 184, 152,  69,  75,
+    228,   1,  87,  38,  80, 204,  19, 242, 235,   9,
+    54,  31,   4,  78, 212, 152, 192, 128,   1,   8,
+    255,  31,  79,  78, 108,  99, 245, 239,  24,   3,
+    136,  16,  32, 212, 139,  24,  34,  83,   8,   3,
+    62,  33, 128,  56,  90,   3,  68, 136,  17, 173,
+    138, 176,  76,  16, 114,  64,   2, 145,   4,   0,
+    136, 196, 128, 129,  22, 215, 146,  66,  50, 224,
+    248,  40,  33, 147,  62,   2,  11,  39, 120, 120,
+    48, 162,  33,  10,   2,  44,  62,  64, 156, 144,
+    244,  31, 129,  17,  12,  31, 240, 157, 240,  76,
+    238, 131,  12,   4, 160, 110,   4,   1, 130, 192,
+    6,   6,  33, 112, 212,  48, 226, 195, 220,  25,
+    145,  95, 189, 118,  77,  64,  50, 236, 172,  79,
+    66,  92, 140,  96,  11,   0,  71,  78,  12,  39,
+    12, 108, 200,  71,  32,  68, 190,  16,  38,  70,
+    56,  54, 120,  87,  71, 136,  16,  25,  70,  36,
+    160, 141,  65,  33,  10,  12,  57,  13,  36, 240,
+    173,  15,  64,   2,  31,  58, 186, 189,  34,  96,
+    238,  86,  73,  90, 198,  75, 146,  12,   1, 128,
+    249, 203, 208,  62,  74,   9,  49,  96,   0,   3,
+    53,   9,   6,  78, 220,  78, 141, 218, 251, 137,
+    19, 168, 199, 163, 230,  46, 254, 246, 120, 247,
+    169, 193, 183, 127, 234,  34,  67,   6,  63,  51,
+    249, 156,  12,  55, 160, 181,  57, 114, 255, 137,
+    52,   3, 127,  62,  12, 129,  65, 118,  74, 112,
+    247,  29, 120, 219,  81, 163, 224, 130, 224,  61,
+    40, 225, 130,  15, 222, 162,  74,  60, 160, 116,
+    181,  95,   6,  36, 189, 212, 255, 225, 103,  39,
+    97, 224,  74, 119, 186, 157,  98, 162,  18, 169,
+    172,  65,   3,  13,  40, 184, 178, 149,  14,   9,
+    160,  97,   2,  87,  18, 204, 104,  66,  89,  51,
+    24,  23, 163,  16,  62, 132, 224, 195,  90,  39,
+    6, 121, 132,  37,  58, 176, 136, 195,  59,  46,
+    152, 133,  98, 135, 174,   8, 129, 129, 143,  56,
+    36, 160,  93,  33,  84,  82,  97,   3,  11,  12,
+    136, 128,   3,  66, 227,  44,  49,   2, 110,  67,
+    248, 224, 131,   6,  34,  48, 176, 204,   3, 131,
+    84, 169, 230,  19,  44, 128, 144, 195,   6,  71,
+    190, 179,   4,  26,  46, 136, 169,   1,  10,  57,
+    236, 192,   2,  15,  79, 164, 185, 166, 154,  55,
+    124, 192, 192, 155,   8, 228,  54, 130,  11, 136,
+    134,  86, 167, 152,  99,  34, 176,  65,  14,  12,
+    124,  16,   8,  20, 126,  62, 176,   2,   5,  20,
+    188, 160, 233, 166, 155,  58, 224, 105,   4,  61,
+    252,  73,  69, 160,  59,  12,  42,   2,  10,   8,
+    32, 160, 193, 170, 171, 166, 138, 130,   8, 144,
+    238, 240,   1, 159, 145,  72,   0,   5,  15,  20,
+    56,  16,  65,   4,  63,   4, 224, 171,   2,   1,
+    0, 171, 192, 176, 195,   6,  32, 234,  21, 129,
+    126,  48,  85,  79, 204,  50,  43, 235,   7,  55,
+    196,  97, 171, 165, 159, 254, 240, 195, 176,  63,
+    188, 240,   0, 173,  80, 244, 192, 194, 153,   2,
+    192, 113, 236, 184, 114, 172,  96, 174, 185, 152,
+    82, 160, 255, 133,   7,  13,  20, 240, 132,  12,
+    5, 196,  80, 192,  92,  15, 192,  32, 175,   0,
+    15,  88,  16, 195, 190,  22, 148, 224, 238,  19,
+    250, 242,  27, 176, 188, 226, 198, 128, 205, 190,
+    252, 202,  96, 111,   1, 248,  62, 128, 112,   1,
+    22,  80, 106, 235,  11,  14,  80, 188, 107, 175,
+    190, 250, 106,  45, 198,   1, 144, 192, 193,  19,
+    5,  52, 208,  64,  24,  29, 116,  96, 111,   3,
+    240,  54,   0,  67, 200,   2,   8, 160,  50,  12,
+    30, 216,  11, 133, 203,  48, 192,  76,  51,  12,
+    237,  62, 112,  65, 187,  54, 216, 107, 178,   7,
+    49, 168,  28,  52, 190, 237, 194,  80, 178, 196,
+    43, 108,  28, 172,   2,  11, 120, 204, 193, 211,
+    17, 112, 176, 235, 211,  28, 236, 240,  68,   7,
+    33, 151, 128, 179, 184,  45,  55,  32,  64, 180,
+    22, 120, 224, 114, 203,  10, 199,  48, 179, 215,
+    225, 186,  12, 178, 217,  33, 163,  92, 175, 217,
+    22, 120, 125, 131,  13, 242,  62, 224, 117, 189,
+    35, 247,  41, 129,   3, 196,  50, 189,  64,  11,
+    36, 216,  48, 183,  29,  79,   4,  98, 195, 164,
+    46, 119,  80, 180, 217, 103,  75, 225, 178, 200,
+    2, 200, 252, 196, 227, 104, 139,  44, 242,   5,
+    50,  52, 160,  56,  12, 111,  63, 160, 246,  19,
+    246, 218,  96, 121, 206, 122, 191, 224, 247, 223,
+    45, 164, 238, 244, 174, 172,  63, 173, 238,   3,
+    5, 152,  28,  50, 206,  17,  43,  76, 154,  51,
+    232,  93,  67,  33, 185, 231, 121, 243,  46,  64,
+    12,  29,  60,  80, 130, 208, 193, 203, 204,  46,
+    231,  50,  96, 109, 119, 205,  13, 208, 139, 166,
+    173,  42, 144, 176,  64,  10, 212,  87, 159, 250,
+    2, 216, 103, 191, 192,  14, 129, 168, 252, 132,
+    202,  33,   7,  93, 188, 230, 138, 139, 221,   0,
+    191,  56, 239, 203, 240, 249,  49,  88, 160, 118,
+    220,  43, 155, 189, 115, 204, 140, 227, 172, 120,
+    243, 118, 135, 139, 245, 164, 149,  78,  74, 248,
+    220, 130, 187, 193, 224,  30,  16,  51, 113, 149,
+    160,   4,  54, 208,  90,   9, 102,  86,  51,  56,
+    196, 172, 102,  98, 171,  25,  12,  74, 240,  64,
+    152, 197, 204,  38,  53, 139,  88, 189,  90, 182,
+    192, 201, 213, 236,  76,  48, 179, 129,   5,  96,
+    166, 183, 113, 153,  80,  77,  66,  74, 161,  10,
+    41,  17,   4,   0,  59,   0
+};
+
+static int eaccelerator_last_startup(zend_extension *extension)
+{
+    int ret;
+    extension->startup = last_startup;
+    ret = extension->startup(extension);
+    zend_extensions.count++;
+    eaccelerator_el->next = zend_extensions.head;
+    eaccelerator_el->prev = NULL;
+    zend_extensions.head->prev = eaccelerator_el;
+    zend_extensions.head = eaccelerator_el;
+    if (ZendOptimizer) {
+        if ((ZendOptimizer = zend_get_extension("Zend Optimizer")) != NULL) {
+            ZendOptimizer->op_array_handler = NULL;
+        }
     }
-  }
-  return ret;
+    return ret;
 }
 
 /*
@@ -2127,61 +2217,62 @@
 */
 
 
-ZEND_DLEXPORT int eaccelerator_zend_startup(zend_extension *extension) {
- ea_is_zend_extension = 1;
-  eaccelerator_el   = NULL;
-  last_startup = NULL;
-
-  if (!ea_is_extension) {
-    if (zend_startup_module(&eaccelerator_module_entry) != SUCCESS) {
-      return FAILURE;
+ZEND_DLEXPORT int eaccelerator_zend_startup(zend_extension *extension)
+{
+    ea_is_zend_extension = 1;
+    eaccelerator_el   = NULL;
+    last_startup = NULL;
+
+    if (!ea_is_extension) {
+        if (zend_startup_module(&eaccelerator_module_entry) != SUCCESS) {
+            return FAILURE;
+        }
     }
-  }
 
-  if (zend_llist_count(&zend_extensions) > 1) {
-    zend_llist_element *p = zend_extensions.head;
-    while (p != NULL) {
-      zend_extension* ext = (zend_extension*)(p->data);
-      if (strcmp(ext->name, EACCELERATOR_EXTENSION_NAME) == 0) {
-        /* temporary removing eAccelerator extension */
-        zend_extension* last_ext = (zend_extension*)zend_extensions.tail->data;
-        if (eaccelerator_el != NULL) {
-          zend_error(E_CORE_ERROR,"[%s] %s %s can not be loaded twice",
-                   EACCELERATOR_EXTENSION_NAME,
-                   EACCELERATOR_EXTENSION_NAME,
-                   EACCELERATOR_VERSION);
-          exit(1);
-        }
-        if (last_ext != ext) {
-          eaccelerator_el = p;
-          last_startup = last_ext->startup;
-          last_ext->startup = eaccelerator_last_startup;
-          zend_extensions.count--;
-          if (p->prev != NULL) {
-            p->prev->next = p->next;
-          } else {
-            zend_extensions.head = p->next;
-          }
-          if (p->next != NULL) {
-            p->next->prev = p->prev;
-          } else {
-            zend_extensions.tail = p->prev;
-          }
-        }
-      } else if (strcmp(ext->name, "Zend Extension Manager") == 0 ||
-                 strcmp(ext->name, "Zend Optimizer") == 0) {
-        /* Disable ZendOptimizer Optimizations */
-        ZendOptimizer = ext;
-        ext->op_array_handler = NULL;
-      }
-      p = p->next;
+    if (zend_llist_count(&zend_extensions) > 1) {
+        zend_llist_element *p = zend_extensions.head;
+        while (p != NULL) {
+            zend_extension* ext = (zend_extension*)(p->data);
+            if (strcmp(ext->name, EACCELERATOR_EXTENSION_NAME) == 0) {
+                /* temporary removing eAccelerator extension */
+                zend_extension* last_ext = (zend_extension*)zend_extensions.tail->data;
+                if (eaccelerator_el != NULL) {
+                    zend_error(E_CORE_ERROR,"[%s] %s %s can not be loaded twice",
+                               EACCELERATOR_EXTENSION_NAME,
+                               EACCELERATOR_EXTENSION_NAME,
+                               EACCELERATOR_VERSION);
+                    exit(1);
+                }
+                if (last_ext != ext) {
+                    eaccelerator_el = p;
+                    last_startup = last_ext->startup;
+                    last_ext->startup = eaccelerator_last_startup;
+                    zend_extensions.count--;
+                    if (p->prev != NULL) {
+                        p->prev->next = p->next;
+                    } else {
+                        zend_extensions.head = p->next;
+                    }
+                    if (p->next != NULL) {
+                        p->next->prev = p->prev;
+                    } else {
+                        zend_extensions.tail = p->prev;
+                    }
+                }
+            } else if (strcmp(ext->name, "Zend Extension Manager") == 0 ||
+                       strcmp(ext->name, "Zend Optimizer") == 0) {
+                /* Disable ZendOptimizer Optimizations */
+                ZendOptimizer = ext;
+                ext->op_array_handler = NULL;
+            }
+            p = p->next;
+        }
     }
-  }
 
-  php_register_info_logo(EACCELERATOR_VERSION_GUID, "text/plain", (unsigned char*)EACCELERATOR_VERSION_STRING, sizeof(EACCELERATOR_VERSION_STRING));
-  php_register_info_logo(EACCELERATOR_LOGO_GUID,    "image/gif",  (unsigned char*)eaccelerator_logo, sizeof(eaccelerator_logo));
+    php_register_info_logo(EACCELERATOR_VERSION_GUID, "text/plain", (unsigned char*)EACCELERATOR_VERSION_STRING, sizeof(EACCELERATOR_VERSION_STRING));
+    php_register_info_logo(EACCELERATOR_LOGO_GUID,    "image/gif",  (unsigned char*)eaccelerator_logo, sizeof(eaccelerator_logo));
 
-  return SUCCESS;
+    return SUCCESS;
 }
 
 #ifndef ZEND_EXT_API
@@ -2191,67 +2282,68 @@
 ZEND_EXTENSION();
 
 ZEND_DLEXPORT zend_extension zend_extension_entry = {
-  EACCELERATOR_EXTENSION_NAME,
-  EACCELERATOR_VERSION,
-  "eAccelerator",
-  "http://eaccelerator.net",
-  "Copyright (c) 2004-2010 eAccelerator",
-  eaccelerator_zend_startup,
-  NULL,
-  NULL,   /* void (*activate)() */
-  NULL,   /* void (*deactivate)() */
-  NULL,   /* void (*message_handle)(int message, void *arg) */
+    EACCELERATOR_EXTENSION_NAME,
+    EACCELERATOR_VERSION,
+    "eAccelerator",
+    "http://eaccelerator.net",
+    "Copyright (c) 2004-2012 eAccelerator",
+    eaccelerator_zend_startup,
+    NULL,
+    NULL,   /* void (*activate)() */
+    NULL,   /* void (*deactivate)() */
+    NULL,   /* void (*message_handle)(int message, void *arg) */
 #ifdef WITH_EACCELERATOR_OPTIMIZER
-  eaccelerator_optimize,   /* void (*op_array_handler)(zend_op_array *o_a); */
+    eaccelerator_optimize,   /* void (*op_array_handler)(zend_op_array *o_a); */
 #else
-  NULL,   /* void (*op_array_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*op_array_handler)(zend_op_array *o_a); */
 #endif
-  NULL,   /* void (*statement_handler)(zend_op_array *o_a); */
-  NULL,   /* void (*fcall_begin_handler)(zend_op_array *o_a); */
-  NULL,   /* void (*fcall_end_handler)(zend_op_array *o_a); */
-  NULL,   /* void (*op_array_ctor)(zend_op_array *o_a); */
-  NULL,   /* void (*op_array_dtor)(zend_op_array *o_a); */
+    NULL,   /* void (*statement_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*fcall_begin_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*fcall_end_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*op_array_ctor)(zend_op_array *o_a); */
+    NULL,   /* void (*op_array_dtor)(zend_op_array *o_a); */
 #ifdef COMPAT_ZEND_EXTENSION_PROPERTIES
-  NULL,   /* api_no_check */
-  COMPAT_ZEND_EXTENSION_PROPERTIES
+    NULL,   /* api_no_check */
+    COMPAT_ZEND_EXTENSION_PROPERTIES
 #else
-  STANDARD_ZEND_EXTENSION_PROPERTIES
+    STANDARD_ZEND_EXTENSION_PROPERTIES
 #endif
 };
 
 static zend_extension eaccelerator_extension_entry = {
-  EACCELERATOR_EXTENSION_NAME,
-  EACCELERATOR_VERSION,
-  "eAccelerator",
-  "http://eaccelerator.net",
-  "Copyright (c) 2004-2010 eAccelerator",
-  eaccelerator_zend_startup,
-  NULL,
-  NULL,   /* void (*activate)() */
-  NULL,   /* void (*deactivate)() */
-  NULL,   /* void (*message_handle)(int message, void *arg) */
+    EACCELERATOR_EXTENSION_NAME,
+    EACCELERATOR_VERSION,
+    "eAccelerator",
+    "http://eaccelerator.net",
+    "Copyright (c) 2004-2012 eAccelerator",
+    eaccelerator_zend_startup,
+    NULL,
+    NULL,   /* void (*activate)() */
+    NULL,   /* void (*deactivate)() */
+    NULL,   /* void (*message_handle)(int message, void *arg) */
 #ifdef WITH_EACCELERATOR_OPTIMIZER
-  eaccelerator_optimize,   /* void (*op_array_handler)(zend_op_array *o_a); */
+    eaccelerator_optimize,   /* void (*op_array_handler)(zend_op_array *o_a); */
 #else
-  NULL,   /* void (*op_array_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*op_array_handler)(zend_op_array *o_a); */
 #endif
-  NULL,   /* void (*statement_handler)(zend_op_array *o_a); */
-  NULL,   /* void (*fcall_begin_handler)(zend_op_array *o_a); */
-  NULL,   /* void (*fcall_end_handler)(zend_op_array *o_a); */
-  NULL,   /* void (*op_array_ctor)(zend_op_array *o_a); */
-  NULL,   /* void (*op_array_dtor)(zend_op_array *o_a); */
+    NULL,   /* void (*statement_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*fcall_begin_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*fcall_end_handler)(zend_op_array *o_a); */
+    NULL,   /* void (*op_array_ctor)(zend_op_array *o_a); */
+    NULL,   /* void (*op_array_dtor)(zend_op_array *o_a); */
 #ifdef COMPAT_ZEND_EXTENSION_PROPERTIES
-  NULL,   /* api_no_check */
-  COMPAT_ZEND_EXTENSION_PROPERTIES
+    NULL,   /* api_no_check */
+    COMPAT_ZEND_EXTENSION_PROPERTIES
 #else
-  STANDARD_ZEND_EXTENSION_PROPERTIES
+    STANDARD_ZEND_EXTENSION_PROPERTIES
 #endif
 };
 
-static void register_eaccelerator_as_zend_extension() {
-  zend_extension extension = eaccelerator_extension_entry;
-  extension.handle = 0;
-  zend_llist_prepend_element(&zend_extensions, &extension);
+static void register_eaccelerator_as_zend_extension()
+{
+    zend_extension extension = eaccelerator_extension_entry;
+    extension.handle = 0;
+    zend_llist_prepend_element(&zend_extensions, &extension);
 }
 
 /******************************************************************************/
@@ -2260,9 +2352,9 @@
 
 /*
  * Local variables:
- * tab-width: 2
- * c-basic-offset: 2
+ * tab-width: 4
+ * c-basic-offset: 4
  * End:
- * vim600: noet sw=2 ts=2 fdm=marker
- * vim<600: noet sw=2 ts=2
+ * vim>600: expandtab sw=4 ts=4 sts=4 fdm=marker
+ * vim<600: expandtab sw=4 ts=4 sts=4
  */
diff -Naur orig/eaccelerator.h patched/eaccelerator.h
--- orig/eaccelerator.h	2010-01-19 16:49:13.000000000 +0100
+++ patched/eaccelerator.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,8 +2,8 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
-   | http://eaccelerator.net                                  		      |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
+   | http://eaccelerator.net                                  	          |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
    | modify it under the terms of the GNU General Public License          |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id: eaccelerator.h 375 2010-01-19 15:49:13Z bart $
+   $Id: eaccelerator.h 423 2010-07-11 21:03:25Z bart $
 */
 
 #ifndef INCLUDED_EACCELERATOR_H
@@ -42,7 +42,7 @@
 #endif
 
 #if PHP_MAJOR_VERSION == 4 || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION < 1)
-    #error "eAccelerator only supports PHP 5.1 and higher"
+#error "eAccelerator only supports PHP 5.1 and higher"
 #endif
 
 #if PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 2
@@ -53,16 +53,15 @@
 #   define ZEND_ENGINE_2_3
 #endif
 
+#if PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 4
+#   define ZEND_ENGINE_2_4
+#endif
+
 /* fixes compile errors on php5.1 */
 #ifdef STR_EMPTY_ALLOC
 #	define empty_string STR_EMPTY_ALLOC()
 #endif
 
-#if !defined(ZEND_WIN32) && defined(WITH_EACCELERATOR_USE_INODE)
-/* UnDefine if your filesystem doesn't support inodes */
-#  define EACCELERATOR_USE_INODE
-#endif
-
 #ifdef WITH_EACCELERATOR_CRASH_DETECTION
 #  include <signal.h>
 #endif
@@ -111,20 +110,20 @@
 #endif
 
 #if !defined(_INTPTR_T_DEFINED) && ZEND_WIN32
-	typedef intptr_t;
-	#define _INTPTR_T_DEFINED
+typedef intptr_t;
+#define _INTPTR_T_DEFINED
 #else
 #  ifdef HAVE_STDINT_H
 #    include <stdint.h>
-#  elif HAVE_INTTYPES_H 
-#    include <inttypes.h> 
-#  endif 
+#  elif HAVE_INTTYPES_H
+#    include <inttypes.h>
+#  endif
 #endif
 
 #if !defined(ssize_t) && ZEND_WIN32
-	/* define ssize_t for Win32. */
-	#define ssize_t int
-#endif 
+/* define ssize_t for Win32. */
+#define ssize_t int
+#endif
 
 #ifdef HAVE_EACCELERATOR
 
@@ -153,14 +152,6 @@
 #  define ZTS_UNLOCK()
 #endif
 
-#if defined(EACCELERATOR_PROTECT_SHM)
-#  define EACCELERATOR_PROTECT()    do {mm_protect(ea_mm_instance->mm, MM_PROT_READ);} while(0)
-#  define EACCELERATOR_UNPROTECT()  do {mm_protect(ea_mm_instance->mm, MM_PROT_READ|MM_PROT_WRITE);} while(0)
-#else
-#  define EACCELERATOR_PROTECT()
-#  define EACCELERATOR_UNPROTECT()
-#endif
-
 #define EACCELERATOR_LOCK_RW()    do {ZTS_LOCK(); mm_lock(ea_mm_instance->mm, MM_LOCK_RW);} while(0)
 #define EACCELERATOR_LOCK_RD()    do {ZTS_LOCK(); mm_lock(ea_mm_instance->mm, MM_LOCK_RD);} while(0)
 #define EACCELERATOR_UNLOCK()     do {mm_unlock(ea_mm_instance->mm); ZTS_UNLOCK();} while(0)
@@ -190,9 +181,9 @@
 #define EA_SIZE_ALIGN(n) (n) = ((((size_t)(n)-1) & ~(EACCELERATOR_PLATFORM_ALIGNMENT-1)) + EACCELERATOR_PLATFORM_ALIGNMENT)
 
 #ifdef ZEND_ENGINE_2_3
-    #define RESET_PZVAL_REFCOUNT(z) Z_SET_REFCOUNT_P(z, 1)
+#define RESET_PZVAL_REFCOUNT(z) Z_SET_REFCOUNT_P(z, 1)
 #else
-    #define RESET_PZVAL_REFCOUNT(z) (z)->refcount = 1;
+#define RESET_PZVAL_REFCOUNT(z) (z)->refcount = 1;
 #endif
 
 #define MAX_DUP_STR_LEN 256
@@ -212,72 +203,118 @@
 #endif
 
 typedef struct _eaccelerator_op_array {
-	zend_uchar type;
+    zend_uchar type;
+#ifndef ZEND_ENGINE_2_3
+    zend_bool uses_this;
+#endif
+    zend_uint num_args;
+    zend_uint required_num_args;
+    zend_arg_info *arg_info;
+#ifdef ZEND_ENGINE_2_4
+    const char *function_name;
+#else
+    zend_bool pass_rest_by_reference;
+    zend_bool return_reference;
+
+    char *function_name;
+#endif
+    char *scope_name;
+    int scope_name_len;
+    zend_uint fn_flags;
+    zend_op *opcodes;
+    zend_uint last;
+    zend_compiled_variable *vars;
+    int last_var;
+    zend_uint T;
+    zend_brk_cont_element *brk_cont_array;
+    int last_brk_cont;
+    zend_try_catch_element *try_catch_array;
+    int last_try_catch;
+    HashTable *static_variables;
+
 #ifdef ZEND_ENGINE_2_3
-    zend_uint early_binding;
     zend_uint this_var;
+#endif
+
+#ifdef ZEND_ENGINE_2_4
+    const char *filename;
 #else
-	zend_bool uses_this;
+    char *filename;
 #endif
-	zend_bool return_reference;
-	zend_uint num_args;
-	zend_uint required_num_args;
-	zend_arg_info *arg_info;
-	zend_bool pass_rest_by_reference;
-	char *function_name;
-	char *scope_name;
-	int scope_name_len;
-	zend_uint fn_flags;
-	zend_op *opcodes;
-	zend_uint last;
-	zend_compiled_variable *vars;
-    int last_var;
-	zend_uint T;
-	zend_brk_cont_element *brk_cont_array;
-	zend_uint last_brk_cont;
-	zend_try_catch_element *try_catch_array;
-	int last_try_catch;
-	HashTable *static_variables;
-	char *filename;
-	zend_uint line_start;
-	zend_uint line_end;
+    zend_uint line_start;
+    zend_uint line_end;
 #ifdef INCLUDE_DOC_COMMENTS
+#  ifdef ZEND_ENGINE_2_4
+    const char *doc_comment;
+#  else
     char *doc_comment;
+#  endif
     zend_uint doc_comment_len;
 #endif
+#ifdef ZEND_ENGINE_2_3
+    zend_uint early_binding;
+#endif
+#ifdef ZEND_ENGINE_2_4
+    zend_literal *literals;
+    int last_literal;
+
+    int last_cache_slot;
+#endif
 } ea_op_array;
 
 typedef struct _eaccelerator_class_entry {
-	char type;
-	char *name;
-	zend_uint name_length;
-	char *parent;
-	HashTable function_table;
-	HashTable default_properties;
-	HashTable properties_info;
-	HashTable default_static_members;
-	HashTable *static_members;
-	HashTable constants_table;
-	zend_uint ce_flags;
-	zend_uint num_interfaces;
-
-	char *filename;
-	zend_uint line_start;
-	zend_uint line_end;
-#  ifdef INCLUDE_DOC_COMMENTS
+    char type;
+#ifdef ZEND_ENGINE_2_4
+    const char *name;
+#else
+    char *name;
+#endif
+    zend_uint name_length;
+    char *parent;
+    HashTable function_table;
+    HashTable properties_info;
+#ifdef ZEND_ENGINE_2_4
+    zval **default_properties_table;
+    zval **default_static_members_table;
+    zval **static_members_table;
+#else
+    HashTable default_properties;
+    HashTable default_static_members;
+    HashTable *static_members;
+#endif
+    HashTable constants_table;
+#ifdef ZEND_ENGINE_2_4
+    int default_properties_count;
+    int default_static_members_count;
+#endif
+    zend_uint ce_flags;
+    zend_uint num_interfaces;
+
+#ifdef ZEND_ENGINE_2_4
+    const char *filename;
+#else
+    char *filename;
+#endif
+    zend_uint line_start;
+    zend_uint line_end;
+#ifdef INCLUDE_DOC_COMMENTS
+#  ifdef ZEND_ENGINE_2_4
+    const char *doc_comment;
+#  else
     char *doc_comment;
-    zend_uint doc_comment_len;
 #  endif
+    zend_uint doc_comment_len;
+#endif
 } ea_class_entry;
 
 /*
  * To cache functions and classes.
  */
 typedef struct _ea_fc_entry {
-	void *fc;
-	struct _ea_fc_entry *next;
-	int htablen;
-	char htabkey[1];			/* must be last element */
+    void *fc;
+    struct _ea_fc_entry *next;
+    int htablen;
+    char htabkey[1];			/* must be last element */
 } ea_fc_entry;
 
 
@@ -287,101 +324,84 @@
  * the list of ea_fc_entry.
  */
 typedef struct _ea_cache_entry {
-	struct _ea_cache_entry *next;
-#ifdef EACCELERATOR_USE_INODE
-	dev_t st_dev;				/* file's device                         */
-	ino_t st_ino;				/* file's inode                          */
-#else
-	unsigned int hv;			/* hash value                            */
-#endif
-	off_t filesize;				/* file size */
-	time_t mtime;				/* file last modification time           */
-	time_t ttl;				/* expiration time (updated on each hit) */
-	time_t ts;				/* timestamp of cache entry              */
-	unsigned int size;			/* entry size (bytes)                    */
-	unsigned int nhits;			/* hits count                            */
-	unsigned int nreloads;			/* count of reloads                      */
-	int use_cnt;			/* how many processes uses the entry     */
-	ea_op_array *op_array;	/* script's global scope code        */
-	ea_fc_entry *f_head;		/* list of nested functions          */
-	ea_fc_entry *c_head;		/* list of nested classes            */
-	zend_bool removed;			/* the entry is scheduled to remove  */
-	char realfilename[1];		/* real file name (must be last el.) */
+    struct _ea_cache_entry *next;
+    unsigned int hv;			/* hash value                            */
+    off_t filesize;				/* file size */
+    time_t mtime;				/* file last modification time           */
+    time_t ttl;				/* expiration time (updated on each hit) */
+    time_t ts;				/* timestamp of cache entry              */
+    unsigned int size;			/* entry size (bytes)                    */
+    unsigned int nhits;			/* hits count                            */
+    unsigned int nreloads;			/* count of reloads                      */
+    int use_cnt;			/* how many processes uses the entry     */
+    ea_op_array *op_array;	/* script's global scope code        */
+    ea_fc_entry *f_head;		/* list of nested functions          */
+    ea_fc_entry *c_head;		/* list of nested classes            */
+    zend_bool removed;			/* the entry is scheduled to remove  */
+    char realfilename[1];		/* real file name (must be last el.) */
 } ea_cache_entry;
 
 /*
  * Linked list of ea_cache_entry which are used by process/thread
  */
 typedef struct _ea_used_entry {
-	struct _ea_used_entry *next;
-	ea_cache_entry *entry;
+    struct _ea_used_entry *next;
+    ea_cache_entry *entry;
 } ea_used_entry;
 
-/*
- * Linked list of locks
- */
-typedef struct _ea_lock_entry {
-	struct _ea_lock_entry *next;
-	pid_t pid;
-#ifdef ZTS
-	THREAD_T thread;
-#endif
-	char key[1];
-} ea_lock_entry;
-
 typedef struct _ea_file_header {
-	char magic[8];				/* "EACCELERATOR" */
-	int eaccelerator_version[2];
-	int zend_version[2];
-	int php_version[2];
-	int size;
-	time_t mtime;
-	time_t ts;
-	unsigned int crc32;
+    char magic[8];				/* "EACCELERATOR" */
+    int eaccelerator_version[2];
+    int zend_version[2];
+    int php_version[2];
+    int size;
+    time_t mtime;
+    time_t ts;
+    unsigned int crc32;
 } ea_file_header;
 
 int check_header(ea_file_header *hdr);
 void init_header(ea_file_header *hdr);
 
 typedef struct {
-	MM *mm;
-	pid_t owner;
-	size_t total;
-	unsigned int hash_cnt;
-	zend_bool enabled;
-	zend_bool optimizer_enabled;
-	zend_bool check_mtime_enabled;
-	unsigned int rem_cnt;
-	time_t last_prune;
-	ea_cache_entry *removed;
-	ea_lock_entry *locks;
+    MM *mm;
+    pid_t owner;
+    size_t total;
+    unsigned int hash_cnt;
+    zend_bool enabled;
+    zend_bool optimizer_enabled;
+    zend_bool check_mtime_enabled;
+    unsigned int rem_cnt;
+    time_t last_prune;
+    ea_cache_entry *removed;
+    uid_t cache_dir_uid;
 
-	ea_cache_entry *hash[EA_HASH_SIZE];
+    ea_cache_entry *hash[EA_HASH_SIZE];
 } eaccelerator_mm;
 
 /*
  * Where to cache
  */
 typedef enum _ea_cache_place {
-	ea_shm_and_disk,	/* in shm and in disk */
-	ea_shm,				/* in shm, but if it is not possible then on disk */
-	ea_shm_only,		/* in shm only  */
-	ea_disk_only,		/* on disk only */
-	ea_none				/* don't cache  */
+    ea_shm_and_disk,	/* in shm and in disk */
+    ea_shm,				/* in shm, but if it is not possible then on disk */
+    ea_shm_only,		/* in shm only  */
+    ea_disk_only,		/* on disk only */
+    ea_none				/* don't cache  */
 } ea_cache_place;
 
 typedef union align_union {
-  double d;
-  void *v;
-  int (*func)(int);
-  long l;
+    double d;
+    void *v;
+    int (*func)(int);
+    long l;
 } align_union;
 
 #ifdef ZEND_ENGINE_2_2
 typedef union _align_test {
-  void *ptr;
-  double dbl;
-  long lng;
+    void *ptr;
+    double dbl;
+    long lng;
 } align_test;
 #endif
 
@@ -404,13 +424,10 @@
 void format_size (char *s, unsigned int size, int legend);
 void eaccelerator_prune (time_t t);
 
-int eaccelerator_lock (const char *key, int key_len TSRMLS_DC);
-int eaccelerator_unlock (const char *key, int key_len TSRMLS_DC);
-
 void *eaccelerator_malloc2 (size_t size TSRMLS_DC);
 
 unsigned int eaccelerator_crc32 (const char *p, size_t n);
-int eaccelerator_md5 (char *s, const char *prefix, const char *key TSRMLS_DC); 
+int eaccelerator_md5 (char *s, const char *prefix, const char *key TSRMLS_DC);
 
 #  ifdef WITH_EACCELERATOR_OPTIMIZER
 void eaccelerator_optimize (zend_op_array * op_array);
@@ -423,8 +440,8 @@
 #endif
 
 struct ea_pattern_t {
-  struct ea_pattern_t *next;
-  char *pattern;
+    struct ea_pattern_t *next;
+    char *pattern;
 };
 
 /*
@@ -432,7 +449,7 @@
  */
 ZEND_BEGIN_MODULE_GLOBALS (eaccelerator)
 void *used_entries;			/* list of files which are used     */
-					/* by process/thread                */
+/* by process/thread                */
 zend_bool enabled;
 zend_bool optimizer_enabled;
 zend_bool check_mtime_enabled;
@@ -484,3 +501,12 @@
 
 #endif 		/* HAVE_EACCELERATOR */
 #endif		/* #ifndef INCLUDED_EACCELERATOR_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim>600: expandtab sw=4 ts=4 sts=4 fdm=marker
+ * vim<600: expandtab sw=4 ts=4 sts=4
+ */
diff -Naur orig/eaccelerator.ini patched/eaccelerator.ini
--- orig/eaccelerator.ini	2010-01-26 15:25:13.000000000 +0100
+++ patched/eaccelerator.ini	2012-08-16 15:34:36.000000000 +0200
@@ -25,7 +25,7 @@
 eaccelerator.shm_size = "0"
 
 ; The directory that is used for disk cache. eAccelerator stores precompiled
-; code, session data, content and user entries  here. The same data can be
+; code, session data, content and user entries here. The same data can be
 ; stored in shared memory also (for more quick access). Default value is
 ; "/tmp/eaccelerator".
 eaccelerator.cache_dir = "/tmp/eaccelerator"
diff -Naur orig/eaccelerator_version.h patched/eaccelerator_version.h
--- orig/eaccelerator_version.h	2010-05-31 21:29:23.000000000 +0200
+++ patched/eaccelerator_version.h	2012-08-16 15:34:36.000000000 +0200
@@ -1,3 +1,3 @@
 #ifndef EACCELERATOR_VERSION
-#define EACCELERATOR_VERSION "0.9.6.1"
+#define EACCELERATOR_VERSION "1.0-dev"
 #endif
diff -Naur orig/ea_dasm.c patched/ea_dasm.c
--- orig/ea_dasm.c	2010-01-20 15:58:03.000000000 +0100
+++ patched/ea_dasm.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -34,7 +34,7 @@
 
 extern eaccelerator_mm *ea_mm_instance;
 
-#define LOOKUP(arr, index, max, ptr) if (index < max) { ptr = arr[index]; } else { ptr = "UNDEFINED (todo)"; };
+#define LOOKUP(arr, index, max, ptr) if (index < max) { ptr = arr[index]; } else { ptr = "UNDEFINED (TODO)"; };
 
 /* {{{ static const char *extopnames_declare[] */
 static const char *extopnames_declare[] = {
@@ -70,7 +70,7 @@
     "FETCH_ADD_LOCK",           /* 1 */
     "FETCH_MAKE_REF"            /* 2 */
 };
-#define EXTOPNAMES_FETCH_NUM 2
+#define EXTOPNAMES_FETCH_NUM 3
 #define GET_EXTOPNAMES_FETCH(index, ptr) LOOKUP(extopnames_fetch, index, EXTOPNAMES_FETCH_NUM, ptr)
 /* }}} */
 
@@ -85,7 +85,7 @@
     "FETCH_CLASS_INTERFACE",        /* 6 */
     "FETCH_CLASS_STATIC",           /* 7 */
 };
-#define EXTOPNAMES_FETCH_CLASS_NUM 6
+#define EXTOPNAMES_FETCH_CLASS_NUM 8
 #define GET_EXTOPNAMES_FETCH_CLASS(index, ptr) LOOKUP(extopnames_fetch_class, index, EXTOPNAMES_FETCH_CLASS_NUM, ptr)
 /* }}} */
 
@@ -105,9 +105,11 @@
     "&nbsp;",                   /* 0 */
     "ARG_SEND_BY_REF",          /* 1 */
     "ARG_COMPILE_TIME_BOUND",   /* 2 */
-    "ARG_SEND_BY_REF | ZEND_ARG_COMPILE_TIME_BOUND" /* 3 */
+    "ARG_SEND_BY_REF | ZEND_ARG_COMPILE_TIME_BOUND", /* 3 */
+    "ZEND_ARG_SEND_FUNCTION"    /* 4 */
+    /* bleh, this sucks for bitmasks */
 };
-#define EXTOPNAMES_SENDNOREF_NUM 4
+#define EXTOPNAMES_SENDNOREF_NUM 5
 #define GET_EXTOPNAMES_SENDNOREF(index, ptr) LOOKUP(extopnames_sendnoref, index, EXTOPNAMES_SENDNOREF_NUM, ptr)
 /* }}} */
 
@@ -141,66 +143,71 @@
     char buf[512];
     size_t size;
 
+#ifndef ZEND_ENGINE_2_3
     switch (Z_TYPE_P(v) & ~IS_CONSTANT_INDEX) {
-        case IS_NULL:
-            str = emalloc(sizeof("null"));
-            strncpy(str, "null", sizeof("null"));
-            break;
-        case IS_LONG:
-            snprintf(buf, sizeof(buf), "long(%ld)", Z_LVAL_P(v));
-            str = emalloc(strlen(buf) + 1);
-            strcpy(str, buf);
-            break;
-        case IS_DOUBLE:
-            snprintf(buf, sizeof(buf), "double(%e)", Z_DVAL_P(v));
-            str = emalloc(strlen(buf) + 1);
-            strcpy(str, buf);
-            break;
-        case IS_STRING:
-            size = Z_STRLEN_P(v) + 1 + sizeof("string('')");
-            str = emalloc(size);
-            snprintf(str, size, "string('%s')", Z_STRVAL_P(v)); 
-            break;
-        case IS_BOOL:
-            if (Z_LVAL_P(v)) {
-                str = emalloc(sizeof("bool(true)"));
-                strcpy(str, "bool(true)");
-            } else {
-                str = emalloc(sizeof("bool(false)"));
-                strcpy(str, "bool(false)");
-            }
-            break;
-        case IS_ARRAY:
-            str = emalloc(sizeof("array(?)"));
-            strcpy(str, "array(?)");
-            break;
-        case IS_OBJECT:
-            str = emalloc(sizeof("object(?)"));
-            strcpy(str, "object(?)");
-            break;
-        case IS_RESOURCE:
-            str = emalloc(sizeof("resource(?)"));
-            strcpy(str, "resource(?)");
-            break;
-        case IS_CONSTANT:
-            size = Z_STRLEN_P(v) + 1 + sizeof("constant('')");
-            str = emalloc(size);
-            snprintf(str, size, "constant('%s')", Z_STRVAL_P(v)); 
-            break;
-        case IS_CONSTANT_ARRAY:
-            str = emalloc(sizeof("constant_array(?)"));
-            strcpy(str, "constant_array(?)");
-            break;
-        default:
-            snprintf(buf, sizeof(buf), "unknown(type=%d)", Z_TYPE_P(v));
-            str = emalloc(strlen(buf) + 1);
-            strcpy(str, buf);
+#else
+    switch (Z_TYPE_P(v) & IS_CONSTANT_TYPE_MASK) {
+#endif
+
+    case IS_NULL:
+        str = emalloc(sizeof("null"));
+        strncpy(str, "null", sizeof("null"));
+        break;
+    case IS_LONG:
+        snprintf(buf, sizeof(buf), "long(%ld)", Z_LVAL_P(v));
+        str = emalloc(strlen(buf) + 1);
+        strcpy(str, buf);
+        break;
+    case IS_DOUBLE:
+        snprintf(buf, sizeof(buf), "double(%e)", Z_DVAL_P(v));
+        str = emalloc(strlen(buf) + 1);
+        strcpy(str, buf);
+        break;
+    case IS_STRING:
+        size = Z_STRLEN_P(v) + 1 + sizeof("string('')");
+        str = emalloc(size);
+        snprintf(str, size, "string('%s')", Z_STRVAL_P(v));
+        break;
+    case IS_BOOL:
+        if (Z_LVAL_P(v)) {
+            str = emalloc(sizeof("bool(true)"));
+            strcpy(str, "bool(true)");
+        } else {
+            str = emalloc(sizeof("bool(false)"));
+            strcpy(str, "bool(false)");
+        }
+        break;
+    case IS_ARRAY:
+        str = emalloc(sizeof("array(?)"));
+        strcpy(str, "array(?)");
+        break;
+    case IS_OBJECT:
+        str = emalloc(sizeof("object(?)"));
+        strcpy(str, "object(?)");
+        break;
+    case IS_RESOURCE:
+        str = emalloc(sizeof("resource(?)"));
+        strcpy(str, "resource(?)");
+        break;
+    case IS_CONSTANT:
+        size = Z_STRLEN_P(v) + 1 + sizeof("constant('')");
+        str = emalloc(size);
+        snprintf(str, size, "constant('%s')", Z_STRVAL_P(v));
+        break;
+    case IS_CONSTANT_ARRAY:
+        str = emalloc(sizeof("constant_array(?)"));
+        strcpy(str, "constant_array(?)");
+        break;
+    default:
+        snprintf(buf, sizeof(buf), "unknown(type=%d)", Z_TYPE_P(v));
+        str = emalloc(strlen(buf) + 1);
+        strcpy(str, buf);
     }
     return str;
 }
 /* }}} */
 
-/* {{{ get_op_array: return a php array with the given op_array structure 
+/* {{{ get_op_array: return a php array with the given op_array structure
  * array() { [0] .. [n] =>
  *      array () {
  *          [lineno]        => // the line number in the source code
@@ -208,11 +215,11 @@
  *          [extended_value]=> // the extended value field
  *          [op1]           => // the first opcode
  *          [op2]           => // the second opcode
- *          [result]        => // the result 
+ *          [result]        => // the result
  *      }
  * }
  */
-static zval *get_op_array(ea_op_array *op_array TSRMLS_DC) 
+static zval *get_op_array(ea_op_array *op_array TSRMLS_DC)
 {
     zval *return_value;
     MAKE_STD_ZVAL(return_value);
@@ -221,7 +228,7 @@
     if (op_array->opcodes) {
         zend_op *opline;
         zend_op *end;
-        
+
         opline = op_array->opcodes;
         end = opline + op_array->last;
 
@@ -236,7 +243,7 @@
 
             /* lineno */
             add_assoc_long(el, "lineno", opline->lineno);
-           
+
             /* opname */
             if (op != NULL) {
                 add_assoc_string(el, "opcode", (char *)op->opname, 1);
@@ -247,7 +254,7 @@
 
             /* extended value */
             if ((op->ops & EXT_MASK) == EXT_OPLINE) {
-                snprintf(buf, sizeof(buf), "opline(%lu)", opline->extended_value); 
+                snprintf(buf, sizeof(buf), "opline(%lu)", opline->extended_value);
             } else if ((op->ops & EXT_MASK) == EXT_FCALL) {
                 snprintf(buf, sizeof(buf), "args(%lu)", opline->extended_value);
             } else if ((op->ops & EXT_MASK) == EXT_ARG) {
@@ -318,26 +325,32 @@
 
             /* op1 */
             zval_used = 0;
-            if (opline->op1.op_type == IS_CV) {
-                snprintf(buf, sizeof(buf), "$cv%u(%s)", opline->op1.u.var, op_array->vars[opline->op1.u.var].name);
+            if (OP1_TYPE(opline) == IS_CV) {
+                snprintf(buf, sizeof(buf), "$cv%u(%s)", OP1_VARR(opline),
+                         op_array->vars[OP1_VARR(opline)].name);
             } else if ((op->ops & OP1_MASK) == OP1_OPLINE) {
-                snprintf(buf, sizeof(buf), "opline(%d)", opline->op1.u.opline_num);
+                snprintf(buf, sizeof(buf), "opline(%d)", OP1_OPLINE_NUM(opline));
             } else if ((op->ops & OP1_MASK) == OP1_JMPADDR) {
-                snprintf(buf, sizeof(buf), "opline(%u)", (unsigned int)(opline->op1.u.jmp_addr - op_array->opcodes));
+                snprintf(buf, sizeof(buf), "opline(%u)", (unsigned int)(OP1_JMP_ADDR(opline) - op_array->opcodes));
             } else if ((op->ops & OP1_MASK) == OP1_CLASS) {
-                snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(opline->op1.u.var));
+                snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(OP1_VARR(opline)));
 #ifdef ZEND_ENGINE_2_3
             } else if ((op->ops & OP1_MASK) == OP1_UCLASS) {
-                if (opline->op1.op_type == IS_UNUSED) {
+                if (OP1_TYPE(opline) == IS_UNUSED) {
                     buf[0] = '\0';
                 } else {
-                    snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(opline->op1.u.var));
+                    snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(OP1_VARR(opline)));
                 }
 #endif
             } else if ((op->ops & OP1_MASK) == OP1_BRK) {
-                if (opline->op1.u.opline_num != -1 && opline->op2.op_type == IS_CONST && opline->op2.u.constant.type == IS_LONG) {
-                    int level = opline->op2.u.constant.value.lval;
-                    zend_uint offset = opline->op1.u.opline_num;
+#ifdef ZEND_ENGINE_2_4
+                if (OP1_OPLINE_NUM(opline) != -1 && OP2_TYPE(opline) == IS_CONST && Z_TYPE_P(opline->op2.zv) == IS_LONG) {
+                    int level = Z_LVAL_P(opline->op2.zv);
+#else
+                if (OP1_OPLINE_NUM(opline) != -1 && OP2_TYPE(opline) == IS_CONST && opline->op2.u.constant.type == IS_LONG) {
+                    int level = Z_LVAL(OP2_CONST(opline));
+#endif
+                    zend_uint offset = OP1_OPLINE_NUM(opline);
                     zend_brk_cont_element *jmp_to;
                     do {
                         if (offset >= op_array->last_brk_cont) {
@@ -349,12 +362,17 @@
                     snprintf(buf, sizeof(buf), "opline(%d)", jmp_to->brk);
                 } else {
 brk_failed:
-                    snprintf(buf, sizeof(buf), "brk_cont(%u)", opline->op1.u.opline_num);
+                    snprintf(buf, sizeof(buf), "brk_cont(%u)", OP1_OPLINE_NUM(opline));
                 }
             } else if ((op->ops & OP1_MASK) == OP1_CONT) {
-                if (opline->op1.u.opline_num != -1 && opline->op2.op_type == IS_CONST && opline->op2.u.constant.type == IS_LONG) {
-                    int level = opline->op2.u.constant.value.lval;
-                    zend_uint offset = opline->op1.u.opline_num;
+#ifdef ZEND_ENGINE_2_4
+                if (OP1_OPLINE_NUM(opline) != -1 && OP2_TYPE(opline) == IS_CONST && Z_TYPE_P(opline->op2.zv) == IS_LONG) {
+                    int level = Z_LVAL_P(opline->op2.zv);
+#else
+                if (OP1_OPLINE_NUM(opline) != -1 && OP2_TYPE(opline) == IS_CONST && opline->op2.u.constant.type == IS_LONG) {
+                    int level = Z_LVAL(OP2_CONST(opline));
+#endif
+                    zend_uint offset = OP1_OPLINE_NUM(opline);
                     zend_brk_cont_element *jmp_to;
                     do {
                         if (offset >= op_array->last_brk_cont) {
@@ -366,26 +384,34 @@
                     snprintf(buf, sizeof(buf), "opline(%d)", jmp_to->cont);
                 } else {
 cont_failed:
-                    snprintf(buf, sizeof(buf), "brk_cont(%u)", opline->op1.u.opline_num);
+                    snprintf(buf, sizeof(buf), "brk_cont(%u)", OP1_OPLINE_NUM(opline));
                 }
             } else if ((op->ops & OP1_MASK) == OP1_ARG) {
-                snprintf(buf, sizeof(buf), "arg(%ld)", opline->op1.u.constant.value.lval);
+#ifdef ZEND_ENGINE_2_4
+                snprintf(buf, sizeof(buf), "arg(%ld)", opline->op1.num);
+#else
+                snprintf(buf, sizeof(buf), "arg(%ld)", Z_LVAL(OP1_CONST(opline)));
+#endif
             } else if ((op->ops & OP1_MASK) == OP1_VAR) {
-                snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(opline->op1.u.var));
+                snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(OP1_VARR(opline)));
             } else if ((op->ops & OP1_MASK) == OP1_TMP) {
-                snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(opline->op1.u.var));
+                snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(OP1_VARR(opline)));
             } else {
-                if (opline->op1.op_type == IS_CONST) {
+                if (OP1_TYPE(opline) == IS_CONST) {
                     zval_used = 1;
+#ifdef ZEND_ENGINE_2_4
+                    add_assoc_string(el, "op1", get_zval((zval*)opline->op1.literal), 0);
+#else
                     add_assoc_string(el, "op1", get_zval(&opline->op1.u.constant), 0);
-                } else if (opline->op1.op_type == IS_TMP_VAR) {
-                    snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(opline->op1.u.var));
-                } else if (opline->op1.op_type == IS_VAR) {
-                    snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(opline->op1.u.var));
-                } else if (opline->op1.op_type == IS_UNUSED) {
+#endif
+                } else if (OP1_TYPE(opline) == IS_TMP_VAR) {
+                    snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(OP1_VARR(opline)));
+                } else if (OP1_TYPE(opline) == IS_VAR) {
+                    snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(OP1_VARR(opline)));
+                } else if (OP1_TYPE(opline) == IS_UNUSED) {
                     buf[0] = '\0';
                 } else {
-                    snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", opline->op1.op_type);
+                    snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", OP1_TYPE(opline));
                 }
             }
             if (zval_used == 0) {
@@ -394,25 +420,50 @@
 
             /* op2 */
             zval_used = 0;
-            if (opline->op2.op_type == IS_CV) {
-                snprintf(buf, sizeof(buf), "$cv%u(%s)", opline->op2.u.var, op_array->vars[opline->op2.u.var].name);
+            if (OP2_TYPE(opline) == IS_CV) {
+                snprintf(buf, sizeof(buf), "$cv%u(%s)", OP2_VARR(opline), op_array->vars[OP2_VARR(opline)].name);
             } else if ((op->ops & OP2_MASK) == OP2_OPLINE) {
-                snprintf(buf, sizeof(buf), "opline(%d)", opline->op2.u.opline_num);
+                snprintf(buf, sizeof(buf), "opline(%d)", OP2_OPLINE_NUM(opline));
             } else if ((op->ops & OP2_MASK) == OP2_JMPADDR) {
-                snprintf(buf, sizeof(buf), "opline(%u)", (unsigned int) (opline->op2.u.jmp_addr - op_array->opcodes));
+                snprintf(buf, sizeof(buf), "opline(%u)", (unsigned int) (OP2_JMP_ADDR(opline) - op_array->opcodes));
             } else if ((op->ops & OP2_MASK) == OP2_CLASS) {
-                snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(opline->op2.u.var));
+                snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(OP2_VARR(opline)));
             } else if ((op->ops & OP2_MASK) == OP2_VAR) {
-                snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(opline->op2.u.var));
+                snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(OP2_VARR(opline)));
             } else if ((op->ops & OP2_MASK) == OP2_FETCH) {
                 const char *typename = NULL;
+#ifdef ZEND_ENGINE_2_4
+                GET_FETCHTYPENAME((opline->extended_value & ~ZEND_FETCH_TYPE_MASK), typename);
+//                if (opline->extended_value == ZEND_FETCH_STATIC_MEMBER) {
+                if (opline->op2_type == IS_CONST) {
+                    snprintf(buf, sizeof(buf), "%s %s", typename, Z_STRVAL_P(opline->op2.zv));
+                } else {
+                    snprintf(buf, sizeof(buf), "%s", typename);
+                }
+#else
                 GET_FETCHTYPENAME(opline->op2.u.EA.type, typename);
                 if (opline->op2.u.EA.type == ZEND_FETCH_STATIC_MEMBER) {
-                    snprintf(buf, sizeof(buf), "%s $class%u", typename, VAR_NUM(opline->op2.u.var));
+                    snprintf(buf, sizeof(buf), "%s $class%u", typename, VAR_NUM(OP2_VARR(opline)));
                 } else {
                     snprintf(buf, sizeof(buf), "%s", typename);
                 }
+#endif
             } else if ((op->ops & OP2_MASK) == OP2_INCLUDE) {
+#ifdef ZEND_ENGINE_2_4
+                if (opline->extended_value == ZEND_EVAL) {
+                    snprintf(buf, sizeof(buf), "ZEND_EVAL");
+                } else if (opline->extended_value == ZEND_INCLUDE) {
+                    snprintf(buf, sizeof(buf), "ZEND_INCLUDE");
+                } else if (opline->extended_value == ZEND_INCLUDE_ONCE) {
+                    snprintf(buf, sizeof(buf), "ZEND_INCLUDE_ONCE");
+                } else if (opline->extended_value == ZEND_REQUIRE) {
+                    snprintf(buf, sizeof(buf), "ZEND_REQUIRE");
+                } else if (opline->extended_value == ZEND_REQUIRE_ONCE) {
+                    snprintf(buf, sizeof(buf), "ZEND_REQUIRE_ONCE");
+                } else {
+                    buf[0] = '\0';
+                }
+#else
                 if (opline->op2.u.constant.value.lval == ZEND_EVAL) {
                     snprintf(buf, sizeof(buf), "ZEND_EVAL");
                 } else if (opline->op2.u.constant.value.lval == ZEND_INCLUDE) {
@@ -426,9 +477,19 @@
                 } else {
                     buf[0] = '\0';
                 }
+#endif
             } else if ((op->ops & OP2_MASK) == OP2_ARG) {
-                snprintf(buf, sizeof(buf), "arg(%u)", opline->op2.u.opline_num);
+                snprintf(buf, sizeof(buf), "arg(%u)", OP2_OPLINE_NUM(opline));
             } else if ((op->ops & OP2_MASK) == OP2_ISSET) {
+#ifdef ZEND_ENGINE_2_4
+                if (opline->extended_value == ZEND_ISSET) {
+                    snprintf(buf, sizeof(buf), "ZEND_ISSET");
+                } else if (opline->extended_value == ZEND_ISEMPTY) {
+                    snprintf(buf, sizeof(buf), "ZEND_ISEMPTY");
+                } else {
+                    buf[0] = '\0';
+                }
+#else
                 if (opline->op2.u.constant.value.lval == ZEND_ISSET) {
                     snprintf(buf, sizeof(buf), "ZEND_ISSET");
                 } else if (opline->op2.u.constant.value.lval == ZEND_ISEMPTY) {
@@ -436,18 +497,23 @@
                 } else {
                     buf[0] = '\0';
                 }
+#endif
             } else {
-                if (opline->op2.op_type == IS_CONST) {
+                if (OP2_TYPE(opline) == IS_CONST) {
                     zval_used = 1;
+#ifdef ZEND_ENGINE_2_4
+                    add_assoc_string(el, "op2", get_zval((zval*)opline->op2.literal), 0);
+#else
                     add_assoc_string(el, "op2", get_zval(&opline->op2.u.constant), 0);
-                } else if (opline->op2.op_type == IS_TMP_VAR) {
-                    snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(opline->op2.u.var));
-                } else if (opline->op2.op_type == IS_VAR) {
-                    snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(opline->op2.u.var));
-                } else if (opline->op2.op_type == IS_UNUSED) {
+#endif
+                } else if (OP2_TYPE(opline) == IS_TMP_VAR) {
+                    snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(OP2_VARR(opline)));
+                } else if (OP2_TYPE(opline) == IS_VAR) {
+                    snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(OP2_VARR(opline)));
+                } else if (OP2_TYPE(opline) == IS_UNUSED) {
                     buf[0] = '\0';
                 } else {
-                    snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", opline->op2.op_type);
+                    snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", OP2_TYPE(opline));
                 }
             }
             if (zval_used == 0) {
@@ -456,51 +522,63 @@
 
             /* result */
             zval_used = 0;
-            if (opline->result.op_type == IS_CV) {
-                snprintf(buf, sizeof(buf), "$cv%u(%s)", opline->result.u.var, op_array->vars[opline->result.u.var].name);
-            } else 
-            switch (op->ops & RES_MASK) {
+            if (RES_TYPE(opline) & IS_CV) {
+                snprintf(buf, sizeof(buf), "$cv%u(%s)", RES_VARR(opline), op_array->vars[RES_VARR(opline)].name);
+            } else
+                switch (op->ops & RES_MASK) {
                 case RES_STD:
-                    if (opline->result.op_type == IS_CONST) {
+                    if (RES_TYPE(opline) & IS_CONST) {
                         zval_used = 1;
+#ifdef ZEND_ENGINE_2_4
+                        add_assoc_string(el, "result", get_zval((zval*)opline->result.literal), 0);
+#else
                         add_assoc_string(el, "result", get_zval(&opline->result.u.constant), 0);
-                    } else if (opline->result.op_type == IS_TMP_VAR) {
-                        snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(opline->result.u.var)); 
-                    } else if (opline->result.op_type == IS_VAR) {
+#endif
+                    } else if (RES_TYPE(opline) & IS_TMP_VAR) {
+                        snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(RES_VARR(opline)));
+                    } else if (RES_TYPE(opline) & IS_VAR) {
+#ifdef ZEND_ENGINE_2_4
+                        if ((RES_TYPE(opline) & EXT_TYPE_UNUSED) != 0) {
+#else
                         if ((opline->result.u.EA.type & EXT_TYPE_UNUSED) != 0) {
-                            snprintf(buf, sizeof(buf), "$var%u (unused)", VAR_NUM(opline->result.u.var));
+#endif
+                            snprintf(buf, sizeof(buf), "$var%u (unused)", VAR_NUM(RES_VARR(opline)));
                         } else {
-                            snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(opline->result.u.var));
+                            snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(RES_VARR(opline)));
                         }
-                    } else if (opline->result.op_type == IS_UNUSED) {
+                    } else if (RES_TYPE(opline) & IS_UNUSED) {
                         buf[0] = '\0';
                     } else {
-                        snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", opline->result.op_type);
+                        snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", RES_TYPE(opline));
                     }
                     break;
                 case RES_CLASS:
-                    snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(opline->result.u.var));
+                    snprintf(buf, sizeof(buf), "$class%u", VAR_NUM(RES_VARR(opline)));
                     break;
                 case RES_TMP:
-                    snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(opline->result.u.var));
+                    snprintf(buf, sizeof(buf), "$tmp%u", VAR_NUM(RES_VARR(opline)));
                     break;
                 case RES_VAR:
+#ifdef ZEND_ENGINE_2_4
+                    if ((RES_TYPE(opline) & EXT_TYPE_UNUSED) != 0) {
+#else
                     if ((opline->result.u.EA.type & EXT_TYPE_UNUSED) != 0) {
-                        snprintf(buf, sizeof(buf), "$var%u (unused)", VAR_NUM(opline->result.u.var));
+#endif
+                        snprintf(buf, sizeof(buf), "$var%u (unused)", VAR_NUM(RES_VARR(opline)));
                     } else {
-                        snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(opline->result.u.var));
+                        snprintf(buf, sizeof(buf), "$var%u", VAR_NUM(RES_VARR(opline)));
                     }
                     break;
                 case RES_UNUSED:
                     buf[0] = '\0';
                     break;
                 case RES_OPLINE:
-                    snprintf(buf, sizeof(buf), "opline(%d)", opline->result.u.opline_num);
+                    snprintf(buf, sizeof(buf), "opline(%d)", RES_OPLINE_NUM(opline));
                     break;
                 default:
-                    snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", opline->result.op_type);
+                    snprintf(buf, sizeof(buf), "UNKNOWN NODE %d", RES_TYPE(opline));
                     break;
-            }
+                }
             if (zval_used == 0) {
                 add_assoc_string(el, "result", buf, 1);
             }
@@ -513,15 +591,14 @@
 /* }}} */
 
 /* {{{ get_cache_entry: get the cache_entry for the given file */
-static ea_cache_entry *get_cache_entry(const char *file) {
+static ea_cache_entry *get_cache_entry(const char *file)
+{
     unsigned int slot;
     ea_cache_entry *p;
     ea_cache_entry *result = NULL;
-    
+
     if (file != NULL) {
-        EACCELERATOR_UNPROTECT();
         EACCELERATOR_LOCK_RD();
-        EACCELERATOR_PROTECT();
         for (slot = 0; slot < EA_HASH_SIZE; slot++) {
             p = ea_mm_instance->hash[slot];
             while (p != NULL) {
@@ -531,9 +608,7 @@
                 p = p->next;
             }
         }
-        EACCELERATOR_UNPROTECT();
         EACCELERATOR_UNLOCK_RD();
-        EACCELERATOR_PROTECT();
     }
     return result;
 }
@@ -561,8 +636,9 @@
     zval *functions;
     zval *classes;
 
-    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &file, &file_len) == FAILURE)
+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &file, &file_len) == FAILURE) {
         return;
+    }
 
     if (ea_mm_instance == NULL || php_check_open_basedir(file TSRMLS_CC)) {
         RETURN_NULL();
@@ -572,9 +648,9 @@
     if (p == NULL) {
         RETURN_NULL();
     }
-  
+
     array_init(return_value);
-   
+
     /* file op_array */
     add_assoc_zval(return_value, "op_array", get_op_array(p->op_array TSRMLS_CC));
 
@@ -583,7 +659,8 @@
     MAKE_STD_ZVAL(functions);
     array_init(functions);
     while (fc != NULL) {
-        add_assoc_zval(functions, fc->htabkey, get_op_array((ea_op_array *)fc->fc TSRMLS_CC));
+        ea_op_array *func = (ea_op_array *) fc->fc;
+        add_assoc_zval(functions, func->function_name, get_op_array(func TSRMLS_CC));
         fc = fc->next;
     }
     add_assoc_zval(return_value, "functions", functions);
@@ -614,7 +691,7 @@
             fc = fc->next;
         }
     }
-    add_assoc_zval(return_value, "classes", classes); 
+    add_assoc_zval(return_value, "classes", classes);
 }
 /* }}} */
 
@@ -625,7 +702,6 @@
  * tab-width: 4
  * c-basic-offset: 4
  * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim<600: noet sw=4 ts=4
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
  */
-
diff -Naur orig/ea_dasm.h patched/ea_dasm.h
--- orig/ea_dasm.h	2010-01-19 16:49:13.000000000 +0100
+++ patched/ea_dasm.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,8 +2,8 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
-   | http://eaccelerator.net                                  			  |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
+   | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
    | modify it under the terms of the GNU General Public License          |
@@ -42,7 +42,6 @@
  * tab-width: 4
  * c-basic-offset: 4
  * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim<600: noet sw=4 ts=4
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
  */
-
diff -Naur orig/ea_info.c patched/ea_info.c
--- orig/ea_info.c	2010-01-19 16:49:13.000000000 +0100
+++ patched/ea_info.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,8 +2,8 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
-   | http://eaccelerator.net                                  			  |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
+   | http://eaccelerator.net                                  	          |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
    | modify it under the terms of the GNU General Public License          |
@@ -48,7 +48,8 @@
 extern zend_bool ea_scripts_shm_only;
 
 /* {{{ isAdminAllowed(): check if the admin functions are allowed for the calling script */
-static int isAdminAllowed(TSRMLS_D) {
+static int isAdminAllowed(TSRMLS_D)
+{
     const char *filename = zend_get_executed_filename(TSRMLS_C);
     if (EAG(allowed_admin_path) && *EAG(allowed_admin_path)) {
         char *path;
@@ -59,12 +60,12 @@
         p = path;
 
         while (p && *p) {
-            next = strchr(p, DEFAULT_DIR_SEPARATOR); 
+            next = strchr(p, DEFAULT_DIR_SEPARATOR);
             if (next != NULL) {
                 *next = '\0';
                 ++next;
             }
-            
+
             if (!php_check_specific_open_basedir(p, filename TSRMLS_CC)) {
                 efree(path);
                 return 1;
@@ -83,185 +84,184 @@
 static void clear_filecache(const char* dir)
 #ifndef ZEND_WIN32
 {
-	DIR *dp;
-	struct dirent *entry;
-	char s[MAXPATHLEN];
-	struct stat dirstat;
-	
-	if ((dp = opendir(dir)) != NULL) {
-		while ((entry = readdir(dp)) != NULL) {
-			strncpy(s, dir, MAXPATHLEN - 1);
-			strlcat(s, "/", MAXPATHLEN);
-			strlcat(s, entry->d_name, MAXPATHLEN);
-			if (strstr(entry->d_name, "eaccelerator") == entry->d_name) {
-				unlink(s);
-			}
-			if (stat(s, &dirstat) != -1) {
-				if (strcmp(entry->d_name, ".") == 0)
-					continue;
-				if (strcmp(entry->d_name, "..") == 0)
-					continue;
-				if (S_ISDIR(dirstat.st_mode)) {
-					clear_filecache(s);
-				}
-			}
-		}
-		closedir (dp);
-	} else {
-		ea_debug_error("[%s] Could not open cachedir %s\n", EACCELERATOR_EXTENSION_NAME, dir);
-	}
+    DIR *dp;
+    struct dirent *entry;
+    char s[MAXPATHLEN];
+    struct stat dirstat;
+
+    if ((dp = opendir(dir)) != NULL) {
+        while ((entry = readdir(dp)) != NULL) {
+            strncpy(s, dir, MAXPATHLEN - 1);
+            strlcat(s, "/", MAXPATHLEN);
+            strlcat(s, entry->d_name, MAXPATHLEN);
+            if (strstr(entry->d_name, "eaccelerator") == entry->d_name) {
+                unlink(s);
+            }
+            if (stat(s, &dirstat) != -1) {
+                if (strcmp(entry->d_name, ".") == 0) {
+                    continue;
+                }
+                if (strcmp(entry->d_name, "..") == 0) {
+                    continue;
+                }
+                if (S_ISDIR(dirstat.st_mode)) {
+                    clear_filecache(s);
+                }
+            }
+        }
+        closedir (dp);
+    } else {
+        ea_debug_error("[%s] Could not open cachedir %s\n", EACCELERATOR_EXTENSION_NAME, dir);
+    }
 }
 #else
 {
-	HANDLE  hFind;
+    HANDLE  hFind;
     WIN32_FIND_DATA wfd;
     char path[MAXPATHLEN];
     size_t dirlen = strlen(dir);
-  
+
     memcpy(path, dir, dirlen);
     strcpy(path + dirlen++, "\\eaccelerator*");
 
     hFind = FindFirstFile(path, &wfd);
-	if (hFind == INVALID_HANDLE_VALUE) {
-		do {
-			strcpy(path + dirlen, wfd.cFileName);
-			if (FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes) {
-				clear_filecache(path);
-			} else if (!DeleteFile(path)) {
-				ea_debug_error("[%s] Can't delete file %s: error %d\n", EACCELERATOR_EXTENSION_NAME, path, GetLastError());
-			}
-		} while (FindNextFile(hFind, &wfd));
-	}
+    if (hFind == INVALID_HANDLE_VALUE) {
+        do {
+            strcpy(path + dirlen, wfd.cFileName);
+            if (FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes) {
+                clear_filecache(path);
+            } else if (!DeleteFile(path)) {
+                ea_debug_error("[%s] Can't delete file %s: error %d\n", EACCELERATOR_EXTENSION_NAME, path, GetLastError());
+            }
+        } while (FindNextFile(hFind, &wfd));
+    }
     FindClose (hFind);
 }
 #endif
 /* }}} */
 
 /* {{{  clean_file: check if the given file is expired */
-static inline void clean_file(char *file, time_t t) 
+static inline void clean_file(char *file, time_t t)
 {
-	int f;
+    int f;
 
-	if ((f = open(file, O_RDONLY | O_BINARY)) > 0) {
-		ea_file_header hdr;
-		EACCELERATOR_FLOCK (f, LOCK_SH);
-		if (read(f, &hdr, sizeof(hdr)) != sizeof(hdr) 
-				|| strncmp (hdr.magic, EA_MAGIC,	8) != 0 
-				|| (hdr.mtime != 0 && hdr.mtime < t)) {
-			EACCELERATOR_FLOCK (f, LOCK_UN);
-			close (f);
-			unlink (file);
-		} else {
-			EACCELERATOR_FLOCK (f, LOCK_UN);
-			close (f);
-		}
-	}
+    if ((f = open(file, O_RDONLY | O_BINARY)) > 0) {
+        ea_file_header hdr;
+        EACCELERATOR_FLOCK (f, LOCK_SH);
+        if (read(f, &hdr, sizeof(hdr)) != sizeof(hdr)
+                || strncmp (hdr.magic, EA_MAGIC,	8) != 0
+                || (hdr.mtime != 0 && hdr.mtime < t)) {
+            EACCELERATOR_FLOCK (f, LOCK_UN);
+            close (f);
+            unlink (file);
+        } else {
+            EACCELERATOR_FLOCK (f, LOCK_UN);
+            close (f);
+        }
+    }
 }
 /* }}} */
 
 /* {{{ PHP_FUNCTION(eaccelerator_clean): remove all expired scripts and data from shared memory and disk cache */
 PHP_FUNCTION(eaccelerator_clean)
 {
-	time_t t;
+    time_t t;
 
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
 
-	if (!isAdminAllowed(TSRMLS_C)) {
-		zend_error(E_WARNING, NOT_ADMIN_WARNING);
-		RETURN_NULL();
-	}
+    if (!isAdminAllowed(TSRMLS_C)) {
+        zend_error(E_WARNING, NOT_ADMIN_WARNING);
+        RETURN_NULL();
+    }
 
-	t = time (NULL);
+    t = time (NULL);
 
-	/* Remove expired scripts from shared memory */
-	eaccelerator_prune (t);
+    /* Remove expired scripts from shared memory */
+    eaccelerator_prune (t);
 }
 /* }}} */
 
 /* {{{ PHP_FUNCTION(eaccelerator_check_mtime): enable or disable check_mtime */
-PHP_FUNCTION(eaccelerator_check_mtime) 
+PHP_FUNCTION(eaccelerator_check_mtime)
 {
     zend_bool enable;
-    
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "b", &enable) == FAILURE)
-		return;
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "b", &enable) == FAILURE) {
+        return;
+    }
 
     if (isAdminAllowed(TSRMLS_C)) {
-        EACCELERATOR_UNPROTECT();
         if (enable) {
             ea_mm_instance->check_mtime_enabled = 1;
         } else {
             ea_mm_instance->check_mtime_enabled = 0;
         }
-        EACCELERATOR_PROTECT();
     } else {
         zend_error(E_WARNING, NOT_ADMIN_WARNING);
     }
-    
+
     RETURN_NULL();
 }
 /* }}} */
 
 /* {{{ PHP_FUNCTION(eaccelerator_optimizer): enable or disable optimizer */
 #ifdef WITH_EACCELERATOR_OPTIMIZER
-PHP_FUNCTION(eaccelerator_optimizer) 
+PHP_FUNCTION(eaccelerator_optimizer)
 {
     zend_bool enable;
-    
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "b", &enable) == FAILURE)
-		return;
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
+
+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "b", &enable) == FAILURE) {
+        return;
+    }
 
     if (isAdminAllowed(TSRMLS_C)) {
-        EACCELERATOR_UNPROTECT();
         if (enable) {
             ea_mm_instance->optimizer_enabled = 1;
         } else {
             ea_mm_instance->optimizer_enabled = 0;
         }
-        EACCELERATOR_PROTECT();
     } else {
         zend_error(E_WARNING, NOT_ADMIN_WARNING);
     }
-    
+
     RETURN_NULL();
 }
 #endif
 /* }}} */
 
 /* {{{ PHP_FUNCTION(eaccelerator_caching): enable or disable caching */
-PHP_FUNCTION(eaccelerator_caching) 
+PHP_FUNCTION(eaccelerator_caching)
 {
     zend_bool enable;
 
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "b", &enable) == FAILURE)
-		return;
+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "b", &enable) == FAILURE) {
+        return;
+    }
 
     if (isAdminAllowed(TSRMLS_C)) {
-        EACCELERATOR_UNPROTECT();
         if (enable) {
             ea_mm_instance->enabled = 1;
         } else {
             ea_mm_instance->enabled = 0;
         }
-        EACCELERATOR_PROTECT();
     } else {
         zend_error(E_WARNING, NOT_ADMIN_WARNING);
     }
-    
+
     RETURN_NULL();
 }
 /* }}} */
@@ -269,42 +269,40 @@
 /* {{{ PHP_FUNCTION(eaccelerator_clear): remove all unused scripts and data from shared memory and disk cache */
 PHP_FUNCTION(eaccelerator_clear)
 {
-	unsigned int i;
-	ea_cache_entry *p;
+    unsigned int i;
+    ea_cache_entry *p;
 
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
 
     if (!isAdminAllowed(TSRMLS_C)) {
         zend_error(E_WARNING, NOT_ADMIN_WARNING);
         RETURN_NULL();
     }
 
-	EACCELERATOR_UNPROTECT ();
-	EACCELERATOR_LOCK_RW ();
-	for (i = 0; i < EA_HASH_SIZE; i++) {
-		p = ea_mm_instance->hash[i];
-		while (p != NULL) {
-			ea_cache_entry *r = p;
-			p = p->next;
-			ea_mm_instance->hash_cnt--;
-			if (r->use_cnt <= 0) {
-				eaccelerator_free_nolock (r);
-			} else {
-				r->removed = 1;
-				r->next = ea_mm_instance->removed;
-				ea_mm_instance->removed = r;
-				ea_mm_instance->rem_cnt++;
-			}
-		}
-		ea_mm_instance->hash[i] = NULL;
-	}
-	EACCELERATOR_UNLOCK_RW ();
-	EACCELERATOR_PROTECT ();
+    EACCELERATOR_LOCK_RW ();
+    for (i = 0; i < EA_HASH_SIZE; i++) {
+        p = ea_mm_instance->hash[i];
+        while (p != NULL) {
+            ea_cache_entry *r = p;
+            p = p->next;
+            ea_mm_instance->hash_cnt--;
+            if (r->use_cnt <= 0) {
+                eaccelerator_free_nolock (r);
+            } else {
+                r->removed = 1;
+                r->next = ea_mm_instance->removed;
+                ea_mm_instance->removed = r;
+                ea_mm_instance->rem_cnt++;
+            }
+        }
+        ea_mm_instance->hash[i] = NULL;
+    }
+    EACCELERATOR_UNLOCK_RW ();
 
-	if(!ea_scripts_shm_only) {
-		clear_filecache(EAG(cache_dir));
+    if(!ea_scripts_shm_only) {
+        clear_filecache(EAG(cache_dir));
     }
 
     RETURN_NULL();
@@ -320,21 +318,19 @@
         RETURN_NULL();
     }
 
-	if (ea_mm_instance != NULL) {
-		ea_cache_entry *p, *q;
-		EACCELERATOR_UNPROTECT();
-		EACCELERATOR_LOCK_RW();
-		p = ea_mm_instance->removed;
-		ea_mm_instance->rem_cnt = 0;
-		ea_mm_instance->removed = NULL;
-		while (p != NULL) {
-			q = p->next;
-			eaccelerator_free_nolock(p);
-			p = q;
-		}
-		EACCELERATOR_UNLOCK_RW();
-		EACCELERATOR_PROTECT();
-	}
+    if (ea_mm_instance != NULL) {
+        ea_cache_entry *p, *q;
+        EACCELERATOR_LOCK_RW();
+        p = ea_mm_instance->removed;
+        ea_mm_instance->rem_cnt = 0;
+        ea_mm_instance->removed = NULL;
+        while (p != NULL) {
+            q = p->next;
+            eaccelerator_free_nolock(p);
+            p = q;
+        }
+        EACCELERATOR_UNLOCK_RW();
+    }
     RETURN_NULL();
 }
 /* }}} */
@@ -344,42 +340,42 @@
 // returhs the same as eaccelerator section in phpinfo
 PHP_FUNCTION (eaccelerator_info)
 {
-	unsigned int available;
+    unsigned int available;
     char *shm, *sem;
 
     shm = (char *)mm_shm_type();
     sem = (char *)mm_sem_type();
 
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
-
-	available = mm_available (ea_mm_instance->mm);
-
-	// init return table
-	array_init(return_value);
-	
-	// put eaccelerator information
-	add_assoc_string(return_value, "version", EACCELERATOR_VERSION, 1);
-	add_assoc_string(return_value, "shm_type", shm, 1);
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
+
+    available = mm_available (ea_mm_instance->mm);
+
+    // init return table
+    array_init(return_value);
+
+    // put eaccelerator information
+    add_assoc_string(return_value, "version", EACCELERATOR_VERSION, 1);
+    add_assoc_string(return_value, "shm_type", shm, 1);
     add_assoc_string(return_value, "sem_type", sem, 1);
     add_assoc_string(return_value, "logo", EACCELERATOR_LOGO_GUID, 1);
-	add_assoc_bool(return_value, "cache", (EAG (enabled)
-		&& (ea_mm_instance != NULL)
-		&& ea_mm_instance->enabled) ? 1 : 0);
-	add_assoc_bool(return_value, "optimizer", (EAG (optimizer_enabled)
-		&& (ea_mm_instance != NULL)
-		&& ea_mm_instance->optimizer_enabled) ? 1 : 0);
-	add_assoc_bool(return_value, "check_mtime", (EAG (check_mtime_enabled)
-		&& (ea_mm_instance != NULL)
-		&& ea_mm_instance->check_mtime_enabled) ? 1 : 0);
-	add_assoc_long(return_value, "memorySize", ea_mm_instance->total);
-	add_assoc_long(return_value, "memoryAvailable", available);
-	add_assoc_long(return_value, "memoryAllocated", ea_mm_instance->total - available);
-	add_assoc_long(return_value, "cachedScripts", ea_mm_instance->hash_cnt);
-	add_assoc_long(return_value, "removedScripts", ea_mm_instance->rem_cnt);
+    add_assoc_bool(return_value, "cache", (EAG (enabled)
+                                           && (ea_mm_instance != NULL)
+                                           && ea_mm_instance->enabled) ? 1 : 0);
+    add_assoc_bool(return_value, "optimizer", (EAG (optimizer_enabled)
+                   && (ea_mm_instance != NULL)
+                   && ea_mm_instance->optimizer_enabled) ? 1 : 0);
+    add_assoc_bool(return_value, "check_mtime", (EAG (check_mtime_enabled)
+                   && (ea_mm_instance != NULL)
+                   && ea_mm_instance->check_mtime_enabled) ? 1 : 0);
+    add_assoc_long(return_value, "memorySize", ea_mm_instance->total);
+    add_assoc_long(return_value, "memoryAvailable", available);
+    add_assoc_long(return_value, "memoryAllocated", ea_mm_instance->total - available);
+    add_assoc_long(return_value, "cachedScripts", ea_mm_instance->hash_cnt);
+    add_assoc_long(return_value, "removedScripts", ea_mm_instance->rem_cnt);
 
-	return;
+    return;
 }
 /* }}} */
 
@@ -389,17 +385,17 @@
     ea_cache_entry *p;
     int i;
 
- 	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
 
-	if (!isAdminAllowed(TSRMLS_C)) {
+    if (!isAdminAllowed(TSRMLS_C)) {
         zend_error(E_WARNING, NOT_ADMIN_WARNING);
         RETURN_NULL();
     }
 
     array_init(return_value);
-    
+
     for (i = 0; i < EA_HASH_SIZE; i++) {
         p = ea_mm_instance->hash[i];
         while (p != NULL) {
@@ -414,7 +410,7 @@
             add_assoc_long(script, "reloads", p->nreloads);
             add_assoc_long(script, "usecount", p->use_cnt);
             add_assoc_long(script, "hits", p->nhits);
-            add_next_index_zval(return_value, script); 
+            add_next_index_zval(return_value, script);
             p = p->next;
         }
     }
@@ -428,20 +424,20 @@
     ea_cache_entry *p;
     zval *script;
 
-	if (ea_mm_instance == NULL) {
-		RETURN_NULL();
-	}
+    if (ea_mm_instance == NULL) {
+        RETURN_NULL();
+    }
 
     if (!isAdminAllowed(TSRMLS_C)) {
         zend_error(E_WARNING, NOT_ADMIN_WARNING);
         RETURN_NULL();
     }
 
-    MAKE_STD_ZVAL(script);
     array_init(return_value);
 
     p = ea_mm_instance->removed;
     while (p != NULL) {
+        MAKE_STD_ZVAL(script);
         array_init(script);
         add_assoc_string(script, "file", p->realfilename, 1);
         add_assoc_long(script, "mtime", p->mtime);
@@ -449,7 +445,7 @@
         add_assoc_long(script, "reloads", p->nreloads);
         add_assoc_long(script, "usecount", p->use_cnt);
         add_assoc_long(script, "hits", p->nhits);
-        add_next_index_zval(return_value, script); 
+        add_next_index_zval(return_value, script);
         p = p->next;
     }
     return;
@@ -463,7 +459,6 @@
  * tab-width: 4
  * c-basic-offset: 4
  * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim<600: noet sw=4 ts=4
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
  */
-
diff -Naur orig/ea_info.h patched/ea_info.h
--- orig/ea_info.h	2010-01-19 16:49:13.000000000 +0100
+++ patched/ea_info.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,8 +2,8 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
-   | http://eaccelerator.net                                  			  |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
+   | http://eaccelerator.net                                  	          |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
    | modify it under the terms of the GNU General Public License          |
@@ -50,7 +50,6 @@
  * tab-width: 4
  * c-basic-offset: 4
  * End:
- * vim600: noet sw=4 ts=4 fdm=marker
- * vim<600: noet sw=4 ts=4
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
  */
-
diff -Naur orig/ea_restore.c patched/ea_restore.c
--- orig/ea_restore.c	2010-02-18 13:36:52.000000000 +0100
+++ patched/ea_restore.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id: ea_restore.c 404 2010-02-18 12:36:52Z hans $
+   $Id: ea_restore.c 405 2010-02-18 12:53:07Z hans $
 */
 
 #include "eaccelerator.h"
@@ -64,11 +64,14 @@
 
     property_dtor = dummy_class_entry.properties_info.pDestructor;
 
-    zend_hash_destroy(&dummy_class_entry.default_properties);
     zend_hash_destroy(&dummy_class_entry.function_table);
     zend_hash_destroy(&dummy_class_entry.constants_table);
     zend_hash_destroy(&dummy_class_entry.properties_info);
+#ifndef ZEND_ENGINE_2_4
+    zend_hash_destroy(&dummy_class_entry.default_properties);
     zend_hash_destroy(&dummy_class_entry.default_static_members);
+#endif
+
     return property_dtor;
 }
 
@@ -84,7 +87,9 @@
 static void fixup_property_info(char *base, zend_property_info * from TSRMLS_DC)
 {
     FIXUP(base, from->name);
+#ifdef INCLUDE_DOC_COMMENTS
     FIXUP(base, from->doc_comment);
+#endif
 }
 
 static void fixup_hash(char *base, HashTable * source,
@@ -105,6 +110,9 @@
 
         p = source->pListHead;
         while (p) {
+#ifdef ZEND_ENGINE_2_4
+            FIXUP(base, p->arKey);
+#endif
             FIXUP(base, p->pNext);
             FIXUP(base, p->pLast);
             FIXUP(base, p->pData);
@@ -126,20 +134,20 @@
 void fixup_zval(char *base, zval * zv TSRMLS_DC)
 {
     switch (EA_ZV_TYPE_P(zv)) {
-        case IS_CONSTANT:           /* fallthrough */
-        case IS_OBJECT:             /* fallthrough: object are serialized */
-        case IS_STRING:
-            FIXUP(base, Z_STRVAL_P(zv));
-            break;
-
-        case IS_ARRAY:              /* fallthrough */
-        case IS_CONSTANT_ARRAY:
-            FIXUP(base, Z_ARRVAL_P(zv));
-            fixup_zval_hash(base, Z_ARRVAL_P(zv));
-            break;
+    case IS_CONSTANT:           /* fallthrough */
+    case IS_OBJECT:             /* fallthrough: object are serialized */
+    case IS_STRING:
+        FIXUP(base, Z_STRVAL_P(zv));
+        break;
 
-        default:
-            break;
+    case IS_ARRAY:              /* fallthrough */
+    case IS_CONSTANT_ARRAY:
+        FIXUP(base, Z_ARRVAL_P(zv));
+        fixup_zval_hash(base, Z_ARRVAL_P(zv));
+        break;
+
+    default:
+        break;
     }
 }
 
@@ -147,9 +155,9 @@
 {
     zend_op *opline;
     zend_op *end;
+    zend_uint i;
 
     if (from->num_args > 0) {
-        zend_uint i;
         FIXUP(base, from->arg_info);
         for (i = 0; i < from->num_args; i++) {
             FIXUP(base, from->arg_info[i].name);
@@ -162,26 +170,52 @@
         return;
     }
 
+#ifdef ZEND_ENGINE_2_4
+    if (from->literals != NULL) {
+        zend_literal *l, *end;
+
+        FIXUP(base, from->literals);
+        l = from->literals;
+        end = from->literals + from->last_literal;
+        while (l < end) {
+                fixup_zval(base, &l->constant TSRMLS_CC);
+            l++;
+        }
+    }
+#endif
+
     if (from->opcodes != NULL) {
         FIXUP(base, from->opcodes);
 
         opline = from->opcodes;
         end = opline + from->last;
         for (; opline < end; opline++) {
-            /*
-               if (opline->result.op_type == IS_CONST) 
-               fixup_zval(&opline->result.u.constant TSRMLS_CC);
-             */
-            if (opline->op1.op_type == IS_CONST)
+#ifdef ZEND_ENGINE_2_4
+            if (opline->op1_type == IS_CONST) {
+                FIXUP(base, opline->op1.literal);
+            }
+            if (opline->op2_type == IS_CONST) {
+                FIXUP(base, opline->op2.literal);
+            }
+#else
+            if (opline->op1.op_type == IS_CONST) {
                 fixup_zval(base, &opline->op1.u.constant TSRMLS_CC);
-            if (opline->op2.op_type == IS_CONST)
+            }
+            if (opline->op2.op_type == IS_CONST) {
                 fixup_zval(base, &opline->op2.u.constant TSRMLS_CC);
+            }
+#endif
+
             switch (opline->opcode) {
 #ifdef ZEND_GOTO
             case ZEND_GOTO:
 #endif
             case ZEND_JMP:
+#ifdef ZEND_ENGINE_2_4
+                FIXUP(base, opline->op1.jmp_addr);
+#else
                 FIXUP(base, opline->op1.u.jmp_addr);
+#endif
                 break;
             case ZEND_JMPZ: /* fallthrough */
             case ZEND_JMPNZ:
@@ -190,7 +224,12 @@
 #ifdef ZEND_ENGINE_2_3
             case ZEND_JMP_SET:
 #endif
+#ifdef ZEND_ENGINE_2_4
+            case ZEND_JMP_SET_VAR:
+                FIXUP(base, opline->op2.jmp_addr);
+#else
                 FIXUP(base, opline->op2.u.jmp_addr);
+#endif
                 break;
             }
             ZEND_VM_SET_OPCODE_HANDLER(opline);
@@ -217,13 +256,18 @@
 
 static void fixup_class_entry(char *base, ea_class_entry *from TSRMLS_DC)
 {
+#ifdef ZEND_ENGINE_2_4
+    int i;
+#endif
+
     FIXUP(base, from->name);
     FIXUP(base, from->parent);
     FIXUP(base, from->filename);
     fixup_zval_hash(base, &from->constants_table);
-    fixup_zval_hash(base, &from->default_properties);
     fixup_hash(base, &from->properties_info,
                (fixup_bucket_t) fixup_property_info TSRMLS_CC);
+#ifndef ZEND_ENGINE_2_4
+    fixup_zval_hash(base, &from->default_properties);
     fixup_zval_hash(base, &from->default_static_members);
     if (from->static_members != NULL) {
         FIXUP(base, from->static_members);
@@ -231,7 +275,31 @@
             fixup_zval_hash(base, from->static_members);
         }
     }
+#else
+    if (from->default_properties_count) {
+        FIXUP(base, from->default_properties_table);
+        for (i = 0; i < from->default_properties_count; i++) {
+            if (from->default_properties_table[i]) {
+                FIXUP(base, from->default_properties_table[i]);
+                fixup_zval(base, from->default_properties_table[i] TSRMLS_CC);
+            }
+        }
+    }
+
+    if (from->default_static_members_count) {
+        FIXUP(base, from->default_static_members_table);
+        for (i = 0; i < from->default_static_members_count; i++) {
+            if (from->default_static_members_table[i]) {
+                FIXUP(base, from->default_static_members_table[i]);
+                fixup_zval(base, from->default_static_members_table[i] TSRMLS_CC);
+            }
+        }
+    }
+#endif
     fixup_hash(base, &from->function_table,(fixup_bucket_t) fixup_op_array TSRMLS_CC);
+#ifdef INCLUDE_DOC_COMMENTS
+    FIXUP(base, from->doc_comment);
+#endif
 }
 
 void eaccelerator_fixup(ea_cache_entry *p TSRMLS_DC)
@@ -277,11 +345,11 @@
     memcpy(p, from, sizeof(zval));
     restore_zval(p TSRMLS_CC);
     /* hrak: reset refcount to make sure there is one reference to this val, and prevent memleaks */
-#ifdef ZEND_ENGINE_2_3
-    Z_SET_REFCOUNT_P(p, 1);
-#else
-    p->refcount = 1;
-#endif
+    /*#ifdef ZEND_ENGINE_2_3
+        Z_SET_REFCOUNT_P(p, 1);
+    #else
+        p->refcount = 1;
+    #endif*/
     return p;
 }
 
@@ -300,6 +368,7 @@
     memset(target->arBuckets, 0, target->nTableSize * sizeof(Bucket *));
     target->pDestructor = NULL;
     target->persistent = 0;
+    target->pInternalPointer = NULL;
     target->pListHead = NULL;
     target->pListTail = NULL;
 #if HARDENING_PATCH_HASH_PROTECT
@@ -310,9 +379,35 @@
     prev_p = NULL;
     np = NULL;
     while (p) {
+#ifdef ZEND_ENGINE_2_4
+//        if (IS_INTERNED(p->arKey)) {
+        /* TODO */
+//            DBG(ea_debug_printf, (EA_DEBUG, "[%d] restore_hash: restoring interned arKey '%s'\n", getpid(), p->arKey));
+//            np = (Bucket *) emalloc(sizeof(Bucket));
+//            memcpy(np, p, sizeof(Bucket));
+//        } else if (!p->nKeyLength) {
+//            DBG(ea_debug_printf, (EA_DEBUG, "[%d] restore_hash: restoring zero length arKey '%s'\n", getpid(), p->arKey));
+//            np = (Bucket *) emalloc(sizeof(Bucket));
+//           memcpy(np, p, sizeof(Bucket));
+//        } else {
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] restore_hash: restoring regular arKey '%s'\n", getpid(), p->arKey));
+
+        if (IS_INTERNED(p->arKey) || !p->nKeyLength) {
+            np = (Bucket *) emalloc(sizeof(Bucket));
+            memcpy(np, p, sizeof(Bucket));
+        } else {
+            np = (Bucket *) emalloc(sizeof(Bucket) + p->nKeyLength);
+            memcpy(np, p, sizeof(Bucket));
+            np->arKey = (char*)(np + 1);
+            memcpy((char*)np->arKey, p->arKey, p->nKeyLength);
+        }
+//        }
+#else
         np = (Bucket *) emalloc(offsetof(Bucket, arKey) + p->nKeyLength);
-        /*    np = (Bucket *) emalloc(sizeof(Bucket) + p->nKeyLength); */
-        nIndex = p->h % source->nTableSize;
+        memcpy(np, p, offsetof(Bucket, arKey) + p->nKeyLength);
+#endif
+
+        nIndex = p->h % target->nTableSize;
         if (target->arBuckets[nIndex]) {
             np->pNext = target->arBuckets[nIndex];
             np->pLast = NULL;
@@ -322,8 +417,6 @@
             np->pLast = NULL;
         }
         target->arBuckets[nIndex] = np;
-        np->h = p->h;
-        np->nKeyLength = p->nKeyLength;
 
         if (p->pDataPtr == NULL) {
             np->pData = copy_bucket(p->pData TSRMLS_CC);
@@ -332,11 +425,10 @@
             np->pDataPtr = copy_bucket(p->pDataPtr TSRMLS_CC);
             np->pData = &np->pDataPtr;
         }
+
         np->pListLast = prev_p;
         np->pListNext = NULL;
 
-        memcpy(np->arKey, p->arKey, p->nKeyLength);
-
         if (prev_p) {
             prev_p->pListNext = np;
         } else {
@@ -346,7 +438,7 @@
         p = p->pListNext;
     }
     target->pListTail = np;
-    target->pInternalPointer = target->pListHead;
+    zend_hash_internal_pointer_reset(target);
     return target;
 }
 
@@ -356,7 +448,7 @@
     case IS_CONSTANT:
     case IS_OBJECT:
     case IS_STRING:
-        if (Z_STRVAL_P(zv) == NULL || Z_STRVAL_P(zv) == "" || Z_STRLEN_P(zv) == 0) {
+        if (Z_STRVAL_P(zv) == NULL || Z_STRLEN_P(zv) == 0) {
             Z_STRLEN_P(zv) = 0;
             Z_STRVAL_P(zv) = empty_string;
             return;
@@ -396,7 +488,7 @@
 
     DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
     DBG(ea_debug_printf, (EA_DEBUG, "[%d] restore_op_array: %s type=%x\n", getpid(),
-                    from->function_name ? from->function_name : "(top)", from->type));
+                          from->function_name ? from->function_name : "(top)", from->type));
 
     if (from->type == ZEND_INTERNAL_FUNCTION) {
         if (to == NULL) {
@@ -409,15 +501,17 @@
         }
         memset(to, 0, sizeof(zend_op_array));
         if (ZendOptimizer) {
-            zend_llist_apply_with_argument(&zend_extensions, 
-                    (llist_apply_with_arg_func_t) call_op_array_ctor_handler, to TSRMLS_CC);
+            zend_llist_apply_with_argument(&zend_extensions,
+                                           (llist_apply_with_arg_func_t) call_op_array_ctor_handler, to TSRMLS_CC);
         }
     }
     to->type = from->type;
     to->num_args = from->num_args;
     to->required_num_args = from->required_num_args;
     to->arg_info = from->arg_info;
+#ifndef ZEND_ENGINE_2_4
     to->pass_rest_by_reference = from->pass_rest_by_reference;
+#endif
     to->function_name = from->function_name;
 
     if (to->function_name) {
@@ -427,6 +521,12 @@
 
     to->fn_flags = from->fn_flags;
 
+#ifdef ZEND_ENGINE_2_4
+    to->literals = from->literals;
+    to->last_literal = from->last_literal;
+    to->last_cache_slot = from->last_cache_slot;
+#endif
+
     /* segv74:
      * to->scope = EAG(class_entry)
      *
@@ -438,12 +538,12 @@
      *
      *
      * if  from->scope_name != NULL,
-     *     ; we are in class member function 
+     *     ; we are in class member function
      *
      *     ; we have to find appropriate (zend_class_entry*) to->scope for name from->scope_name
      *     ; if we find in CG(class_table), link to it.
      *     ; if fail, it should be EAG(class_entry)
-     *    
+     *
      * am I right here ? ;-(
      */
     if (from->scope_name != NULL) {
@@ -457,7 +557,7 @@
                 to->scope != NULL) {
             DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
             DBG(ea_debug_printf, (EA_DEBUG, "[%d]                   found '%s' in hash\n", getpid(), from->scope_name));
-            DBG(ea_debug_printf, (EA_DEBUG, "name=%s :: to->scope is 0x%x", to->function_name, (unsigned int) to->scope));
+            DBG(ea_debug_printf, (EA_DEBUG, "name=%s :: to->scope is 0x%x", to->function_name, to->scope));
             to->scope = *(zend_class_entry **) to->scope;
         } else {
             DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
@@ -475,8 +575,8 @@
                 DBG(ea_debug_printf, (EA_DEBUG, "[%d]                   checking parent '%s' have '%s'\n", getpid(), p->name, fname_lc));
                 if (zend_hash_find(&p->function_table, fname_lc, fname_len + 1, &function.ptr) == SUCCESS) {
                     DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-                    DBG(ea_debug_printf, (EA_DEBUG, "[%d]                                   '%s' has '%s' of scope '%s'\n", 
-                            getpid(), p->name, fname_lc, function.v->common.scope->name));
+                    DBG(ea_debug_printf, (EA_DEBUG, "[%d]                                   '%s' has '%s' of scope '%s'\n",
+                                          getpid(), p->name, fname_lc, function.v->common.scope->name));
                     to->scope = function.v->common.scope;
                     break;
                 }
@@ -487,22 +587,22 @@
     }
 
     DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-    DBG(ea_debug_printf, (EA_DEBUG, "[%d]                   %s's scope is '%s'\n", getpid(), 
-            from->function_name ? from->function_name : "(top)", to->scope ? to->scope->name : "NULL"));
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d]                   %s's scope is '%s'\n", getpid(),
+                          from->function_name ? from->function_name : "(top)", to->scope ? to->scope->name : "NULL"));
     if (from->type == ZEND_INTERNAL_FUNCTION) {
         zend_class_entry *class_entry = EAG(class_entry);
         DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-        DBG(ea_debug_printf, (EA_DEBUG, "[%d]                   [internal function from=%08x,to=%08x] class_entry='%s' [%08x]\n", 
-                getpid(), from, to, class_entry->name, class_entry));
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d]                   [internal function from=%08x,to=%08x] class_entry='%s' [%08x]\n",
+                              getpid(), from, to, class_entry->name, class_entry));
         if (class_entry) {
             DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-            DBG(ea_debug_printf, (EA_DEBUG, "[%d]                                       class_entry->parent='%s' [%08x]\n", 
-                    getpid(), class_entry->parent->name, class_entry->parent));
+            DBG(ea_debug_printf, (EA_DEBUG, "[%d]                                       class_entry->parent='%s' [%08x]\n",
+                                  getpid(), class_entry->parent->name, class_entry->parent));
         }
-        if (class_entry != NULL && class_entry->parent != NULL && 
+        if (class_entry != NULL && class_entry->parent != NULL &&
                 zend_hash_find(&class_entry->parent->function_table,
-                fname_lc, fname_len + 1,
-                &function.ptr) == SUCCESS && function.v->type == ZEND_INTERNAL_FUNCTION) {
+                               fname_lc, fname_len + 1,
+                               &function.ptr) == SUCCESS && function.v->type == ZEND_INTERNAL_FUNCTION) {
             DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
             DBG(ea_debug_printf, (EA_DEBUG, "[%d]                                       found in function table\n", getpid()));
             ((zend_internal_function *) (to))->handler = ((zend_internal_function *) function.v)->handler;
@@ -512,13 +612,15 @@
              */
             DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
             DBG(ea_debug_printf, (EA_DEBUG, "[%d]                                       can't find\n", getpid()));
-        }       
+        }
         /* hrak: slight memleak here. dont forget to free the lowercase function name! */
         if (fname_lc != NULL) {
             efree(fname_lc);
         }
+#ifndef ZEND_ENGINE_2_4
         /* zend_internal_function also contains return_reference in ZE2 */
         to->return_reference = from->return_reference;
+#endif
         /* this gets set by zend_do_inheritance */
         to->prototype = NULL;
         return to;
@@ -528,17 +630,26 @@
         efree(fname_lc);
     }
     to->opcodes = from->opcodes;
+
+#ifdef ZEND_ENGINE_2_4
+    to->last = from->last;
+#else
     to->last = to->size = from->last;
+#endif
     to->T = from->T;
     to->brk_cont_array = from->brk_cont_array;
     to->last_brk_cont = from->last_brk_cont;
 
+#ifndef ZEND_ENGINE_2_4
     to->current_brk_cont = -1;
+#endif
     to->static_variables = from->static_variables;
+#ifndef ZEND_ENGINE_2_4
     to->backpatch_count  = 0;
 
     to->return_reference = from->return_reference;
     to->done_pass_two = 1;
+#endif
     to->filename = from->filename;
 
     to->try_catch_array = from->try_catch_array;
@@ -566,7 +677,9 @@
 
     to->vars             = from->vars;
     to->last_var         = from->last_var;
+#ifndef ZEND_ENGINE_2_4
     to->size_var         = 0;
+#endif
 
     /* disable deletion in destroy_op_array */
     ++EAG(refcount_helper);
@@ -581,16 +694,16 @@
 }
 
 static zend_property_info *restore_property_info(zend_property_info *
-                                                 from TSRMLS_DC)
+        from TSRMLS_DC)
 {
     zend_property_info *to = emalloc(sizeof(zend_property_info));
     memcpy(to, from, sizeof(zend_property_info));
     to->name = emalloc(from->name_length + 1);
-    memcpy(to->name, from->name, from->name_length + 1);
+    memcpy((char*)to->name, from->name, from->name_length + 1);
 #ifdef INCLUDE_DOC_COMMENTS
     if (from->doc_comment != NULL) {
         to->doc_comment = emalloc(from->doc_comment_len + 1);
-        memcpy(to->doc_comment, from->doc_comment, from->doc_comment_len + 1);
+        memcpy((char*)to->doc_comment, from->doc_comment, from->doc_comment_len + 1);
     }
 #endif
 #ifdef ZEND_ENGINE_2_2
@@ -603,15 +716,20 @@
 static void restore_class_parent(char *parent, int len, zend_class_entry * to TSRMLS_DC)
 {
     zend_class_entry** parent_ptr = NULL;
-    if (zend_lookup_class(parent, len, &parent_ptr TSRMLS_CC) != SUCCESS)
-    {
-        ea_debug_error("[%d] EACCELERATOR can't restore parent class \"%s\" of class \"%s\"\n", getpid(), (char *) parent, to->name);
-        to->parent = NULL;
-    } else {
+    if (zend_lookup_class_ex(parent,
+                                len,
+#ifdef ZEND_ENGINE_2_4
+                                NULL,
+#endif
+                                0,
+                                &parent_ptr TSRMLS_CC) == SUCCESS) {
         /* parent found */
         to->parent = *parent_ptr;
-        DBG(ea_debug_printf, (EA_DEBUG, "restore_class_parent: found parent %s..\n", to->parent->name));
-        DBG(ea_debug_printf, (EA_DEBUG, "restore_class_parent: parent type=%d child type=%d\n", to->parent->type, to->type));
+        DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] restore_class_parent: found parent %s..\n", getpid(), to->parent->name));
+    } else {
+        ea_debug_error("[%d] EACCELERATOR can't restore parent class \"%s\" of class \"%s\"\n", getpid(), (char *) parent, to->name);
+        to->parent = NULL;
     }
 }
 
@@ -630,45 +748,48 @@
         f = p->pData;
         fname_len = strlen(f->common.function_name);
         fname_lc = zend_str_tolower_dup(f->common.function_name, fname_len);
-        
+
         /* only put the function that has the same name as the class as contructor if there isn't a __construct function */
         if (fname_len == cname_len && !memcmp(fname_lc, cname_lc, fname_len) && f->common.scope != to->parent
                 && to->constructor == NULL) {
             to->constructor = f;
         } else if (fname_lc[0] == '_' && fname_lc[1] == '_' && f->common.scope != to->parent) {
-            if (fname_len == sizeof(ZEND_CONSTRUCTOR_FUNC_NAME) - 1 && 
-                    memcmp(fname_lc, ZEND_CONSTRUCTOR_FUNC_NAME, sizeof(ZEND_CONSTRUCTOR_FUNC_NAME)) == 0)
+            if (fname_len == sizeof(ZEND_CONSTRUCTOR_FUNC_NAME) - 1 &&
+                    memcmp(fname_lc, ZEND_CONSTRUCTOR_FUNC_NAME, sizeof(ZEND_CONSTRUCTOR_FUNC_NAME)) == 0) {
                 to->constructor = f;
-            else if (fname_len == sizeof(ZEND_DESTRUCTOR_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_DESTRUCTOR_FUNC_NAME, sizeof(ZEND_DESTRUCTOR_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_DESTRUCTOR_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_DESTRUCTOR_FUNC_NAME, sizeof(ZEND_DESTRUCTOR_FUNC_NAME)) == 0) {
                 to->destructor = f;
-            else if (fname_len == sizeof(ZEND_CLONE_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_CLONE_FUNC_NAME, sizeof(ZEND_CLONE_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_CLONE_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_CLONE_FUNC_NAME, sizeof(ZEND_CLONE_FUNC_NAME)) == 0) {
                 to->clone = f;
-            else if (fname_len == sizeof(ZEND_GET_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_GET_FUNC_NAME, sizeof(ZEND_GET_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_GET_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_GET_FUNC_NAME, sizeof(ZEND_GET_FUNC_NAME)) == 0) {
                 to->__get = f;
-            else if (fname_len == sizeof(ZEND_SET_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_SET_FUNC_NAME, sizeof(ZEND_SET_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_SET_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_SET_FUNC_NAME, sizeof(ZEND_SET_FUNC_NAME)) == 0) {
                 to->__set = f;
-            else if (fname_len == sizeof(ZEND_UNSET_FUNC_NAME) - 1 &&
-                    memcmp(fname_lc, ZEND_UNSET_FUNC_NAME, sizeof(ZEND_UNSET_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_UNSET_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_UNSET_FUNC_NAME, sizeof(ZEND_UNSET_FUNC_NAME)) == 0) {
                 to->__unset = f;
-            else if (fname_len == sizeof(ZEND_ISSET_FUNC_NAME) - 1 &&
-                    memcmp(fname_lc, ZEND_ISSET_FUNC_NAME, sizeof(ZEND_ISSET_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_ISSET_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_ISSET_FUNC_NAME, sizeof(ZEND_ISSET_FUNC_NAME)) == 0) {
                 to->__isset = f;
-            else if (fname_len == sizeof(ZEND_CALL_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_CALL_FUNC_NAME, sizeof(ZEND_CALL_FUNC_NAME)) == 0)
+            } else if (fname_len == sizeof(ZEND_CALL_FUNC_NAME) - 1 &&
+                       memcmp(fname_lc, ZEND_CALL_FUNC_NAME, sizeof(ZEND_CALL_FUNC_NAME)) == 0) {
                 to->__call = f;
+            }
 #  ifdef ZEND_ENGINE_2_3
             else if (fname_len == sizeof(ZEND_CALLSTATIC_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_CALLSTATIC_FUNC_NAME, sizeof(ZEND_CALLSTATIC_FUNC_NAME)) == 0)
+                     memcmp(fname_lc, ZEND_CALLSTATIC_FUNC_NAME, sizeof(ZEND_CALLSTATIC_FUNC_NAME)) == 0) {
                 to->__callstatic = f;
+            }
 #  endif
 #  ifdef ZEND_ENGINE_2_2
             else if (fname_len == sizeof(ZEND_TOSTRING_FUNC_NAME) - 1 &&
-                     memcmp(fname_lc, ZEND_TOSTRING_FUNC_NAME, sizeof(ZEND_TOSTRING_FUNC_NAME)) == 0)
+                     memcmp(fname_lc, ZEND_TOSTRING_FUNC_NAME, sizeof(ZEND_TOSTRING_FUNC_NAME)) == 0) {
                 to->__tostring = f;
+            }
 #  endif
         }
         if (to->parent) {
@@ -686,6 +807,9 @@
 static zend_class_entry *restore_class_entry(zend_class_entry * to, ea_class_entry * from TSRMLS_DC)
 {
     zend_class_entry *old;
+#ifdef ZEND_ENGINE_2_4
+    int i;
+#endif
 
     DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
     DBG(ea_debug_printf, (EA_DEBUG, "[%d] restore_class_entry: %s\n", getpid(), from->name ? from->name : "(top)"));
@@ -701,7 +825,7 @@
     if (from->name != NULL) {
         to->name_length = from->name_length;
         to->name = emalloc(from->name_length + 1);
-        memcpy(to->name, from->name, from->name_length + 1);
+        memcpy((char*)to->name, from->name, from->name_length + 1);
     }
 
     old = EAG(class_entry);
@@ -711,35 +835,87 @@
     to->num_interfaces = from->num_interfaces;
     to->interfaces = NULL;
     to->refcount = 1;
+#ifdef ZEND_ENGINE_2_4
+    to->info.user.line_start = from->line_start;
+    to->info.user.line_end = from->line_end;
+#else
     to->line_start = from->line_start;
     to->line_end = from->line_end;
-    
+#endif
+
     if (to->num_interfaces > 0) {
         /* hrak: Allocate the slots which will later be populated by ZEND_ADD_INTERFACE */
         to->interfaces = (zend_class_entry **) emalloc(sizeof(zend_class_entry *) * to->num_interfaces);
         memset(to->interfaces, 0, sizeof(zend_class_entry *) * to->num_interfaces);
     }
 #ifdef INCLUDE_DOC_COMMENTS
+#  ifdef ZEND_ENGINE_2_4
+    to->info.user.doc_comment_len = from->doc_comment_len;
+    if (from->doc_comment != NULL) {
+        to->info.user.doc_comment = emalloc(from->doc_comment_len + 1);
+        memcpy((char*)to->info.user.doc_comment, from->doc_comment, from->doc_comment_len + 1);
+    }
+#  else
     to->doc_comment_len = from->doc_comment_len;
     if (from->doc_comment != NULL) {
         to->doc_comment = emalloc(from->doc_comment_len + 1);
         memcpy(to->doc_comment, from->doc_comment, from->doc_comment_len + 1);
     }
+#  endif
 #else
+#  ifdef ZEND_ENGINE_2_4
+    to->info.user.doc_comment_len = 0;
+    to->info.user.doc_comment = NULL;
+#  else
     to->doc_comment_len = 0;
     to->doc_comment = NULL;
+#  endif
 #endif
 
+#ifdef ZEND_ENGINE_2_4
+    to->info.user.filename = from->filename;
+#else
     to->filename = from->filename;
+#endif
 
     /* restore constants table */
     restore_zval_hash(&to->constants_table, &from->constants_table);
     to->constants_table.pDestructor = ZVAL_PTR_DTOR;
-    
+
     /* restore properties */
     restore_hash(&to->properties_info, &from->properties_info, (restore_bucket_t) restore_property_info TSRMLS_CC);
     to->properties_info.pDestructor = properties_info_dtor;
 
+#ifdef ZEND_ENGINE_2_4
+    to->default_properties_count = from->default_properties_count;
+    if (from->default_properties_count) {
+        to->default_properties_table = (zval **) emalloc((sizeof(zval*) * from->default_properties_count));
+        for (i = 0; i < from->default_properties_count; i++) {
+            if (from->default_properties_table[i]) {
+                to->default_properties_table[i] = restore_zval_ptr((zval*)from->default_properties_table[i] TSRMLS_CC);
+            } else {
+                to->default_properties_table[i] = NULL;
+            }
+        }
+    } else {
+        to->default_properties_table = NULL;
+    }
+
+    to->default_static_members_count = from->default_static_members_count;
+    if (from->default_static_members_count > 0) {
+        to->default_static_members_table = (zval **) emalloc((sizeof(zval*) * from->default_static_members_count));
+        for (i = 0; i < from->default_static_members_count; i++) {
+            if (from->default_static_members_table[i]) {
+                to->default_static_members_table[i] = restore_zval_ptr((zval*)from->default_static_members_table[i] TSRMLS_CC);
+            } else {
+                to->default_static_members_table[i] = NULL;
+            }
+        }
+    } else {
+        to->default_static_members_table = NULL;
+    }
+    to->static_members_table = to->default_static_members_table;
+#else
     /* restore default properties */
     restore_zval_hash(&to->default_properties, &from->default_properties);
     to->default_properties.pDestructor = ZVAL_PTR_DTOR;
@@ -747,7 +923,7 @@
     /* restore default_static_members */
     restore_zval_hash(&to->default_static_members, &from->default_static_members);
     to->default_static_members.pDestructor = ZVAL_PTR_DTOR;
-    
+
     if (from->static_members != &(from->default_static_members)) {
         ALLOC_HASHTABLE(to->static_members);
         restore_zval_hash(to->static_members, from->static_members);
@@ -755,6 +931,7 @@
     } else {
         to->static_members = &(to->default_static_members);
     }
+#endif
 
     if (from->parent != NULL) {
         restore_class_parent(from->parent, strlen(from->parent), to TSRMLS_CC);
@@ -784,8 +961,10 @@
 {
     zend_op_array op_array;
 
-    if ((p->htabkey[0] == '\000') && zend_hash_exists(CG(function_table), p->htabkey, p->htablen)) {
-        return;
+    if (p->htabkey[0] == '\0' && p->htablen != 0) {
+        if (zend_hash_exists(CG(function_table), p->htabkey, p->htablen)) {
+            return;
+        }
     }
     if (restore_op_array(&op_array, (ea_op_array *) p->fc TSRMLS_CC) != NULL) {
         if (zend_hash_add(CG(function_table), p->htabkey, p->htablen, &op_array, sizeof(zend_op_array), NULL) == FAILURE) {
@@ -804,20 +983,33 @@
 {
     zend_class_entry *ce;
 
-    if ((p->htabkey[0] == '\000') && zend_hash_exists(CG(class_table), p->htabkey, p->htablen)) {
-        return;
+    if (p->htabkey[0] == '\0' && p->htablen != 0) {
+        if (zend_hash_exists(CG(class_table), p->htabkey, p->htablen)) {
+            return;
+        }
     }
     ce = restore_class_entry(NULL, (ea_class_entry *) p->fc TSRMLS_CC);
-    if (ce != NULL)
-    {
-        if (zend_hash_add(CG(class_table), p->htabkey, p->htablen, &ce, sizeof(zend_class_entry *), NULL) == FAILURE)
-        {
+    if (ce != NULL) {
+        if (zend_hash_add(CG(class_table), p->htabkey, p->htablen, &ce, sizeof(zend_class_entry *), NULL) == FAILURE) {
             CG(in_compilation) = 1;
             CG(compiled_filename) = EAG(mem);
+#ifdef ZEND_ENGINE_2_4
+            CG(zend_lineno) = ce->info.user.line_start;
+#else
             CG(zend_lineno) = ce->line_start;
+#endif
             zend_error(E_ERROR, "Cannot redeclare class %s", p->htabkey);
         }
     }
 }
 
 #endif /* HAVE_EACCELERATOR */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/ea_restore.h patched/ea_restore.h
--- orig/ea_restore.h	2010-01-19 16:49:13.000000000 +0100
+++ patched/ea_restore.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -40,3 +40,12 @@
 dtor_func_t get_zend_destroy_property_info(TSRMLS_D);
 
 #endif /* EA_RESTORE_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/ea_store.c patched/ea_store.c
--- orig/ea_store.c	2010-02-25 11:56:33.000000000 +0100
+++ patched/ea_store.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id: ea_store.c 412 2010-02-25 10:56:33Z hans $
+   $Id: ea_store.c 418 2010-06-03 11:13:47Z hans $
 */
 
 #include "eaccelerator.h"
@@ -52,8 +52,7 @@
 static size_t calc_string(char *str, int len TSRMLS_DC)
 #endif
 {
-    if (len > MAX_DUP_STR_LEN || 
-            zend_hash_add(&EAG(strings), str, len, &str, sizeof(char *), NULL) == SUCCESS) {
+    if (len > MAX_DUP_STR_LEN || zend_hash_add(&EAG(strings), str, len, (void *) &str, sizeof(char *), NULL) == SUCCESS) {
         EA_SIZE_ALIGN(len);
         return len;
     }
@@ -92,16 +91,16 @@
 
     size += calc_string(from->name, from->name_length + 1 TSRMLS_CC);
 #ifdef INCLUDE_DOC_COMMENTS
-     if (from->doc_comment != NULL) {
+    if (from->doc_comment != NULL) {
         size += calc_string(from->doc_comment, from->doc_comment_len + 1 TSRMLS_CC);
-     }
+    }
 #endif
-     return size;
+    return size;
 }
 
 /* Calculate the size of an HashTable */
 static size_t calc_hash_int(HashTable * source, Bucket * start,
-                          calc_bucket_t calc_bucket TSRMLS_DC)
+                            calc_bucket_t calc_bucket TSRMLS_DC)
 {
     Bucket *p;
     size_t size = 0;
@@ -110,7 +109,14 @@
         ADDSIZE(size, source->nTableSize * sizeof(Bucket *));
         p = start;
         while (p) {
+#ifdef ZEND_ENGINE_2_4
+//            if (!IS_INTERNED(p->arKey) && p->nKeyLength) {
+            ADDSIZE(size, sizeof(Bucket));
+            ADDSIZE(size, p->nKeyLength);
+//            }
+#else
             ADDSIZE(size, offsetof(Bucket, arKey) + p->nKeyLength);
+#endif
             size += calc_bucket(p->pData TSRMLS_CC);
             p = p->pListNext;
         }
@@ -123,26 +129,26 @@
     size_t size = 0;
 
     switch (EA_ZV_TYPE_P(zv)) {
-        case IS_CONSTANT:
-        case IS_OBJECT: /* object should have been serialized before storing them */
-        case IS_STRING:
-            size += calc_string(Z_STRVAL_P(zv), Z_STRLEN_P(zv) + 1 TSRMLS_CC);
-            break;
-
-        case IS_ARRAY:
-        case IS_CONSTANT_ARRAY:
-            if (Z_ARRVAL_P(zv) != NULL && Z_ARRVAL_P(zv) != &EG(symbol_table)) {
-                ADDSIZE(size, sizeof(HashTable));
-                size += calc_zval_hash(Z_ARRVAL_P(zv));
-            }
-            break;
+    case IS_CONSTANT:
+    case IS_OBJECT: /* object should have been serialized before storing them */
+    case IS_STRING:
+        size += calc_string(Z_STRVAL_P(zv), Z_STRLEN_P(zv) + 1 TSRMLS_CC);
+        break;
+
+    case IS_ARRAY:
+    case IS_CONSTANT_ARRAY:
+        if (Z_ARRVAL_P(zv) != NULL && Z_ARRVAL_P(zv) != &EG(symbol_table)) {
+            ADDSIZE(size, sizeof(HashTable));
+            size += calc_zval_hash(Z_ARRVAL_P(zv));
+        }
+        break;
 
-        case IS_RESOURCE:
-            DBG(ea_debug_error, ("[%d] EACCELERATOR can't cache resources\n", getpid()));
-            zend_bailout();
-            break;
-        default:
-            break;
+    case IS_RESOURCE:
+        DBG(ea_debug_error, ("[%d] EACCELERATOR can't cache resources\n", getpid()));
+        zend_bailout();
+        break;
+    default:
+        break;
     }
     return size;
 }
@@ -150,8 +156,6 @@
 /* Calculate the size of an op_array */
 static size_t calc_op_array(zend_op_array * from TSRMLS_DC)
 {
-    zend_op *opline;
-    zend_op *end;
     size_t size = 0;
 
     if (from->type == ZEND_INTERNAL_FUNCTION) {
@@ -164,6 +168,7 @@
     }
     if (from->num_args > 0) {
         zend_uint i;
+
         ADDSIZE(size, from->num_args * sizeof(zend_arg_info));
         for (i = 0; i < from->num_args; i++) {
             if (from->arg_info[i].name) {
@@ -180,6 +185,7 @@
     if (from->scope != NULL) {
         // HOESH: the same problem?
         Bucket *q = CG(class_table)->pListHead;
+
         while (q != NULL) {
             if (*(zend_class_entry **) q->pData == from->scope) {
                 size += calc_string(q->arKey, q->nKeyLength TSRMLS_CC);
@@ -195,6 +201,9 @@
     if (from->opcodes != NULL) {
         ADDSIZE(size, from->last * sizeof(zend_op));
 
+#ifndef ZEND_ENGINE_2_4
+        zend_op *opline, *end;
+
         opline = from->opcodes;
         end = opline + from->last;
         for (; opline < end; opline++) {
@@ -205,7 +214,21 @@
                 size += calc_zval(&opline->op2.u.constant TSRMLS_CC);
             }
         }
+#endif
     }
+#ifdef ZEND_ENGINE_2_4
+    if (from->literals != NULL) {
+        zend_literal *l, *end;
+
+        ADDSIZE(size, sizeof(zend_literal) * from->last_literal);
+
+        l = from->literals;
+        end = l + from->last_literal;
+        for (; l < end; l++) {
+            size += calc_zval(&l->constant TSRMLS_CC);
+        }
+    }
+#endif
     if (from->brk_cont_array != NULL) {
         ADDSIZE(size, sizeof(zend_brk_cont_element) * from->last_brk_cont);
     }
@@ -218,6 +241,7 @@
     }
     if (from->vars != NULL) {
         int i;
+
         ADDSIZE(size, sizeof(zend_compiled_variable) * from->last_var);
         for (i = 0; i < from->last_var; i ++) {
             size += calc_string(from->vars[i].name, from->vars[i].name_len+1 TSRMLS_CC);
@@ -251,24 +275,58 @@
     if (from->parent != NULL && from->parent->name) {
         size += calc_string(from->parent->name, from->parent->name_length + 1 TSRMLS_CC);
     }
+#ifdef ZEND_ENGINE_2_4
+    if (from->info.user.filename != NULL) {
+        size += calc_string(from->info.user.filename, strlen(from->info.user.filename) + 1 TSRMLS_CC);
+    }
+#  ifdef INCLUDE_DOC_COMMENTS
+    if (from->info.user.doc_comment != NULL) {
+        size += calc_string(from->info.user.doc_comment, from->info.user.doc_comment_len + 1 TSRMLS_CC);
+    }
+#  endif
+#else
     if (from->filename != NULL) {
         size += calc_string(from->filename, strlen(from->filename) + 1 TSRMLS_CC);
     }
-#ifdef INCLUDE_DOC_COMMENTS
-     if (from->doc_comment != NULL) {
+#  ifdef INCLUDE_DOC_COMMENTS
+    if (from->doc_comment != NULL) {
         size += calc_string(from->doc_comment, from->doc_comment_len + 1 TSRMLS_CC);
-     }
+    }
+#  endif
 #endif
-    
+
     size += calc_zval_hash(&from->constants_table);
-    size += calc_zval_hash(&from->default_properties);
     size += calc_hash(&from->properties_info, (calc_bucket_t) calc_property_info);
+#ifdef ZEND_ENGINE_2_4
+    if (from->default_properties_count) {
+        int i = 0;
+
+        ADDSIZE(size, sizeof(zval *) * from->default_properties_count);
+        for (i = 0; i < from->default_properties_count; i++) {
+            if (from->default_properties_table[i]) {
+                size += calc_zval_ptr(&from->default_properties_table[i] TSRMLS_CC);
+            }
+        }
+    }
+    if (from->default_static_members_count) {
+        int i = 0;
+
+        ADDSIZE(size, sizeof(zval *) * from->default_static_members_count);
+        for (i = 0; i < from->default_static_members_count; i++) {
+            if (from->default_static_members_table[i]) {
+                size += calc_zval_ptr(&from->default_static_members_table[i] TSRMLS_CC);
+            }
+        }
+    }
+#else
+    size += calc_zval_hash(&from->default_properties);
 
     size += calc_zval_hash(&from->default_static_members);
     if ((from->static_members != NULL) && (from->static_members != &from->default_static_members)) {
         ADDSIZE(size, sizeof(HashTable));
         size += calc_zval_hash(from->static_members);
     }
+#endif
     size += calc_hash(&from->function_table, (calc_bucket_t) calc_op_array);
 
     return size;
@@ -279,7 +337,7 @@
 size_t calc_size(char *key, zend_op_array * op_array, Bucket * f, Bucket * c TSRMLS_DC)
 {
     Bucket *b;
-    char *x;
+    const char *x;
     int len = strlen(key);
     size_t size = 0;
 
@@ -297,7 +355,7 @@
     b = f;
     while (b != NULL) {
         ADDSIZE(size, offsetof(ea_fc_entry, htabkey) + b->nKeyLength);
-    
+
         x = b->arKey;
         zend_hash_add(&EAG(strings), b->arKey, b->nKeyLength, &x, sizeof(char *), NULL);
         b = b->pListNext;
@@ -322,17 +380,21 @@
     (*at) += (len); \
     EACCELERATOR_ALIGN((*at));
 
-#ifdef ZEND_ENGINE_2_3
+/* ugh, dirty */
+#ifdef ZEND_ENGINE_2_4
+static inline const char *store_string(char **at, const char *str, int len TSRMLS_DC)
+#elif  defined(ZEND_ENGINE_2_3)
 static inline char *store_string(char **at, const char *str, int len TSRMLS_DC)
 #else
 static inline char *store_string(char **at, char *str, int len TSRMLS_DC)
 #endif
 {
     char *p;
+
     if (len > MAX_DUP_STR_LEN) {
         p = ALLOCATE(at, len);
         memcpy(p, str, len);
-    } else if (zend_hash_find(&EAG(strings), str, len, (void *) &p) == SUCCESS) {
+    } else if (zend_hash_find(&EAG(strings), str, len , (void *) &p) == SUCCESS) {
         p = *(char **) p;
     } else {
         p = ALLOCATE(at, len);
@@ -366,16 +428,19 @@
     return to;
 }
 
-static void store_hash_int(char **at, HashTable *target, HashTable *source, 
+static void store_hash_int(char **at, HashTable *target, HashTable *source,
                            Bucket *start, store_bucket_t copy_bucket,
-                                   check_bucket_t check_bucket,
-                                   zend_class_entry *from_ce)
+                           check_bucket_t check_bucket,
+                           zend_class_entry *from_ce)
 {
     Bucket *p, *np, *prev_p;
     int nIndex;
 
     TSRMLS_FETCH();
 
+    assert(target != NULL);
+    assert(source != NULL);
+
     memcpy(target, source, sizeof(HashTable));
 
     if (source->nNumOfElements > 0) {
@@ -384,6 +449,7 @@
 
         target->pDestructor = NULL;
         target->persistent = 1;
+        target->pInternalPointer = NULL;
         target->pListHead = NULL;
         target->pListTail = NULL;
 
@@ -402,9 +468,29 @@
                 }
             }
 
+#ifdef ZEND_ENGINE_2_4
+//            if (IS_INTERNED(p->arKey)) {
+            /* TODO */
+//                DBG(ea_debug_printf, (EA_DEBUG, "[%d] store_hash_int: storing interned arKey '%s'\n", getpid(), p->arKey));
+//                np = (Bucket *)ALLOCATE(at, sizeof(Bucket));
+//                memcpy(np, p, sizeof(Bucket));
+//            } else if (!p->nKeyLength) {
+//                DBG(ea_debug_printf, (EA_DEBUG, "[%d] store_hash_int: storing zero length arKey '%s'\n", getpid(), p->arKey));
+//                np = (Bucket *)ALLOCATE(at, sizeof(Bucket));
+//                memcpy(np, p, sizeof(Bucket));
+//            } else {
+            DBG(ea_debug_printf, (EA_DEBUG, "[%d] store_hash_int: storing regular arKey '%s'\n", getpid(), p->arKey));
+            np = (Bucket *)ALLOCATE(at, sizeof(Bucket));
+            memcpy(np, p, sizeof(Bucket));
+            np->arKey = (char *)ALLOCATE(at, p->nKeyLength);
+            memcpy((char*)np->arKey, p->arKey, p->nKeyLength);
+//            }
+#else
             np = (Bucket *)ALLOCATE(at, offsetof(Bucket, arKey) + p->nKeyLength);
+            memcpy(np, p, offsetof(Bucket, arKey) + p->nKeyLength);
+#endif
 
-            nIndex = p->h % source->nTableSize;
+            nIndex = p->h % target->nTableSize;
             if (target->arBuckets[nIndex]) {
                 np->pNext = target->arBuckets[nIndex];
                 np->pLast = NULL;
@@ -414,8 +500,6 @@
                 np->pLast = NULL;
             }
             target->arBuckets[nIndex] = np;
-            np->h = p->h;
-            np->nKeyLength = p->nKeyLength;
 
             if (p->pDataPtr == NULL) {
                 np->pData = copy_bucket(at, p->pData TSRMLS_CC);
@@ -428,8 +512,6 @@
             np->pListLast = prev_p;
             np->pListNext = NULL;
 
-            memcpy(np->arKey, p->arKey, p->nKeyLength);
-
             if (prev_p) {
                 prev_p->pListNext = np;
             } else {
@@ -439,31 +521,31 @@
             p = p->pListNext;
         }
         target->pListTail = np;
-        target->pInternalPointer = target->pListHead;
+        zend_hash_internal_pointer_reset(target);
     }
 }
 
 void store_zval(char **at, zval *zv TSRMLS_DC)
 {
     switch (EA_ZV_TYPE_P(zv)) {
-        case IS_CONSTANT:
-        case IS_OBJECT: /* object should have been serialized before storing them */
-        case IS_STRING:
-            Z_STRVAL_P(zv) = store_string(at, Z_STRVAL_P(zv), Z_STRLEN_P(zv) + 1 TSRMLS_CC);
-            break;
-
-        case IS_ARRAY:
-        case IS_CONSTANT_ARRAY:
-            if (Z_ARRVAL_P(zv) != NULL && Z_ARRVAL_P(zv) != &EG(symbol_table)) {
-                HashTable *q;
-                q = (HashTable *)ALLOCATE(at, sizeof(HashTable));
-                store_zval_hash(at, q, Z_ARRVAL_P(zv));
-                Z_ARRVAL_P(zv) = q;
-            }
-            break;
+    case IS_CONSTANT:
+    case IS_OBJECT: /* object should have been serialized before storing them */
+    case IS_STRING:
+        Z_STRVAL_P(zv) = (char*)store_string(at, Z_STRVAL_P(zv), Z_STRLEN_P(zv) + 1 TSRMLS_CC);
+        break;
+
+    case IS_ARRAY:
+    case IS_CONSTANT_ARRAY:
+        if (Z_ARRVAL_P(zv) != NULL && Z_ARRVAL_P(zv) != &EG(symbol_table)) {
+            HashTable *q;
+            q = (HashTable *)ALLOCATE(at, sizeof(HashTable));
+            store_zval_hash(at, q, Z_ARRVAL_P(zv));
+            Z_ARRVAL_P(zv) = q;
+        }
+        break;
 
-        default:
-            break;
+    default:
+        break;
     }
 }
 
@@ -471,17 +553,17 @@
 {
     ea_op_array *to;
     zend_op *opline;
-    zend_op *end;
+    zend_uint i;
 
     DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-    DBG(ea_debug_printf, (EA_DEBUG, "[%d] store_op_array: %s [scope=%s type=%x]\n", 
-            getpid(), from->function_name ? from->function_name : "(top)",
-            from->scope ? from->scope->name : "NULL"
-            , from->type
-        ));
+    DBG(ea_debug_printf, (EA_DEBUG, "[%d] store_op_array: %s [scope=%s type=%x]\n",
+                          getpid(), from->function_name ? from->function_name : "(top)",
+                          from->scope ? from->scope->name : "NULL"
+                          , from->type
+                         ));
 
     if (from->type == ZEND_INTERNAL_FUNCTION) {
-        to = (ea_op_array *)ALLOCATE(at, offsetof(ea_op_array, opcodes));
+        to = (ea_op_array *)ALLOCATE(at, sizeof(zend_internal_function));
     } else if (from->type == ZEND_USER_FUNCTION) {
         to = (ea_op_array *)ALLOCATE(at, sizeof(ea_op_array));
     } else {
@@ -491,43 +573,42 @@
     to->type = from->type;
     to->num_args = from->num_args;
     to->required_num_args = from->required_num_args;
+
     if (from->num_args > 0) {
-        zend_uint i;
         to->arg_info = (zend_arg_info *)ALLOCATE(at, from->num_args * sizeof(zend_arg_info));
-
+        memcpy(to->arg_info, from->arg_info, from->num_args * sizeof(zend_arg_info));
+        
         for (i = 0; i < from->num_args; i++) {
             if (from->arg_info[i].name) {
                 to->arg_info[i].name = store_string(at, from->arg_info[i].name, from->arg_info[i].name_len + 1 TSRMLS_CC);
-                to->arg_info[i].name_len = from->arg_info[i].name_len;
             }
             if (from->arg_info[i].class_name) {
                 to->arg_info[i].class_name = store_string(at, from->arg_info[i].class_name, from->arg_info[i].class_name_len + 1 TSRMLS_CC);
-                to->arg_info[i].class_name_len = from->arg_info[i].class_name_len;
             }
-            /* php 5.1 introduces this in zend_arg_info for array type hinting */
-            to->arg_info[i].array_type_hint = from->arg_info[i].array_type_hint;
-            to->arg_info[i].allow_null = from->arg_info[i].allow_null;
-            to->arg_info[i].pass_by_reference = from->arg_info[i].pass_by_reference;
-            to->arg_info[i].return_reference = from->arg_info[i].return_reference;
         }
     }
+
+#ifndef ZEND_ENGINE_2_4
     to->pass_rest_by_reference = from->pass_rest_by_reference;
-    if (from->function_name != NULL)
+#endif
+    if (from->function_name != NULL) {
         to->function_name = store_string(at, from->function_name, strlen(from->function_name) + 1 TSRMLS_CC);
+    }
     to->fn_flags = from->fn_flags;
     to->scope_name = NULL;
     to->scope_name_len = 0;
     if (from->scope != NULL) {
         Bucket *q = CG(class_table)->pListHead;
+
         while (q != NULL) {
             if (*(zend_class_entry **) q->pData == from->scope) {
-                to->scope_name = store_string(at, q->arKey, q->nKeyLength TSRMLS_CC);
+                to->scope_name = (char*)store_string(at, q->arKey, q->nKeyLength TSRMLS_CC);
                 to->scope_name_len = q->nKeyLength - 1;
 
                 DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-                DBG(ea_debug_printf, (EA_DEBUG, 
-                        "[%d]                 find scope '%s' in CG(class_table) save hashkey '%s' [%08x] as to->scope_name\n",
-                        getpid(), from->scope->name ? from->scope->name : "NULL", q->arKey, to->scope_name));
+                DBG(ea_debug_printf, (EA_DEBUG,
+                                      "[%d]                 find scope '%s' in CG(class_table) save hashkey '%s' [%08x] as to->scope_name\n",
+                                      getpid(), from->scope->name ? from->scope->name : "NULL", q->arKey, to->scope_name));
                 break;
             }
             q = q->pListNext;
@@ -535,60 +616,82 @@
         if (to->scope_name == NULL) {
             DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
             DBG(ea_debug_printf, (EA_DEBUG,
-                        "[%d]                 could not find scope '%s' in CG(class_table), saving it to NULL\n",
-                        getpid(), from->scope->name ? from->scope->name : "NULL"));
+                                  "[%d]                 could not find scope '%s' in CG(class_table), saving it to NULL\n",
+                                  getpid(), from->scope->name ? from->scope->name : "NULL"));
         }
     }
 
     if (from->type == ZEND_INTERNAL_FUNCTION) {
+#ifndef ZEND_ENGINE_2_4
         /* zend_internal_function also contains return_reference in ZE2 */
         to->return_reference = from->return_reference;
+#endif
         return to;
     }
-    
-    to->opcodes = from->opcodes;
+
     to->last = from->last;
     to->T = from->T;
-    to->brk_cont_array = from->brk_cont_array;
-    to->last_brk_cont = from->last_brk_cont;
-    to->try_catch_array = from->try_catch_array;
-    to->last_try_catch = from->last_try_catch;
 #ifdef ZEND_ENGINE_2_3
     to->this_var = from->this_var;
     to->early_binding = from->early_binding;
 #else
     to->uses_this = from->uses_this;
 #endif
-    if (from->try_catch_array != NULL) {
-        to->try_catch_array = (zend_try_catch_element *)ALLOCATE(at, sizeof(zend_try_catch_element) * from->last_try_catch);
-        memcpy(to->try_catch_array, from->try_catch_array, sizeof(zend_try_catch_element) * from->last_try_catch);
+
+#ifdef ZEND_ENGINE_2_4
+    if (from->literals != NULL) {
+        zend_literal *p, *q, *end;
+
+        to->literals = (zend_literal *)ALLOCATE(at, sizeof(zend_literal) * from->last_literal);
+        memcpy(to->literals, from->literals, sizeof(zend_literal) * from->last_literal);
+
+        q = from->literals;
+        p = to->literals;
+        end = p + from->last_literal;
+        while (p < end) {
+            *p = *q;
+            store_zval(at, &p->constant TSRMLS_CC);
+            p++;
+            q++;
+        }
     } else {
-        to->last_try_catch = 0;
+        to->literals = NULL;
     }
+    to->last_literal = from->last_literal;
 
-    to->static_variables = from->static_variables;
+    to->last_cache_slot = from->last_cache_slot;
+#endif
+
+#ifndef ZEND_ENGINE_2_4
     to->return_reference = from->return_reference;
+#endif
     to->filename = from->filename;
 
     if (from->opcodes != NULL) {
         to->opcodes = (zend_op *)ALLOCATE(at, from->last * sizeof(zend_op));
         memcpy(to->opcodes, from->opcodes, from->last * sizeof(zend_op));
 
-        opline = to->opcodes;
-        end = opline + to->last;
-        for (; opline < end; opline++) {
+        for (i = 0; i < from->last; i++) {
+            opline = &(to->opcodes[i]);
+
+#ifndef ZEND_ENGINE_2_4
             if (opline->op1.op_type == IS_CONST) {
                 store_zval(at, &opline->op1.u.constant TSRMLS_CC);
             }
             if (opline->op2.op_type == IS_CONST) {
                 store_zval(at, &opline->op2.u.constant TSRMLS_CC);
             }
+#endif
             switch (opline->opcode) {
 #ifdef ZEND_GOTO
             case ZEND_GOTO:
 #endif
             case ZEND_JMP:
+#ifdef ZEND_ENGINE_2_4
+                opline->op1.jmp_addr = to->opcodes + (opline->op1.jmp_addr - from->opcodes);
+#else
                 opline->op1.u.jmp_addr = to->opcodes + (opline->op1.u.jmp_addr - from->opcodes);
+#endif
                 break;
             case ZEND_JMPZ:
             case ZEND_JMPNZ:
@@ -597,36 +700,62 @@
 #ifdef ZEND_JMP_SET
             case ZEND_JMP_SET:
 #endif
+#ifdef ZEND_ENGINE_2_4
+            case ZEND_JMP_SET_VAR:
+                opline->op2.jmp_addr = to->opcodes + (opline->op2.jmp_addr - from->opcodes);
+#else
                 opline->op2.u.jmp_addr = to->opcodes + (opline->op2.u.jmp_addr - from->opcodes);
+#endif
                 break;
             }
+
+#ifdef ZEND_ENGINE_2_4
+            if (opline->op1_type == IS_CONST) {
+                to->opcodes[i].op1.literal = from->opcodes[i].op1.literal - from->literals + to->literals;
+            }
+            if (opline->op2_type == IS_CONST) {
+                to->opcodes[i].op2.literal = from->opcodes[i].op2.literal - from->literals + to->literals;
+            }
+#endif
         }
     }
+
+    to->last_try_catch = from->last_try_catch;
+    if (from->try_catch_array != NULL) {
+        to->try_catch_array = (zend_try_catch_element *)ALLOCATE(at, sizeof(zend_try_catch_element) * from->last_try_catch);
+        memcpy(to->try_catch_array, from->try_catch_array, sizeof(zend_try_catch_element) * from->last_try_catch);
+    }
+
+    to->last_brk_cont = from->last_brk_cont;
     if (from->brk_cont_array != NULL) {
         to->brk_cont_array = (zend_brk_cont_element *)ALLOCATE(at, sizeof(zend_brk_cont_element) * from->last_brk_cont);
         memcpy(to->brk_cont_array, from->brk_cont_array, sizeof(zend_brk_cont_element) * from->last_brk_cont);
-    } else {
-        to->last_brk_cont = 0;
     }
 
     if (from->static_variables != NULL) {
         to->static_variables = (HashTable *)ALLOCATE(at, sizeof(HashTable));
         store_zval_hash(at, to->static_variables, from->static_variables);
+    } else {
+        to->static_variables = NULL;
     }
+
     if (from->vars != NULL) {
-            int i;
-            to->last_var = from->last_var;
-            to->vars = (zend_compiled_variable*)ALLOCATE(at, sizeof(zend_compiled_variable) * from->last_var);
-            memcpy(to->vars, from->vars, sizeof(zend_compiled_variable) * from->last_var);
-            for (i = 0; i < from->last_var; i ++) {
-                to->vars[i].name = store_string(at, from->vars[i].name, from->vars[i].name_len+1 TSRMLS_CC);
+        int i;
+
+        to->last_var = from->last_var;
+        to->vars = (zend_compiled_variable*)ALLOCATE(at, sizeof(zend_compiled_variable) * from->last_var);
+        memcpy(to->vars, from->vars, sizeof(zend_compiled_variable) * from->last_var);
+        for (i = 0; i < from->last_var; i++) {
+            to->vars[i].name = store_string(at, from->vars[i].name, from->vars[i].name_len + 1 TSRMLS_CC);
         }
     } else {
         to->last_var = 0;
-            to->vars = NULL;
+        to->vars = NULL;
     }
+
     to->line_start = from->line_start;
     to->line_end = from->line_end;
+
 #ifdef INCLUDE_DOC_COMMENTS
     to->doc_comment_len = from->doc_comment_len;
     if (from->doc_comment != NULL) {
@@ -637,6 +766,7 @@
     if (from->filename != NULL) {
         to->filename = store_string(at, from->filename, strlen(from->filename) + 1 TSRMLS_CC);
     }
+
     return to;
 }
 
@@ -646,12 +776,17 @@
 
     to = (zend_property_info *)ALLOCATE(at, sizeof(zend_property_info));
 
-    memcpy(to, from, sizeof(zend_property_info));
-    to->name = store_string(at, from->name, from->name_length + 1 TSRMLS_CC);
+    memcpy(to, from, sizeof(*from));
+
+    to->name = NULL;
+
+    if (from->name) {
+        to->name = store_string(at, from->name, from->name_length + 1 TSRMLS_CC);
+    }
 #ifdef INCLUDE_DOC_COMMENTS
-    to->doc_comment_len = from->doc_comment_len; 
-    if (from->doc_comment != NULL) { 
-       to->doc_comment = store_string(at, from->doc_comment, from->doc_comment_len + 1 TSRMLS_CC);
+    to->doc_comment_len = from->doc_comment_len;
+    if (from->doc_comment) {
+        to->doc_comment = store_string(at, from->doc_comment, from->doc_comment_len + 1 TSRMLS_CC);
     }
 #else
     to->doc_comment_len = 0;
@@ -660,37 +795,65 @@
     return to;
 }
 
-/* 
- * The following two functions handle access checking of properties (public/private/protected) 
+/*
+ * The following two functions handle access checking of properties (public/private/protected)
  * and control proper inheritance during copying of the properties_info and (default_)static_members hashes
  *
  * Both functions return ZEND_HASH_APPLY_REMOVE if the property to be copied needs to be skipped, or
  * ZEND_HASH_APPLY_KEEP if the property needs to be copied over into the cache.
- *  
+ *
  * If the property is skipped due to access restrictions, or it needs inheritance of its value from the
  * parent, the restore phase will take care of that.
  *
  * Most of the logic behind all this can be found in zend_compile.c, functions zend_do_inheritance and
  * do_inherit_property_access_check
 */
-static int store_property_access_check(Bucket * p, zend_class_entry * from_ce)
+static int store_property_access_check(Bucket * p, zend_class_entry * from)
 {
-    zend_class_entry *from = from_ce;
     zend_class_entry *parent = from->parent;
     zend_property_info* child_info = (zend_property_info*)p->pData;
-    zend_property_info* parent_info = NULL; 
+    zend_property_info* parent_info = NULL;
 
+#ifdef ZEND_ENGINE_2_2
     return (child_info->ce != from);
+#endif
 
     if (parent && zend_hash_quick_find(&parent->properties_info, p->arKey, p->nKeyLength, p->h, (void **) &parent_info)==SUCCESS) {
-      if(parent_info->flags & ZEND_ACC_PRIVATE) {
-        return ZEND_HASH_APPLY_KEEP;
-      }
-      /* if public/private/protected mask differs: copy, else let zend_do_inheritance handle this */
-      if((parent_info->flags & ZEND_ACC_PPP_MASK) != (child_info->flags & ZEND_ACC_PPP_MASK)) {
-        return ZEND_HASH_APPLY_KEEP;
-      }
-      return ZEND_HASH_APPLY_REMOVE;
+        if(parent_info->flags & ZEND_ACC_PRIVATE) {
+            return ZEND_HASH_APPLY_KEEP;
+        }
+        /* if public/private/protected mask differs: copy, else let zend_do_inheritance handle this */
+        if((parent_info->flags & ZEND_ACC_PPP_MASK) != (child_info->flags & ZEND_ACC_PPP_MASK)) {
+            return ZEND_HASH_APPLY_KEEP;
+        }
+        return ZEND_HASH_APPLY_REMOVE;
+    }
+    return ZEND_HASH_APPLY_KEEP;
+}
+
+#ifndef ZEND_ENGINE_2_4
+
+static int store_default_property_access_check(Bucket * p, zend_class_entry * from)
+{
+    zend_class_entry *parent = from->parent;
+    union {
+        zend_property_info *v;
+        void *ptr;
+    } pinfo;
+    union {
+        zval **v;
+        void *ptr;
+    } pprop, cprop;
+
+    cprop.v = p->pData;
+    pprop.v = NULL;
+    /* Check if this is a parent class. If so, copy unconditionally */
+    if (parent &&
+            zend_hash_quick_find(&parent->default_properties, p->arKey, p->nKeyLength, p->h, &pinfo.ptr)==SUCCESS) {
+
+        if ((pprop.v == cprop.v) && (*pprop.v == *cprop.v)) {
+            return ZEND_HASH_APPLY_REMOVE;
+        }
     }
     return ZEND_HASH_APPLY_KEEP;
 }
@@ -713,15 +876,15 @@
     /* Check if this is a parent class. If so, copy unconditionally */
     if (parent) {
         /* unpack the \0classname\0membername\0 style property name to seperate vars */
-#ifdef ZEND_ENGINE_2_2
-        zend_unmangle_property_name(p->arKey, p->nKeyLength, &cname, &mname);
-#else
+#  ifdef ZEND_ENGINE_2_2
+        zend_unmangle_property_name(p->arKey, p->nKeyLength-1, &cname, &mname);
+#  else
         zend_unmangle_property_name(p->arKey, &cname, &mname);
-#endif
-    
+#  endif
+
         /* lookup the member's info in parent and child */
         if((zend_hash_find(&parent->properties_info, mname, strlen(mname)+1, &pinfo.ptr) == SUCCESS) &&
-            (zend_hash_find(&from->properties_info, mname, strlen(mname)+1, &cinfo.ptr) == SUCCESS)) {
+                (zend_hash_find(&from->properties_info, mname, strlen(mname)+1, &cinfo.ptr) == SUCCESS)) {
             /* If the static member points to the same value in parent and child, remove for proper inheritance during restore */
             if(zend_hash_quick_find(&parent->default_static_members, p->arKey, p->nKeyLength, p->h, &pprop.ptr) == SUCCESS) {
                 if(*pprop.v == *cprop.v) {
@@ -733,6 +896,8 @@
     return ZEND_HASH_APPLY_KEEP;
 }
 
+#endif /* ZEND_ENGINE_2_4 */
+
 /*
  * This function makes sure that functions/methods that are not in the scope of the current
  * class being stored, do not get copied to the function_table hash. This makes sure they
@@ -745,7 +910,7 @@
 {
     zend_class_entry *from = from_ce;
     zend_function *zf = p->pData;
-    
+
     if (zf->common.scope == from) {
         return ZEND_HASH_APPLY_KEEP;
     }
@@ -758,6 +923,7 @@
     unsigned int i;
 
     to = (ea_class_entry *)ALLOCATE(at, sizeof(ea_class_entry));
+    memset(to, 0, sizeof(ea_class_entry));
 
     to->type = from->type;
     to->name = NULL;
@@ -766,8 +932,8 @@
 
     DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
     DBG(ea_debug_printf, (EA_DEBUG, "[%d] store_class_entry: %s parent was '%s'\n",
-                    getpid(), from->name ? from->name : "(top)",
-                    from->parent ? from->parent->name : "NULL"));
+                          getpid(), from->name ? from->name : "(top)",
+                          from->parent ? from->parent->name : "NULL"));
 #ifdef DEBUG
     EAG(xpad)++;
 #endif
@@ -776,11 +942,10 @@
         to->name = store_string(at, from->name, from->name_length + 1 TSRMLS_CC);
     }
     if (from->parent != NULL && from->parent->name) {
-        to->parent = store_string(at, from->parent->name, from->parent->name_length + 1 TSRMLS_CC);
+        to->parent = (char*)store_string(at, from->parent->name, from->parent->name_length + 1 TSRMLS_CC);
     }
 
     to->ce_flags = from->ce_flags;
-    to->static_members = NULL;
 
     /*
      * Scan the interfaces looking for the first one which isn't 0
@@ -797,27 +962,81 @@
      * hrak: no need to really store the interfaces since these get populated
      * at/after restore by zend_do_inheritance and ZEND_ADD_INTERFACE
      */
-     
+
+#ifdef ZEND_ENGINE_2_4
+    to->line_start = from->info.user.line_start;
+    to->line_end = from->info.user.line_end;
+#  ifdef INCLUDE_DOC_COMMENTS
+    to->doc_comment_len = from->info.user.doc_comment_len;
+#  endif
+
+    if (from->info.user.filename != NULL) {
+        to->filename = store_string(at, from->info.user.filename, strlen(from->info.user.filename) + 1 TSRMLS_CC);
+    }
+#  ifdef INCLUDE_DOC_COMMENTS
+    if (from->info.user.doc_comment != NULL) {
+        to->doc_comment = store_string(at, from->info.user.doc_comment, from->info.user.doc_comment_len + 1 TSRMLS_CC);
+    }
+#  endif
+#else
     to->line_start = from->line_start;
     to->line_end = from->line_end;
-#ifdef INCLUDE_DOC_COMMENTS
+#  ifdef INCLUDE_DOC_COMMENTS
     to->doc_comment_len = from->doc_comment_len;
-#endif
+#  endif
 
-    if (from->filename != NULL)
+    if (from->filename != NULL) {
         to->filename = store_string(at, from->filename, strlen(from->filename) + 1 TSRMLS_CC);
-#ifdef INCLUDE_DOC_COMMENTS
-    if (from->doc_comment != NULL)
+    }
+#  ifdef INCLUDE_DOC_COMMENTS
+    if (from->doc_comment != NULL) {
         to->doc_comment = store_string(at, from->doc_comment, from->doc_comment_len + 1 TSRMLS_CC);
+    }
+#  endif
 #endif
 
     store_zval_hash(at, &to->constants_table, &from->constants_table);
-    store_zval_hash(at, &to->default_properties, &from->default_properties);
+    /* Store default_properties */
+#ifdef ZEND_ENGINE_2_4
+    to->default_properties_count = from->default_properties_count;
+    if (from->default_properties_count) {
+        to->default_properties_table = (zval **)ALLOCATE(at, (sizeof(zval*) * from->default_properties_count));
+        for (i = 0; i < from->default_properties_count; i++) {
+            if (from->default_properties_table[i]) {
+                to->default_properties_table[i] = store_zval_ptr(at, (zval*)from->default_properties_table[i] TSRMLS_CC);
+            } else {
+                to->default_properties_table[i] = NULL;
+            }
+        }
+    } else {
+        to->default_properties_table = NULL;
+    }
+#else
+    store_hash(at, &to->default_properties, &from->default_properties, (store_bucket_t) store_zval_ptr, (check_bucket_t) store_default_property_access_check, from);
+#endif
+    /* Store properties_info */
     store_hash(at, &to->properties_info, &from->properties_info, (store_bucket_t) store_property_info, (check_bucket_t) store_property_access_check, from);
-    
+
+#ifdef ZEND_ENGINE_2_4
+    to->default_static_members_count = from->default_static_members_count;
+    if (from->default_static_members_count > 0) {
+        to->default_static_members_table = (zval **)ALLOCATE(at, (sizeof(zval*) * from->default_static_members_count));
+        for (i = 0; i < from->default_static_members_count; i++) {
+            if (from->default_static_members_table[i]) {
+                to->default_static_members_table[i] = store_zval_ptr(at, (zval*)from->default_static_members_table[i] TSRMLS_CC);
+            } else {
+                to->default_static_members_table[i] = NULL;
+            }
+        }
+    } else {
+        to->default_static_members_table = NULL;
+    }
+    to->static_members_table = to->default_static_members_table;
+#else
+    to->static_members = NULL;
     if ((from->static_members != NULL) && (from->static_members != &from->default_static_members)) {
         store_zval_hash(at, &to->default_static_members, &from->default_static_members);
-        
+
         to->static_members = (HashTable *)ALLOCATE(at, sizeof(HashTable));
 
         store_hash(at, to->static_members, from->static_members, (store_bucket_t) store_zval_ptr, (check_bucket_t) store_static_member_access_check, from);
@@ -825,8 +1044,9 @@
         store_hash(at, &to->default_static_members, &from->default_static_members, (store_bucket_t) store_zval_ptr, (check_bucket_t) store_static_member_access_check, from);
         to->static_members = &to->default_static_members;
     }
+#endif
     store_hash(at, &to->function_table, &from->function_table, (store_bucket_t) store_op_array, (check_bucket_t) store_function_inheritance_check, from);
-    
+
 #ifdef DEBUG
     EAG(xpad)--;
 #endif
@@ -865,7 +1085,7 @@
     q = NULL;
     while (c != NULL) {
         DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-        DBG(ea_debug_printf, (EA_DEBUG, "[%d] eaccelerator_store_int:     class hashkey=", getpid ()));
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] eaccelerator_store_int:     class hashkey(%d)=", getpid(), c->nKeyLength));
         DBG(ea_debug_binary_print, (EA_DEBUG, c->arKey, c->nKeyLength));
 
         fc = (ea_fc_entry *)ALLOCATE(&p, offsetof(ea_fc_entry, htabkey) + c->nKeyLength);
@@ -874,9 +1094,9 @@
         fc->htablen = c->nKeyLength;
         fc->next = NULL;
         fc->fc = *(zend_class_entry **) c->pData;
-        c = c->pListNext;
         x = fc->htabkey;
-        zend_hash_add(&EAG(strings), fc->htabkey, fc->htablen, &x, sizeof(char *), NULL);
+        zend_hash_add(&EAG(strings), c->arKey, c->nKeyLength, &x, sizeof(char *), NULL);
+        c = c->pListNext;
         if (q == NULL) {
             entry->c_head = fc;
         } else {
@@ -888,7 +1108,8 @@
     q = NULL;
     while (f != NULL) {
         DBG(ea_debug_pad, (EA_DEBUG TSRMLS_CC));
-        DBG(ea_debug_printf, (EA_DEBUG, "[%d] eaccelerator_store_int:     function hashkey='%s'\n", getpid (), f->arKey));
+        DBG(ea_debug_printf, (EA_DEBUG, "[%d] eaccelerator_store_int:     function hashkey(%d)=", getpid(), f->nKeyLength));
+        DBG(ea_debug_binary_print, (EA_DEBUG, f->arKey, f->nKeyLength));
 
         fc = (ea_fc_entry *)ALLOCATE(&p, offsetof (ea_fc_entry, htabkey) + f->nKeyLength);
 
@@ -896,9 +1117,9 @@
         fc->htablen = f->nKeyLength;
         fc->next = NULL;
         fc->fc = f->pData;
-        f = f->pListNext;
         x = fc->htabkey;
-        zend_hash_add(&EAG(strings), fc->htabkey, fc->htablen, &x, sizeof(char *), NULL);
+        zend_hash_add(&EAG(strings), f->arKey, f->nKeyLength, &x, sizeof(char *), NULL);
+        f = f->pListNext;
         if (q == NULL) {
             entry->f_head = fc;
         } else {
@@ -924,3 +1145,12 @@
 }
 
 #endif /* HAVE_EACCELERATOR */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/ea_store.h patched/ea_store.h
--- orig/ea_store.h	2010-01-19 16:49:13.000000000 +0100
+++ patched/ea_store.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -35,3 +35,12 @@
 void eaccelerator_store_int(ea_cache_entry *entry, char *key, int len, zend_op_array *op_array, Bucket *f, Bucket *c TSRMLS_DC);
 
 #endif /* EA_STORE_H */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/.gitignore patched/.gitignore
--- orig/.gitignore	2008-06-20 11:20:18.000000000 +0200
+++ patched/.gitignore	2012-08-16 15:34:36.000000000 +0200
@@ -18,4 +18,4 @@
 missing
 mkinstalldirs
 run-tests.php
-
+*~
diff -Naur orig/Makefile.frag patched/Makefile.frag
--- orig/Makefile.frag	1970-01-01 01:00:00.000000000 +0100
+++ patched/Makefile.frag	2012-08-16 15:34:36.000000000 +0200
@@ -0,0 +1,13 @@
+post-install:
+	@echo ""
+	@echo "+-------------------------------------------------------+"
+	@echo "|                 !!! Attention !!!                     |"
+	@echo "|                                                       |"
+	@echo "| For disk cache users (using eaccelerator.shm_only=0): |"
+	@echo "|                                                       |"
+	@echo "| Please remember to empty your eAccelerator disk cache |"
+	@echo "| when upgrading, otherwise things will break!          |"
+	@echo "+-------------------------------------------------------+"
+	@echo ""
+
+install: $(all_targets) $(install_targets) post-install
diff -Naur orig/mm.c patched/mm.c
--- orig/mm.c	2010-02-04 19:00:07.000000000 +0100
+++ patched/mm.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id: mm.c 401 2010-02-04 18:00:07Z bart $
+   $Id: mm.c 421 2010-07-11 21:03:14Z bart $
 */
 
 /* libmm replacement */
@@ -66,10 +66,13 @@
 #  endif
 #endif
 
-#undef MM_CHECK 
+/* Enable the memory corruption check in debug builds (cheap red zone implementation) */
+#ifdef DEBUG
+#undef MM_CHECK
+#endif
 #define MM_PATTERN  0xdeadbeef
 
-#if defined(MM_SHM_MMAP_FILE) || defined(MM_SHM_MMAP_ZERO) || defined(MM_SHM_MMAP_ANON) || defined(MM_SHM_MMAP_POSIX) || defined(HAVE_MPROTECT)
+#if defined(MM_SHM_MMAP_FILE) || defined(MM_SHM_MMAP_ZERO) || defined(MM_SHM_MMAP_ANON) || defined(MM_SHM_MMAP_POSIX)
 #  include <sys/mman.h>
 #endif
 #if defined(MM_SHM_IPC) || defined(MM_SEM_IPC)
@@ -100,24 +103,24 @@
 struct mm_mutex;
 
 typedef struct mm_free_bucket {
-  size_t                 size;
-  struct mm_free_bucket* next;
+    size_t                 size;
+    struct mm_free_bucket* next;
 } mm_free_bucket;
 
 typedef struct mm_core {
-  size_t           size;
-  void*            start;
-  size_t           available;
-  void*            attach_addr;
-  struct mm_mutex* lock;
-  mm_free_bucket*  free_list;
+    size_t           size;
+    void*            start;
+    size_t           available;
+    void*            attach_addr;
+    struct mm_mutex* lock;
+    mm_free_bucket*  free_list;
 } mm_core;
 
 typedef union mm_mem_head {
-  size_t size;
-  double a1;
-  int (*a2)(int);
-  void *a3;
+    size_t size;
+    double a1;
+    int (*a2)(int);
+    void *a3;
 } mm_mem_head;
 
 #define MM_SIZE(sz)       (sizeof(mm_mem_head)+(sz))
@@ -133,10 +136,10 @@
 #endif
 
 typedef union mm_word {
-  size_t size;
-  void*  ptr;
-  double d;
-  int (*func)(int);
+    size_t size;
+    void*  ptr;
+    double d;
+    int (*func)(int);
 } mm_word;
 
 #if (defined (__GNUC__) && __GNUC__ >= 2)
@@ -161,17 +164,18 @@
 #undef MM_SHM_CAN_ATTACH
 
 #if defined(MM_SEM_POSIX) || defined(MM_SEM_FCNTL) || defined(MM_SEM_FLOCK) || defined(MM_SEM_WIN32) || defined(MM_SHM_MMAP_POSIX) || defined(MM_SHM_MMAP_FILE)
-static int strxcat(char* dst, const char* src, int size) {
-  int dst_len = strlen(dst);
-  int src_len = strlen(src);
-  if (dst_len + src_len < size) {
-    memcpy(dst+dst_len, src, src_len+1);
-    return 1;
-  } else {
-    memcpy(dst+dst_len, src, (size-1)-dst_len);
-    dst[size-1] = '\000';
-    return 0;
-  }
+static int strxcat(char* dst, const char* src, int size)
+{
+    int dst_len = strlen(dst);
+    int src_len = strlen(src);
+    if (dst_len + src_len < size) {
+        memcpy(dst+dst_len, src, src_len+1);
+        return 1;
+    } else {
+        memcpy(dst+dst_len, src, (size-1)-dst_len);
+        dst[size-1] = '\000';
+        return 0;
+    }
 }
 #endif
 
@@ -195,48 +199,90 @@
 #define MM_SEM_TYPE "spinlock"
 #define MM_SEM_CAN_ATTACH
 
+#include <sched.h>
+
 typedef struct mm_mutex {
-    volatile unsigned int lock;
-    volatile pid_t pid;
-    volatile int locked;
+    volatile unsigned int locked;
 } mm_mutex;
 
-#define spinlock_try_lock(rw)  asm volatile("lock ; decl %0" :"=m" ((rw)->lock) : : "memory")
-#define _spinlock_unlock(rw)   asm volatile("lock ; incl %0" :"=m" ((rw)->lock) : : "memory")
+static void mm_do_lock_slow(volatile unsigned int* locked);
 
-static int mm_init_lock(const char* key, mm_mutex* lock) 
+static int mm_init_lock(const char* key, mm_mutex* lock)
 {
-    lock->lock = 0x1;
-    lock->pid = -1;
     lock->locked = 0;
     return 1;
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) 
+static inline int mm_do_lock(mm_mutex* lock, int kind)
 {
-    while (1) {
-        spinlock_try_lock(lock);
-        if (lock->lock == 0) {
-            lock->pid = getpid();
-            lock->locked = 1;
-            return 1;
+    int ret, i;
+    __asm__ __volatile__
+    ("xchgl %0, %1"
+     : "=r"(ret), "=m"(lock->locked)
+     : "0"(1), "m"(lock->locked)
+     : "memory");
+
+    if (ret) {
+        /* We didn't immediately get the lock,
+           try again 1000 times with pause instruction in the loop */
+        for (i = 0; i < 1000; i++) {
+            __asm__ __volatile__
+            ("pause\n"
+             "xchgl %0, %1"
+             : "=r"(ret), "=m"(lock->locked)
+             : "0"(1), "m"(lock->locked)
+             : "memory");
+            
+            if (!ret) {
+                return 1;
+            }
+        }
+
+        if (ret) {
+            /* Still no luck, try the slow approach */
+            mm_do_lock_slow(&lock->locked);
         }
-        _spinlock_unlock(lock);
-        sched_yield();
     }
     return 1;
 }
 
-static int mm_do_unlock(mm_mutex* lock) {
-    if (lock->locked && (lock->pid == getpid())) {
-        lock->pid = 0;
-        lock->locked = 0;
-        _spinlock_unlock(lock);
+static void mm_do_lock_slow(volatile unsigned int* locked)
+{
+    sched_yield();
+    while(1) {
+        int ret;
+        __asm__ __volatile__
+        ("pause\n"
+         "xchgl %0, %1"
+         : "=r"(ret), "=m"(*locked)
+         : "0"(1), "m"(*locked)
+         : "memory");
+
+        if (!ret) {
+            return;
+        }
+
+        /* Sleep for a while */
+        struct timespec t;
+        t.tv_sec = 0;
+        t.tv_nsec = 2000000;
+        nanosleep(&t, NULL);
     }
-    return 1;
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
+static inline int mm_do_unlock(mm_mutex* lock)
+{
+    __asm__ __volatile__
+    ("movl $0, %0"
+     : "=m"(lock->locked)
+     : "m" (lock->locked)
+     : "memory");
+     
+     return 1;
+}
+
+static void mm_destroy_lock(mm_mutex* lock)
+{
 }
 
 /* ######################################################################### */
@@ -246,41 +292,45 @@
 #define MM_SEM_TYPE "pthread"
 
 typedef struct mm_mutex {
-  pthread_mutex_t mutex;
+    pthread_mutex_t mutex;
 } mm_mutex;
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  pthread_mutexattr_t mattr;
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    pthread_mutexattr_t mattr;
 
-  if (pthread_mutexattr_init(&mattr) != 0) {
-    return 0;
-  }
-  if (pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED) != 0) {
-    return 0;
-  }
-  if (pthread_mutex_init(&lock->mutex, &mattr) != 0) {
-    return 0;
-  }
-  pthread_mutexattr_destroy(&mattr);
-  return 1;
+    if (pthread_mutexattr_init(&mattr) != 0) {
+        return 0;
+    }
+    if (pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED) != 0) {
+        return 0;
+    }
+    if (pthread_mutex_init(&lock->mutex, &mattr) != 0) {
+        return 0;
+    }
+    pthread_mutexattr_destroy(&mattr);
+    return 1;
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  if (pthread_mutex_lock(&lock->mutex) != 0) {
-    return 0;
-  }
-  return 1;
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    if (pthread_mutex_lock(&lock->mutex) != 0) {
+        return 0;
+    }
+    return 1;
 }
 
-static int mm_do_unlock(mm_mutex* lock) {
-  if (pthread_mutex_unlock(&lock->mutex) != 0) {
-    return 0;
-  }
-  return 1;
+static int mm_do_unlock(mm_mutex* lock)
+{
+    if (pthread_mutex_unlock(&lock->mutex) != 0) {
+        return 0;
+    }
+    return 1;
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
-  pthread_mutex_destroy(&lock->mutex);
+static void mm_destroy_lock(mm_mutex* lock)
+{
+    pthread_mutex_destroy(&lock->mutex);
 }
 
 /* ######################################################################### */
@@ -292,44 +342,48 @@
 #define MM_SEM_TYPE "posix"
 
 typedef struct mm_mutex {
-  sem_t* sem;
+    sem_t* sem;
 } mm_mutex;
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  int fd;
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    int fd;
 #ifdef SEM_NAME_LEN
-  char s[SEM_NAME_LEN];
+    char s[SEM_NAME_LEN];
 
-  strncpy(s, key, SEM_NAME_LEN - 1);
-  strxcat(s, ".sem.XXXXXX", SEM_NAME_LEN);
+    strncpy(s, key, SEM_NAME_LEN - 1);
+    strxcat(s, ".sem.XXXXXX", SEM_NAME_LEN);
 #else
-  char s[MAXPATHLEN];
+    char s[MAXPATHLEN];
 
-  strncpy(s, key, MAXPATHLEN - 1);
-  strxcat(s, ".sem.XXXXXX", MAXPATHLEN);
+    strncpy(s, key, MAXPATHLEN - 1);
+    strxcat(s, ".sem.XXXXXX", MAXPATHLEN);
 #endif
-  if (mkstemp(s) == NULL) {
-    perror(s);
-    return 0;
-  }
-  if ((lock->sem = sem_open(s, O_CREAT, S_IRUSR | S_IWUSR, 1)) == (sem_t*)SEM_FAILED) {
-    perror(s);
-    return 0;
-  }
-  sem_unlink(s);
-  return 1;
+    if (mkstemp(s) == NULL) {
+        perror(s);
+        return 0;
+    }
+    if ((lock->sem = sem_open(s, O_CREAT, S_IRUSR | S_IWUSR, 1)) == (sem_t*)SEM_FAILED) {
+        perror(s);
+        return 0;
+    }
+    sem_unlink(s);
+    return 1;
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  return (sem_wait(lock->sem) == 0);
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    return (sem_wait(lock->sem) == 0);
 }
 
-static int mm_do_unlock(mm_mutex* lock) {
-  return (sem_post(lock->sem) == 0);
+static int mm_do_unlock(mm_mutex* lock)
+{
+    return (sem_post(lock->sem) == 0);
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
-  sem_close(lock->sem);
+static void mm_destroy_lock(mm_mutex* lock)
+{
+    sem_close(lock->sem);
 }
 
 /* ######################################################################### */
@@ -348,73 +402,77 @@
 #endif
 
 typedef struct mm_mutex {
-  int semid;
+    int semid;
 } mm_mutex;
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  int rc;
-  union semun arg;
-  struct semid_ds buf;
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    int rc;
+    union semun arg;
+    struct semid_ds buf;
 
-  if ((lock->semid = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR)) < 0) {
-    return 0;
-  }
+    if ((lock->semid = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR)) < 0) {
+        return 0;
+    }
 
-  arg.buf = &buf;
-  do {
-    rc = semctl(lock->semid, 0, IPC_STAT, arg);
-  } while (rc < 0 && errno == EINTR);
-
-  buf.sem_perm.uid = EA_USERID;
-
-  do {
-    rc = semctl(lock->semid, 0, IPC_SET, arg);
-  } while (rc < 0 && errno == EINTR);
-  
-  arg.val = 1;
-  do {
-    rc = semctl(lock->semid, 0, SETVAL, arg);
-  } while (rc < 0 && errno == EINTR);
-  if (rc < 0) {
+    arg.buf = &buf;
     do {
-      semctl(lock->semid, 0, IPC_RMID, 0);
+        rc = semctl(lock->semid, 0, IPC_STAT, arg);
     } while (rc < 0 && errno == EINTR);
-    return 0;
-  }
-  return 1;
+
+    buf.sem_perm.uid = EA_USERID;
+
+    do {
+        rc = semctl(lock->semid, 0, IPC_SET, arg);
+    } while (rc < 0 && errno == EINTR);
+
+    arg.val = 1;
+    do {
+        rc = semctl(lock->semid, 0, SETVAL, arg);
+    } while (rc < 0 && errno == EINTR);
+    if (rc < 0) {
+        do {
+            semctl(lock->semid, 0, IPC_RMID, 0);
+        } while (rc < 0 && errno == EINTR);
+        return 0;
+    }
+    return 1;
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  int rc;
-  struct sembuf op;
-
-  op.sem_num = 0;
-  op.sem_op  = -1;
-  op.sem_flg = SEM_UNDO;
-  do {
-    rc = semop(lock->semid, &op, 1);
-  } while (rc < 0 && errno == EINTR);
-  return (rc == 0);
-}
-
-static int mm_do_unlock(mm_mutex* lock) {
-  int rc;
-  struct sembuf op;
-
-  op.sem_num = 0;
-  op.sem_op  = 1;
-  op.sem_flg = SEM_UNDO;
-  do {
-    rc = semop(lock->semid, &op, 1);
-  } while (rc < 0 && errno == EINTR);
-  return (rc == 0);
-}
-
-static void mm_destroy_lock(mm_mutex* lock) {
-  int rc;
-  do {
-    rc = semctl(lock->semid, 0, IPC_RMID, 0);
-  } while (rc < 0 && errno == EINTR);
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    int rc;
+    struct sembuf op;
+
+    op.sem_num = 0;
+    op.sem_op  = -1;
+    op.sem_flg = SEM_UNDO;
+    do {
+        rc = semop(lock->semid, &op, 1);
+    } while (rc < 0 && errno == EINTR);
+    return (rc == 0);
+}
+
+static int mm_do_unlock(mm_mutex* lock)
+{
+    int rc;
+    struct sembuf op;
+
+    op.sem_num = 0;
+    op.sem_op  = 1;
+    op.sem_flg = SEM_UNDO;
+    do {
+        rc = semop(lock->semid, &op, 1);
+    } while (rc < 0 && errno == EINTR);
+    return (rc == 0);
+}
+
+static void mm_destroy_lock(mm_mutex* lock)
+{
+    int rc;
+    do {
+        rc = semctl(lock->semid, 0, IPC_RMID, 0);
+    } while (rc < 0 && errno == EINTR);
 }
 
 #elif defined(MM_SEM_FCNTL)
@@ -422,55 +480,59 @@
 #define MM_SEM_TYPE "fcntl"
 
 typedef struct mm_mutex {
-  int fd;
+    int fd;
 } mm_mutex;
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  char s[MAXPATHLEN];
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    char s[MAXPATHLEN];
 
-  strncpy(s,key,MAXPATHLEN-1);
-  strxcat(s,".sem.XXXXXX",MAXPATHLEN);
-  lock->fd =mkstemp(s);
-  if (lock->fd != -1) {
-    unlink(s);
-  }
-  return (lock->fd != -1);
+    strncpy(s,key,MAXPATHLEN-1);
+    strxcat(s,".sem.XXXXXX",MAXPATHLEN);
+    lock->fd =mkstemp(s);
+    if (lock->fd != -1) {
+        unlink(s);
+    }
+    return (lock->fd != -1);
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  int rc;
-  struct flock l;
-  l.l_whence   = SEEK_SET;
-  l.l_start    = 0;
-  l.l_len      = 0;
-  l.l_pid      = 0;
-  if (kind == MM_LOCK_RD) {
-    l.l_type     = F_RDLCK;
-  } else {
-    l.l_type     = F_WRLCK;
-  }
-  do {
-    rc = fcntl(lock->fd, F_SETLKW, &l);
-  } while (rc < 0 && errno == EINTR);
-  return (rc == 0);
-}
-
-static int mm_do_unlock(mm_mutex* lock) {
-  int rc;
-  struct flock l;
-  l.l_whence   = SEEK_SET;
-  l.l_start    = 0;
-  l.l_len      = 0;
-  l.l_pid      = 0;
-  l.l_type     = F_UNLCK;
-  do {
-    rc = fcntl(lock->fd, F_SETLKW, &l);
-  } while (rc < 0 && errno == EINTR);
-  return (rc == 0);
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    int rc;
+    struct flock l;
+    l.l_whence   = SEEK_SET;
+    l.l_start    = 0;
+    l.l_len      = 0;
+    l.l_pid      = 0;
+    if (kind == MM_LOCK_RD) {
+        l.l_type     = F_RDLCK;
+    } else {
+        l.l_type     = F_WRLCK;
+    }
+    do {
+        rc = fcntl(lock->fd, F_SETLKW, &l);
+    } while (rc < 0 && errno == EINTR);
+    return (rc == 0);
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
-  close(lock->fd);
+static int mm_do_unlock(mm_mutex* lock)
+{
+    int rc;
+    struct flock l;
+    l.l_whence   = SEEK_SET;
+    l.l_start    = 0;
+    l.l_len      = 0;
+    l.l_pid      = 0;
+    l.l_type     = F_UNLCK;
+    do {
+        rc = fcntl(lock->fd, F_SETLKW, &l);
+    } while (rc < 0 && errno == EINTR);
+    return (rc == 0);
+}
+
+static void mm_destroy_lock(mm_mutex* lock)
+{
+    close(lock->fd);
 }
 
 /* ######################################################################### */
@@ -485,65 +547,69 @@
 static pid_t mm_flock_pid = -1;
 
 typedef struct mm_mutex {
-  char filename[MAXPATHLEN];
+    char filename[MAXPATHLEN];
 } mm_mutex;
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  strncpy(lock->filename,key,MAXPATHLEN-1);
-  strxcat(lock->filename,".sem.XXXXXX",MAXPATHLEN);
-  mm_flock_fd =mkstemp(lock->filename);
-  if (mm_flock_fd != -1) {
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    strncpy(lock->filename,key,MAXPATHLEN-1);
+    strxcat(lock->filename,".sem.XXXXXX",MAXPATHLEN);
+    mm_flock_fd =mkstemp(lock->filename);
+    if (mm_flock_fd != -1) {
 #if defined(F_SETFD) && defined(FD_CLOEXEC)
-    fcntl(mm_flock_fd, F_SETFD, FD_CLOEXEC);
+        fcntl(mm_flock_fd, F_SETFD, FD_CLOEXEC);
 #endif
-    mm_flock_pid = getpid();
-    return 1;
-  }
-  return 0;
+        mm_flock_pid = getpid();
+        return 1;
+    }
+    return 0;
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  pid_t pid = getpid();
-  int rc;
-  if (kind == MM_LOCK_RD) {
-    kind = LOCK_SH;
-  } else {
-    kind = LOCK_EX;
-  }
-
-  if (mm_flock_fd == -1 || mm_flock_pid != pid) {
-    mm_flock_fd = open(lock->filename, O_RDWR, S_IRUSR | S_IWUSR);
-    if (mm_flock_fd == -1) {
-      return 0;
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    pid_t pid = getpid();
+    int rc;
+    if (kind == MM_LOCK_RD) {
+        kind = LOCK_SH;
+    } else {
+        kind = LOCK_EX;
     }
+
+    if (mm_flock_fd == -1 || mm_flock_pid != pid) {
+        mm_flock_fd = open(lock->filename, O_RDWR, S_IRUSR | S_IWUSR);
+        if (mm_flock_fd == -1) {
+            return 0;
+        }
 #if defined(F_SETFD) && defined(FD_CLOEXEC)
-    fcntl(mm_flock_fd, F_SETFD, FD_CLOEXEC);
+        fcntl(mm_flock_fd, F_SETFD, FD_CLOEXEC);
 #endif
-    mm_flock_pid = pid;
-  }
-  do {
-    rc = flock(mm_flock_fd, kind);
-  } while (rc < 0 && errno == EINTR);
-  return (rc == 0);
+        mm_flock_pid = pid;
+    }
+    do {
+        rc = flock(mm_flock_fd, kind);
+    } while (rc < 0 && errno == EINTR);
+    return (rc == 0);
 }
 
-static int mm_do_unlock(mm_mutex* lock) {
-  int rc;
-  if (mm_flock_fd == -1) {
-    mm_flock_fd = open(lock->filename, O_RDWR, S_IRUSR | S_IWUSR);
+static int mm_do_unlock(mm_mutex* lock)
+{
+    int rc;
     if (mm_flock_fd == -1) {
-      return 0;
+        mm_flock_fd = open(lock->filename, O_RDWR, S_IRUSR | S_IWUSR);
+        if (mm_flock_fd == -1) {
+            return 0;
+        }
     }
-  }
-  do {
-    rc = flock(mm_flock_fd, LOCK_UN);
-  } while (rc < 0 && errno == EINTR);
-  return (rc == 0);
+    do {
+        rc = flock(mm_flock_fd, LOCK_UN);
+    } while (rc < 0 && errno == EINTR);
+    return (rc == 0);
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
-  close(mm_flock_fd);
-  unlink(lock->filename);
+static void mm_destroy_lock(mm_mutex* lock)
+{
+    close(mm_flock_fd);
+    unlink(lock->filename);
 }
 
 /* ######################################################################### */
@@ -564,70 +630,75 @@
 #define MM_SEM_CAN_ATTACH
 
 typedef struct mm_mutex {
-  HANDLE hMutex;
+    HANDLE hMutex;
 } mm_mutex;
 
 static mm_mutex g_lock;
 
-static int mm_attach_lock(const char* key, mm_mutex* lock) {
-  char* ch;
-  char name[256];
-  HANDLE hMutex;
-
-  strncpy(name, key, 255);
-  strxcat(name, ".sem", 255);
-  for (ch = name; *ch; ++ch) {
-    if (*ch == ':' || *ch == '/' || *ch == '\\') {
-      *ch = '_';
-    }
-  }
-  g_lock.hMutex = hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, name);
-  if (!g_lock.hMutex) {
-    return 0;
-  }
-  return 1;
+static int mm_attach_lock(const char* key, mm_mutex* lock)
+{
+    char* ch;
+    char name[256];
+    HANDLE hMutex;
+
+    strncpy(name, key, 255);
+    strxcat(name, ".sem", 255);
+    for (ch = name; *ch; ++ch) {
+        if (*ch == ':' || *ch == '/' || *ch == '\\') {
+            *ch = '_';
+        }
+    }
+    g_lock.hMutex = hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, name);
+    if (!g_lock.hMutex) {
+        return 0;
+    }
+    return 1;
 }
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  char* ch;
-  char name[256];
-  strncpy(name, key, 255);
-  strxcat(name, ".sem", 255);
-  for (ch = name; *ch; ++ch) {
-    if (*ch == ':' || *ch == '/' || *ch == '\\') {
-      *ch = '_';
-    }
-  }
-  g_lock.hMutex = CreateMutex(NULL, FALSE, name);
-  if (!g_lock.hMutex) {
-    return 0;
-  }
-  return 1;
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    char* ch;
+    char name[256];
+    strncpy(name, key, 255);
+    strxcat(name, ".sem", 255);
+    for (ch = name; *ch; ++ch) {
+        if (*ch == ':' || *ch == '/' || *ch == '\\') {
+            *ch = '_';
+        }
+    }
+    g_lock.hMutex = CreateMutex(NULL, FALSE, name);
+    if (!g_lock.hMutex) {
+        return 0;
+    }
+    return 1;
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
-  CloseHandle(g_lock.hMutex);
+static void mm_destroy_lock(mm_mutex* lock)
+{
+    CloseHandle(g_lock.hMutex);
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  DWORD rv;
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    DWORD rv;
 
-  rv = WaitForSingleObject(g_lock.hMutex, INFINITE);
+    rv = WaitForSingleObject(g_lock.hMutex, INFINITE);
 
-  if (rv == WAIT_OBJECT_0 || rv == WAIT_ABANDONED) {
-    return 1;
-  }
-  return 0;
+    if (rv == WAIT_OBJECT_0 || rv == WAIT_ABANDONED) {
+        return 1;
+    }
+    return 0;
 }
 
-static int mm_do_unlock(mm_mutex* lock) {
-  if (ReleaseMutex(g_lock.hMutex) == 0) {
-      // Releasing the mutex doesn't seem to work under windows. It gives some
-      // extremely obscure error code. Locking seems to work though. Because this
-      // flood the error log of the win32 users we are not going to return 0 here
-      // until a windows dev has found the problem.
-  }
-  return 1;
+static int mm_do_unlock(mm_mutex* lock)
+{
+    if (ReleaseMutex(g_lock.hMutex) == 0) {
+        // Releasing the mutex doesn't seem to work under windows. It gives some
+        // extremely obscure error code. Locking seems to work though. Because this
+        // flood the error log of the win32 users we are not going to return 0 here
+        // until a windows dev has found the problem.
+    }
+    return 1;
 }
 
 /* ######################################################################### */
@@ -639,52 +710,59 @@
 
 
 typedef struct mm_mutex {
-  int semid;
+    int semid;
 } mm_mutex;
 
-static int mm_attach_lock(const char* key, mm_mutex* lock) {
-  return 1;
+static int mm_attach_lock(const char* key, mm_mutex* lock)
+{
+    return 1;
 }
 
-static int mm_init_lock(const char* key, mm_mutex* lock) {
-  return 1;
+static int mm_init_lock(const char* key, mm_mutex* lock)
+{
+    return 1;
 }
 
-static void mm_destroy_lock(mm_mutex* lock) {
+static void mm_destroy_lock(mm_mutex* lock)
+{
 }
 
-static int mm_do_lock(mm_mutex* lock, int kind) {
-  return 1;
+static int mm_do_lock(mm_mutex* lock, int kind)
+{
+    return 1;
 }
 
-static int mm_do_unlock(mm_mutex* lock) {
-  return 1;
+static int mm_do_unlock(mm_mutex* lock)
+{
+    return 1;
 }
 
 #else
 #  error "Semaohore type is not selected. Define one of the following: MM_SEM_SPINLOCK, MM_SEM_PTHREAD, MM_SEM_POSIX, MM_SEM_IPC, MM_SEM_FCNTL, MM_SEM_FLOCK, MM_SEM_BEOS, MM_SEM_OS2, MM_SEM_WIN32"
 #endif
 
-int mm_lock(MM* mm, int kind) {
-  if (mm_do_lock(mm->lock, kind)) {
-    return 1;
-  } else {
+int mm_lock(MM* mm, int kind)
+{
+    if (mm_do_lock(mm->lock, kind)) {
+        return 1;
+    } else {
 #if !defined(MM_TEST_SEM) && !defined(MM_TEST_SHM)
-    ea_debug_error("eAccelerator: Could not lock!\n");
+        ea_debug_error("eAccelerator: Could not lock!\n");
 #endif
-    return 0;
-  }
+        return 0;
+    }
 }
 
-int mm_unlock(MM* mm) {
-  if (mm_do_unlock(mm->lock)) {
-    return 1;
-  } else {
+int mm_unlock(MM* mm)
+{
+    if (mm_do_unlock(mm->lock)) {
+        return 1;
+    } else {
 #if !defined(MM_TEST_SEM) && !defined(MM_TEST_SHM)
-    ea_debug_error("eAccelerator: Could not release lock!\n");
+        ea_debug_error("eAccelerator: Could not release lock!\n");
 #endif
-    return 0;
-  }
+        return 0;
+    }
 }
 
 /* Shared Memory Implementations */
@@ -702,65 +780,67 @@
 # define SHM_W 0222 /* write permission */
 #endif
 
-static MM* mm_create_shm(const char* key, size_t size) {
-  int fd;
-  void** segment = NULL;
-  if ((fd = shmget(IPC_PRIVATE, size, (IPC_CREAT | SHM_R | SHM_W))) >= 0) {
-    MM* p;
-    if ((p = (MM*)shmat(fd, NULL, 0)) != ((void *)-1)) {
-      struct shmid_ds shmbuf;
-      if (shmctl(fd, IPC_STAT, &shmbuf) == 0) {
-        shmbuf.shm_perm.uid = getuid();
-        shmbuf.shm_perm.gid = getgid();
-        if (shmctl(fd, IPC_SET, &shmbuf) == 0) {
-          shmctl(fd, IPC_RMID, NULL);
-          p->size = size;
-          segment = (void**)((char*)p+sizeof(MM));
-          *segment = (void*)-1;
-          segment++;
-          p->start = segment;
-          return p;
+static MM* mm_create_shm(const char* key, size_t size)
+{
+    int fd;
+    void** segment = NULL;
+    if ((fd = shmget(IPC_PRIVATE, size, (IPC_CREAT | SHM_R | SHM_W))) >= 0) {
+        MM* p;
+        if ((p = (MM*)shmat(fd, NULL, 0)) != ((void *)-1)) {
+            struct shmid_ds shmbuf;
+            if (shmctl(fd, IPC_STAT, &shmbuf) == 0) {
+                shmbuf.shm_perm.uid = getuid();
+                shmbuf.shm_perm.gid = getgid();
+                if (shmctl(fd, IPC_SET, &shmbuf) == 0) {
+                    shmctl(fd, IPC_RMID, NULL);
+                    p->size = size;
+                    segment = (void**)((char*)p+sizeof(MM));
+                    *segment = (void*)-1;
+                    segment++;
+                    p->start = segment;
+                    return p;
+                }
+            }
+            shmdt(p);
         }
-      }
-      shmdt(p);
-    }
-    shmctl(fd, IPC_RMID, NULL);
-  } else {
-    size_t seg_size = 1024*1024;
+        shmctl(fd, IPC_RMID, NULL);
+    } else {
+        size_t seg_size = 1024*1024;
 
-    while (seg_size <= size/2) {
-      seg_size *= 2;
-    }
-    while ((fd = shmget(IPC_PRIVATE, seg_size, (IPC_CREAT | SHM_R | SHM_W))) == -1) {
-      if (seg_size <= 1024*1024) {
+        while (seg_size <= size/2) {
+            seg_size *= 2;
+        }
+        while ((fd = shmget(IPC_PRIVATE, seg_size, (IPC_CREAT | SHM_R | SHM_W))) == -1) {
+            if (seg_size <= 1024*1024) {
 #if !defined(MM_TEST_SEM) && !defined(MM_TEST_SHM)
-        ea_debug_error("eAccelerator: shmmax should be at least 2MB");
+                ea_debug_error("eAccelerator: shmmax should be at least 2MB");
 #endif
-        return (MM*)-1;
-      }
-      seg_size /= 2;
-    }
+                return (MM*)-1;
+            }
+            seg_size /= 2;
+        }
 #if !defined(MM_TEST_SEM) && !defined(MM_TEST_SHM)
-    ea_debug_error("eAccelerator: Could not allocate %d bytes, the maximum size the kernel allows is %d bytes. "
-            "Lower the amount of memory request or increase the limit in /proc/sys/kernel/shmmax.\n", size, seg_size);
+        ea_debug_error("eAccelerator: Could not allocate %d bytes, the maximum size the kernel allows is %d bytes. "
+                       "Lower the amount of memory request or increase the limit in /proc/sys/kernel/shmmax.\n", size, seg_size);
 #endif
 
-    /* bart: Removed the code that tried to allocate more then one segment 
-     * because it didn't work, this part needs a redesign of the mm code to 
-     * allow this. It should allocate one to init the shared memory and add
-     * the other to the free list.
-     */
-  }
-  return (MM*)-1;
-}
-
-static void mm_destroy_shm(MM* mm) {
-  void** segment = (void**)((char*)mm+sizeof(MM));
-  while (*segment != (void*)-1) {
-    shmdt(*segment);
-    ++segment;
-  }
-  shmdt(mm);
+        /* bart: Removed the code that tried to allocate more then one segment
+         * because it didn't work, this part needs a redesign of the mm code to
+         * allow this. It should allocate one to init the shared memory and add
+         * the other to the free list.
+         */
+    }
+    return (MM*)-1;
+}
+
+static void mm_destroy_shm(MM* mm)
+{
+    void** segment = (void**)((char*)mm+sizeof(MM));
+    while (*segment != (void*)-1) {
+        shmdt(*segment);
+        ++segment;
+    }
+    shmdt(mm);
 }
 
 /* ######################################################################### */
@@ -775,18 +855,20 @@
 #  endif
 #endif
 
-static MM* mm_create_shm(const char* key, size_t size) {
-  MM* p;
-  p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
-  if (p != (MM*)-1) {
-    p->size = size;
-    p->start = (char*)p+sizeof(MM);
-  }
-  return p;
+static MM* mm_create_shm(const char* key, size_t size)
+{
+    MM* p;
+    p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
+    if (p != (MM*)-1) {
+        p->size = size;
+        p->start = (char*)p+sizeof(MM);
+    }
+    return p;
 }
 
-static void mm_destroy_shm(MM* mm) {
-  munmap(mm,mm->size);
+static void mm_destroy_shm(MM* mm)
+{
+    munmap(mm,mm->size);
 }
 
 /* ######################################################################### */
@@ -795,23 +877,25 @@
 
 #define MM_SHM_TYPE "mmap_zero"
 
-static MM* mm_create_shm(const char* key, size_t size) {
-  MM* p;
-  int fd = open("/dev/zero", O_RDWR, S_IRUSR | S_IWUSR);
-  if (fd == -1) {
-    return (MM*)-1;
-  }
-  p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-  close(fd);
-  if (p != (MM*)-1) {
-    p->size = size;
-    p->start = (char*)p+sizeof(MM);
-  }
-  return p;
+static MM* mm_create_shm(const char* key, size_t size)
+{
+    MM* p;
+    int fd = open("/dev/zero", O_RDWR, S_IRUSR | S_IWUSR);
+    if (fd == -1) {
+        return (MM*)-1;
+    }
+    p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    close(fd);
+    if (p != (MM*)-1) {
+        p->size = size;
+        p->start = (char*)p+sizeof(MM);
+    }
+    return p;
 }
 
-static void mm_destroy_shm(MM* mm) {
-  munmap(mm,mm->size);
+static void mm_destroy_shm(MM* mm)
+{
+    munmap(mm,mm->size);
 }
 
 /* ######################################################################### */
@@ -822,36 +906,38 @@
 
 /* Not Tested */
 
-static MM* mm_create_shm(const char* key, size_t size) {
-  MM* p;
-  int fd;
-  char s[MAXPATHLEN];
-
-  strncpy(s,key,MAXPATHLEN-1);
-  strxcat(s,".shm.XXXXXX",MAXPATHLEN);
-  if (mkstemp(s) == -1) {
-    return (MM*)-1;
-  }
-  if ((fd = shm_open(s, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR)) == -1) {
-    return (MM*)-1;
-  }
-  if (ftruncate(fd, size) < 0) {
-    close(fd);
+static MM* mm_create_shm(const char* key, size_t size)
+{
+    MM* p;
+    int fd;
+    char s[MAXPATHLEN];
+
+    strncpy(s,key,MAXPATHLEN-1);
+    strxcat(s,".shm.XXXXXX",MAXPATHLEN);
+    if (mkstemp(s) == -1) {
+        return (MM*)-1;
+    }
+    if ((fd = shm_open(s, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR)) == -1) {
+        return (MM*)-1;
+    }
+    if (ftruncate(fd, size) < 0) {
+        close(fd);
+        shm_unlink(s);
+        return (MM*)-1;
+    }
+    p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
     shm_unlink(s);
-    return (MM*)-1;
-  }
-  p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-  shm_unlink(s);
-  close(fd);
-  if (p != (MM*)-1) {
-    p->size = size;
-    p->start = (char*)p+sizeof(MM);
-  }
-  return p;
+    close(fd);
+    if (p != (MM*)-1) {
+        p->size = size;
+        p->start = (char*)p+sizeof(MM);
+    }
+    return p;
 }
 
-static void mm_destroy_shm(MM* mm) {
-  munmap(mm,mm->size);
+static void mm_destroy_shm(MM* mm)
+{
+    munmap(mm,mm->size);
 }
 
 /* ######################################################################### */
@@ -860,32 +946,34 @@
 
 #define MM_SHM_TYPE "mmap_file"
 
-static MM* mm_create_shm(const char* key, size_t size) {
-  MM* p;
-  int fd;
-  char s[MAXPATHLEN];
-
-  strncpy(s,key,MAXPATHLEN-1);
-  strxcat(s,".shm.XXXXXX",MAXPATHLEN);
-  fd = mkstemp(s);
-  if (fd < 0) {
-    return (MM*)-1;
-  }
-  if (ftruncate(fd, size) < 0) {
-    return (MM*)-1;
-  }
-  p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-  close(fd);
-  unlink(s);
-  if (p != (MM*)-1) {
-    p->size = size;
-    p->start = (char*)p+sizeof(MM);
-  }
-  return p;
+static MM* mm_create_shm(const char* key, size_t size)
+{
+    MM* p;
+    int fd;
+    char s[MAXPATHLEN];
+
+    strncpy(s,key,MAXPATHLEN-1);
+    strxcat(s,".shm.XXXXXX",MAXPATHLEN);
+    fd = mkstemp(s);
+    if (fd < 0) {
+        return (MM*)-1;
+    }
+    if (ftruncate(fd, size) < 0) {
+        return (MM*)-1;
+    }
+    p = (MM*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    close(fd);
+    unlink(s);
+    if (p != (MM*)-1) {
+        p->size = size;
+        p->start = (char*)p+sizeof(MM);
+    }
+    return p;
 }
 
-static void mm_destroy_shm(MM* mm) {
-  munmap(mm,mm->size);
+static void mm_destroy_shm(MM* mm)
+{
+    munmap(mm,mm->size);
 }
 
 /* ######################################################################### */
@@ -909,84 +997,87 @@
 #define MM_SHM_TYPE "win32"
 #define MM_SHM_CAN_ATTACH
 
-static MM* mm_attach_shm(const char* key, size_t size) {
-  HANDLE  shm_handle;
-  MM*     mm;
-  MM*     addr;
-  MM**    addr_ptr;
-  char    s[MAXPATHLEN];
-  char*   ch;
-
-
-  strcpy(s,key);
-  for (ch = s; *ch; ++ch) {
-    if (*ch == ':' || *ch == '/' || *ch == '\\') {
-      *ch = '_';
-    }
-  }
-
-  shm_handle = OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, s);
-  if (shm_handle) {
-    mm = (MM*)MapViewOfFile(shm_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0);
-    if (mm == NULL) {
-      return (MM*)-1;
-    }
-/*
-    if (mm->size != size) {
-      UnmapViewOfFile(mm);
-      CloseHandle(shm_handle);
-      return (MM*)-1;
+static MM* mm_attach_shm(const char* key, size_t size)
+{
+    HANDLE  shm_handle;
+    MM*     mm;
+    MM*     addr;
+    MM**    addr_ptr;
+    char    s[MAXPATHLEN];
+    char*   ch;
+
+
+    strcpy(s,key);
+    for (ch = s; *ch; ++ch) {
+        if (*ch == ':' || *ch == '/' || *ch == '\\') {
+            *ch = '_';
+        }
     }
-*/
-    addr_ptr = (MM**)(((char*)mm)+sizeof(MM));
-    addr = *addr_ptr;
-    if (addr != mm) {
-      UnmapViewOfFile(mm);
-      mm = (MM*)MapViewOfFileEx(shm_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0, addr);
-      if (mm == NULL) {
-        return (MM*)-1;
-      }
+
+    shm_handle = OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, s);
+    if (shm_handle) {
+        mm = (MM*)MapViewOfFile(shm_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0);
+        if (mm == NULL) {
+            return (MM*)-1;
+        }
+        /*
+            if (mm->size != size) {
+              UnmapViewOfFile(mm);
+              CloseHandle(shm_handle);
+              return (MM*)-1;
+            }
+        */
+        addr_ptr = (MM**)(((char*)mm)+sizeof(MM));
+        addr = *addr_ptr;
+        if (addr != mm) {
+            UnmapViewOfFile(mm);
+            mm = (MM*)MapViewOfFileEx(shm_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0, addr);
+            if (mm == NULL) {
+                return (MM*)-1;
+            }
+        }
+        /*  CloseHandle(shm_handle);*/
+        return mm;
     }
-/*  CloseHandle(shm_handle);*/
-    return mm;
-  }
-  return (MM*)-1;
+    return (MM*)-1;
 }
 
-static MM* mm_create_shm(const char* key, size_t size) {
-  HANDLE  shm_handle;
-  MM*     mm;
-  MM**    addr_ptr;
-  char    s[MAXPATHLEN];
-  char*   ch;
+static MM* mm_create_shm(const char* key, size_t size)
+{
+    HANDLE  shm_handle;
+    MM*     mm;
+    MM**    addr_ptr;
+    char    s[MAXPATHLEN];
+    char*   ch;
 
 
-  strcpy(s,key);
-  for (ch = s; *ch; ++ch) {
-    if (*ch == ':' || *ch == '/' || *ch == '\\') {
-      *ch = '_';
+    strcpy(s,key);
+    for (ch = s; *ch; ++ch) {
+        if (*ch == ':' || *ch == '/' || *ch == '\\') {
+            *ch = '_';
+        }
     }
-  }
 
-  shm_handle = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, size, s);
-  if (!shm_handle) {
-    return (MM*)-1;
-  }
-  mm = (MM*)MapViewOfFileEx(shm_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0, NULL);
-  if (mm == NULL) {
-    return (MM*)-1;
-  }
-  addr_ptr = (MM**)(((char*)mm)+sizeof(MM));
-  *addr_ptr = mm;
-  mm->size = size;
-  mm->start = ((char*)mm)+sizeof(MM)+sizeof(void*);
+    shm_handle = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, size, s);
+    if (!shm_handle) {
+        return (MM*)-1;
+    }
+    mm = (MM*)MapViewOfFileEx(shm_handle, FILE_MAP_ALL_ACCESS, 0, 0, 0, NULL);
+    if (mm == NULL) {
+        return (MM*)-1;
+    }
+    addr_ptr = (MM**)(((char*)mm)+sizeof(MM));
+    *addr_ptr = mm;
+    mm->size = size;
+    mm->start = ((char*)mm)+sizeof(MM)+sizeof(void*);
 
-/*  CloseHandle(shm_handle);*/
-  return mm;
+    /*  CloseHandle(shm_handle);*/
+    return mm;
 }
 
-static void mm_destroy_shm(MM* mm) {
-  UnmapViewOfFile(mm);
+static void mm_destroy_shm(MM* mm)
+{
+    UnmapViewOfFile(mm);
 }
 
 /* ######################################################################### */
@@ -995,18 +1086,20 @@
 
 #define MM_SHM_TYPE "malloc"
 
-static void* mm_create_shm(const char* key, size_t size) {
-  MM* p = (MM*)malloc(sizeof(MM));
-  if (p == NULL) {
-    return (MM*)-1;
-  }
-  p->size  = size;
-  p->start = NULL;
-  return p;
+static void* mm_create_shm(const char* key, size_t size)
+{
+    MM* p = (MM*)malloc(sizeof(MM));
+    if (p == NULL) {
+        return (MM*)-1;
+    }
+    p->size  = size;
+    p->start = NULL;
+    return p;
 }
 
-static void mm_destroy_shm(MM* mm) {
-  free(mm);
+static void mm_destroy_shm(MM* mm)
+{
+    free(mm);
 }
 
 /* ######################################################################### */
@@ -1017,368 +1110,379 @@
 #endif
 
 #ifdef MM_SHM_MALLOC
-static void mm_init(MM* mm) {
-  mm->available = mm->size - sizeof(MM);
-  mm->lock = malloc(sizeof(mm_mutex));
-}
-
-void* mm_malloc_nolock(MM* mm, size_t size) {
-  if (size > 0) {
-    mm_mem_head *p = NULL;
-    if (mm->available >= MM_SIZE(size)) {
-      p = malloc(MM_SIZE(size));
-      if (p != NULL) {
-        p->size = MM_SIZE(size);
-        mm->available -= MM_SIZE(size);
-      }
-    }
-    if (p != NULL) {
-      return HEAD_TO_PTR(p);
+static void mm_init(MM* mm)
+{
+    mm->available = mm->size - sizeof(MM);
+    mm->lock = malloc(sizeof(mm_mutex));
+}
+
+void* mm_malloc_nolock(MM* mm, size_t size)
+{
+    if (size > 0) {
+        mm_mem_head *p = NULL;
+        if (mm->available >= MM_SIZE(size)) {
+            p = malloc(MM_SIZE(size));
+            if (p != NULL) {
+                p->size = MM_SIZE(size);
+                mm->available -= MM_SIZE(size);
+            }
+        }
+        if (p != NULL) {
+            return HEAD_TO_PTR(p);
+        }
     }
-  }
-  return NULL;
+    return NULL;
 }
 
-void mm_free_nolock(MM* mm, void* x) {
-  if (x != NULL) {
-    mm_mem_head *p;
-    p = PTR_TO_HEAD(x);
-    mm->available += p->size;
-    free(p);
-  }
+void mm_free_nolock(MM* mm, void* x)
+{
+    if (x != NULL) {
+        mm_mem_head *p;
+        p = PTR_TO_HEAD(x);
+        mm->available += p->size;
+        free(p);
+    }
 }
 
-size_t mm_maxsize(MM* mm) {
-  size_t ret;
-  if (!mm_lock(mm, MM_LOCK_RD)) {
-    return 0;
-  }
-  ret = mm->available - MM_SIZE(0);
-  mm_unlock(mm);
-  return ret;
+size_t mm_maxsize(MM* mm)
+{
+    size_t ret;
+    if (!mm_lock(mm, MM_LOCK_RD)) {
+        return 0;
+    }
+    ret = mm->available - MM_SIZE(0);
+    mm_unlock(mm);
+    return ret;
 }
 
 #else
-static void mm_init(MM* mm) {
-  mm->start = MM_ALIGN(mm->start);
-  mm->attach_addr = (void*)mm;
-  mm->lock = mm->start;
-  mm->start = MM_ALIGN((void*)(((char*)(mm->start)) + sizeof(mm_mutex)));
-  mm->available = mm->size - (((char*)(mm->start))-(char*)mm);
-  mm->free_list = (mm_free_bucket*)mm->start;
-  mm->free_list->size = mm->available;
-  mm->free_list->next = NULL;
+static void mm_init(MM* mm)
+{
+    mm->start = MM_ALIGN(mm->start);
+    mm->attach_addr = (void*)mm;
+    mm->lock = mm->start;
+    mm->start = MM_ALIGN((void*)(((char*)(mm->start)) + sizeof(mm_mutex)));
+    mm->available = mm->size - (((char*)(mm->start))-(char*)mm);
+    mm->free_list = (mm_free_bucket*)mm->start;
+    mm->free_list->size = mm->available;
+    mm->free_list->next = NULL;
 }
 
-void* mm_malloc_nolock(MM* mm, size_t size) {
-  if (size > 0) {
-    mm_mem_head* x = NULL;
-    size_t realsize = (size_t)MM_ALIGN(MM_SIZE(size));
+void* mm_malloc_nolock(MM* mm, size_t size)
+{
+    if (size > 0) {
+        mm_mem_head* x = NULL;
+        size_t realsize = (size_t)MM_ALIGN(MM_SIZE(size));
 #if MM_CHECK
-    realsize += (size_t)MM_ALIGN(sizeof(int));
+        realsize += (size_t)MM_ALIGN(sizeof(int));
 #endif
-    if (realsize <= mm->available) {
-      /* Search for free bucket */
-      mm_free_bucket* p = mm->free_list;
-      mm_free_bucket* q = NULL;
-      mm_free_bucket* best = NULL;
-      mm_free_bucket* best_prev = NULL;
-      while (p != NULL) {
-        if (p->size == realsize) {
-          /* Found free bucket with the same size */
-          if (q == NULL) {
-            mm->free_list = p->next;
-            x = (mm_mem_head*)p;
-          } else {
-            q->next = p->next;
-            x = (mm_mem_head*)p;
-          }
-          break;
-        } else if (p->size > realsize && (best == NULL || best->size > p->size)) {
-          /* Found best bucket (smallest bucket with the bigger size) */
-          best = p;
-          best_prev = q;
-        }
-        q = p;
-        p = p->next;
-      }
-      if (x == NULL && best != NULL) {
-        if (best->size-realsize < sizeof(mm_free_bucket)) {
-          realsize = best->size;
-          x = (mm_mem_head*)best;
-          if (best_prev == NULL) {
-            mm->free_list = best->next;
-          } else {
-            best_prev->next = best->next;
-          }
-        } else {
-          if (best_prev == NULL) {
-            mm->free_list = (mm_free_bucket*)((char*)best + realsize);
-            mm->free_list->size = best->size-realsize;
-            mm->free_list->next = best->next;
-          } else {
-            best_prev->next = (mm_free_bucket*)((char*)best + realsize);
-            best_prev->next->size = best->size-realsize;
-            best_prev->next->next = best->next;
-          }
-          best->size = realsize;
-          x = (mm_mem_head*)best;
+        if (realsize <= mm->available) {
+            /* Search for free bucket */
+            mm_free_bucket* p = mm->free_list;
+            mm_free_bucket* q = NULL;
+            mm_free_bucket* best = NULL;
+            mm_free_bucket* best_prev = NULL;
+            while (p != NULL) {
+                if (p->size == realsize) {
+                    /* Found free bucket with the same size */
+                    if (q == NULL) {
+                        mm->free_list = p->next;
+                        x = (mm_mem_head*)p;
+                    } else {
+                        q->next = p->next;
+                        x = (mm_mem_head*)p;
+                    }
+                    break;
+                } else if (p->size > realsize && (best == NULL || best->size > p->size)) {
+                    /* Found best bucket (smallest bucket with the bigger size) */
+                    best = p;
+                    best_prev = q;
+                }
+                q = p;
+                p = p->next;
+            }
+            if (x == NULL && best != NULL) {
+                if (best->size-realsize < sizeof(mm_free_bucket)) {
+                    realsize = best->size;
+                    x = (mm_mem_head*)best;
+                    if (best_prev == NULL) {
+                        mm->free_list = best->next;
+                    } else {
+                        best_prev->next = best->next;
+                    }
+                } else {
+                    if (best_prev == NULL) {
+                        mm->free_list = (mm_free_bucket*)((char*)best + realsize);
+                        mm->free_list->size = best->size-realsize;
+                        mm->free_list->next = best->next;
+                    } else {
+                        best_prev->next = (mm_free_bucket*)((char*)best + realsize);
+                        best_prev->next->size = best->size-realsize;
+                        best_prev->next->next = best->next;
+                    }
+                    best->size = realsize;
+                    x = (mm_mem_head*)best;
+                }
+            }
+            if (x != NULL) {
+                mm->available -= realsize;
+            }
         }
-      }
-      if (x != NULL) {
-        mm->available -= realsize;
-      }
-    }
-    if (x != NULL) {
+        if (x != NULL) {
 #ifdef MM_CHECK
-      *(int *)((char *)x + realsize - (size_t)MM_ALIGN(sizeof(int))) = MM_PATTERN;
+            *(int *)((char *)x + realsize - (size_t)MM_ALIGN(sizeof(int))) = MM_PATTERN;
 #endif
-      return HEAD_TO_PTR(x);
+            return HEAD_TO_PTR(x);
+        }
     }
-  }
-  return NULL;
+    return NULL;
 }
 
-void mm_free_nolock(MM* mm, void* x) {
-  if (x != NULL) {
-    if (x >= mm->start && x < (void*)((char*)mm + mm->size)) {
-      mm_mem_head *p = PTR_TO_HEAD(x);
-      size_t size = p->size;
-      if ((char*)p+size <= (char*)mm + mm->size) {
-        mm_free_bucket* b = (mm_free_bucket*)p;
-        b->next = NULL;
-        if (mm->free_list == NULL) {
-          mm->free_list = b;
-        } else {
-          mm_free_bucket* q = mm->free_list;
-          mm_free_bucket* prev = NULL;
-          mm_free_bucket* next = NULL;
-          while (q != NULL) {
-            if (b < q) {
-              next = q;
-              break;
-            }
-            prev = q;
-            q = q->next;
-          }
-          if (prev != NULL && (char*)prev+prev->size == (char*)b) {
-            if ((char*)next == (char*)b+size) {
-              /* merging with prev and next */
-              prev->size += size + next->size;
-              prev->next = next->next;
-            } else {
-              /* merging with prev */
-              prev->size += size;
-            }
-          } else {
-            if ((char*)next == (char*)b+size) {
-              /* merging with next */
-              b->size += next->size;
-              b->next = next->next;
-            } else {
-              /* don't merge */
-              b->next = next;
-            }
-            if (prev != NULL) {
-              prev->next = b;
-            } else {
-              mm->free_list = b;
+void mm_free_nolock(MM* mm, void* x)
+{
+    if (x != NULL) {
+        if (x >= mm->start && x < (void*)((char*)mm + mm->size)) {
+            mm_mem_head *p = PTR_TO_HEAD(x);
+            size_t size = p->size;
+            if ((char*)p+size <= (char*)mm + mm->size) {
+                mm_free_bucket* b = (mm_free_bucket*)p;
+                b->next = NULL;
+                if (mm->free_list == NULL) {
+                    mm->free_list = b;
+                } else {
+                    mm_free_bucket* q = mm->free_list;
+                    mm_free_bucket* prev = NULL;
+                    mm_free_bucket* next = NULL;
+                    while (q != NULL) {
+                        if (b < q) {
+                            next = q;
+                            break;
+                        }
+                        prev = q;
+                        q = q->next;
+                    }
+                    if (prev != NULL && (char*)prev+prev->size == (char*)b) {
+                        if ((char*)next == (char*)b+size) {
+                            /* merging with prev and next */
+                            prev->size += size + next->size;
+                            prev->next = next->next;
+                        } else {
+                            /* merging with prev */
+                            prev->size += size;
+                        }
+                    } else {
+                        if ((char*)next == (char*)b+size) {
+                            /* merging with next */
+                            b->size += next->size;
+                            b->next = next->next;
+                        } else {
+                            /* don't merge */
+                            b->next = next;
+                        }
+                        if (prev != NULL) {
+                            prev->next = b;
+                        } else {
+                            mm->free_list = b;
+                        }
+                    }
+                }
+                mm->available += size;
             }
-          }
         }
-        mm->available += size;
-      }
     }
-  }
 }
 
-size_t mm_maxsize(MM* mm) {
-  size_t ret = MM_SIZE(0);
-  mm_free_bucket* p;
-  if (!mm_lock(mm, MM_LOCK_RD)) {
-    return 0;
-  }
-  p = mm->free_list;
-  while (p != NULL) {
-    if (p->size > ret) {
-      ret = p->size;
-    }
-    p = p->next;
-  }
-  mm_unlock(mm);
-  return ret - MM_SIZE(0);
+size_t mm_maxsize(MM* mm)
+{
+    size_t ret = MM_SIZE(0);
+    mm_free_bucket* p;
+    if (!mm_lock(mm, MM_LOCK_RD)) {
+        return 0;
+    }
+    p = mm->free_list;
+    while (p != NULL) {
+        if (p->size > ret) {
+            ret = p->size;
+        }
+        p = p->next;
+    }
+    mm_unlock(mm);
+    return ret - MM_SIZE(0);
 }
 #endif
 
-void* mm_malloc_lock(MM* mm, size_t size) {
-  void *ret;
-  if (!mm_lock(mm, MM_LOCK_RW)) {
-    return NULL;
-  }
-  ret = mm_malloc_nolock(mm,size);
-  mm_unlock(mm);
-  return ret;
+void* mm_malloc_lock(MM* mm, size_t size)
+{
+    void *ret;
+    if (!mm_lock(mm, MM_LOCK_RW)) {
+        return NULL;
+    }
+    ret = mm_malloc_nolock(mm,size);
+    mm_unlock(mm);
+    return ret;
 }
 
-void mm_free_lock(MM* mm, void* x) {
-  mm_lock(mm, MM_LOCK_RW);
-  mm_free_nolock(mm,x);
-  mm_unlock(mm);
+void mm_free_lock(MM* mm, void* x)
+{
+    mm_lock(mm, MM_LOCK_RW);
+    mm_free_nolock(mm,x);
+    mm_unlock(mm);
 }
 
-void mm_set_attach(MM* mm, void* attach_addr) {
-  mm->attach_addr = attach_addr;
+void mm_set_attach(MM* mm, void* attach_addr)
+{
+    mm->attach_addr = attach_addr;
 }
 
-void* mm_attach(size_t size, const char* key) {
+void* mm_attach(size_t size, const char* key)
+{
 #ifdef MM_SHM_CAN_ATTACH
-  MM* mm = mm_attach_shm(key, size);
-  if (mm == (MM*)-1) {
-    return NULL;
-  }
+    MM* mm = mm_attach_shm(key, size);
+    if (mm == (MM*)-1) {
+        return NULL;
+    }
 #ifdef MM_SEM_CAN_ATTACH
-  if (!mm_attach_lock(key, mm->lock)) {
-    mm_destroy_shm(mm);
-    return NULL;
-  }
+    if (!mm_attach_lock(key, mm->lock)) {
+        mm_destroy_shm(mm);
+        return NULL;
+    }
 #endif
-  return mm->attach_addr;
+    return mm->attach_addr;
 #else
-  return NULL;
+    return NULL;
 #endif
 }
 
-MM* mm_create(size_t size, const char* key) {
-  MM* p;
-  if (size == 0) {
-    size = 32 * 1024 * 1024;
-  }
-  p = mm_create_shm(key, size);
-  if (p == (MM*)-1) {
-    return NULL;
-  }
-  mm_init(p);
-  if (p->lock == NULL) {
-    mm_destroy_shm(p);
-    return NULL;
-  }
-  if (!mm_init_lock(key, p->lock)) {
-    mm_destroy_shm(p);
-    return NULL;
-  }
-  return p;
+MM* mm_create(size_t size, const char* key)
+{
+    MM* p;
+    if (size == 0) {
+        size = 32 * 1024 * 1024;
+    }
+    p = mm_create_shm(key, size);
+    if (p == (MM*)-1) {
+        return NULL;
+    }
+    mm_init(p);
+    if (p->lock == NULL) {
+        mm_destroy_shm(p);
+        return NULL;
+    }
+    if (!mm_init_lock(key, p->lock)) {
+        mm_destroy_shm(p);
+        return NULL;
+    }
+    return p;
 }
 
-void mm_destroy(MM* mm) {
-  if (mm != NULL) {
-    mm_destroy_lock(mm->lock);
-    mm_destroy_shm(mm);
-  }
+void mm_destroy(MM* mm)
+{
+    if (mm != NULL) {
+        mm_destroy_lock(mm->lock);
+        mm_destroy_shm(mm);
+    }
 }
 
-size_t mm_size(MM* mm) {
-  if (mm != NULL) {
-    return mm->size;
-  }
-  return 0;
+size_t mm_size(MM* mm)
+{
+    if (mm != NULL) {
+        return mm->size;
+    }
+    return 0;
 }
 
-size_t mm_sizeof(MM* mm, void* x) {
-  mm_mem_head *p;
-  size_t ret;
-  if (mm == NULL || x == NULL || !mm_lock(mm, MM_LOCK_RD)) {
+size_t mm_sizeof(MM* mm, void* x)
+{
+    mm_mem_head *p;
+    size_t ret;
+    if (mm == NULL || x == NULL || !mm_lock(mm, MM_LOCK_RD)) {
+        return 0;
+    }
+    p = PTR_TO_HEAD(x);
+    ret = p->size;
+    mm_unlock(mm);
+    return ret;
+}
+
+size_t mm_available(MM* mm)
+{
+    size_t available;
+    if (mm != NULL && mm_lock(mm, MM_LOCK_RD)) {
+        available = mm->available;
+        mm_unlock(mm);
+        return available;
+    }
     return 0;
-  }
-  p = PTR_TO_HEAD(x);
-  ret = p->size;
-  mm_unlock(mm);
-  return ret;
 }
 
-size_t mm_available(MM* mm) {
-  size_t available;
-  if (mm != NULL && mm_lock(mm, MM_LOCK_RD)) {
-    available = mm->available;
-    mm_unlock(mm);
-    return available;
-  }
-  return 0;
-}
-
-const char* mm_shm_type() {
-  return MM_SHM_TYPE;
-}
-
-const char* mm_sem_type() {
-  return MM_SEM_TYPE;
-}
-
-int mm_protect(MM* mm, int mode) {
-#ifdef HAVE_MPROTECT
-  int pmode = 0;
-  if (mode & MM_PROT_NONE) {
-    pmode |= PROT_NONE;
-  }
-  if (mode & MM_PROT_READ) {
-    pmode |= PROT_READ;
-  }
-  if (mode & MM_PROT_WRITE) {
-    pmode |= PROT_WRITE;
-  }
-  if (mode & MM_PROT_EXEC) {
-    pmode |= PROT_EXEC;
-  }
-  return (mprotect(mm, mm->size, pmode) == 0);
-#endif
-  return 0;
+const char* mm_shm_type()
+{
+    return MM_SHM_TYPE;
+}
+
+const char* mm_sem_type()
+{
+    return MM_SEM_TYPE;
 }
 
 #if defined(MM_CHECK) && !(defined(MM_TEST_SHM) || defined(MM_TEST_SEM))
-void mm_check_mem(void *x) {
-  mm_mem_head *p = PTR_TO_HEAD(x);
-  if (*((unsigned int *)((char *)p + p->size - (size_t)MM_ALIGN(sizeof(int)))) != MM_PATTERN) {
-    ea_debug_error("[EACCELERATOR] Corrupted memory detected\n");
-  }
+void mm_check_mem(void *x)
+{
+    mm_mem_head *p = PTR_TO_HEAD(x);
+    if (*((unsigned int *)((char *)p + p->size - (size_t)MM_ALIGN(sizeof(int)))) != MM_PATTERN) {
+        ea_debug_error("[EACCELERATOR] Corrupted memory detected\n");
+    }
 }
 #else
 void mm_check_mem(void *x) {}
 #endif
 
 #ifdef MM_TEST_SHM
-int main() {
-  char key[] = "/tmp/mm";
-  size_t size = 32*1024*1024;
-  MM *mm = mm_create(size, key);
-  if (mm == NULL) {
-    return 1;
-  }
-  mm_destroy(mm);
-  return 0;
+int main()
+{
+    char key[] = "/tmp/mm";
+    size_t size = 32*1024*1024;
+    MM *mm = mm_create(size, key);
+    if (mm == NULL) {
+        return 1;
+    }
+    mm_destroy(mm);
+    return 0;
 }
 #endif
 
 #ifdef MM_TEST_SEM
-int main() {
-  int ret = 0;
-  char key[] = "/tmp/mm";
-  size_t size = 1*1024*1024;
-  MM *mm = mm_create(size, key);
-  if (mm == NULL) {
-    return 1;
-  }
-  if (!mm_lock(mm, MM_LOCK_RW)) {
-    ret = 1;
-  }
-  if (!mm_unlock(mm)) {
-    ret = 1;
-  }
-  if (!mm_lock(mm, MM_LOCK_RD)) {
-    ret = 1;
-  }
-  if (!mm_unlock(mm)) {
-    ret = 1;
-  }
-  mm_destroy(mm);
-  return ret;
+int main()
+{
+    int ret = 0;
+    char key[] = "/tmp/mm";
+    size_t size = 1*1024*1024;
+    MM *mm = mm_create(size, key);
+    if (mm == NULL) {
+        return 1;
+    }
+    if (!mm_lock(mm, MM_LOCK_RW)) {
+        ret = 1;
+    }
+    if (!mm_unlock(mm)) {
+        ret = 1;
+    }
+    if (!mm_lock(mm, MM_LOCK_RD)) {
+        ret = 1;
+    }
+    if (!mm_unlock(mm)) {
+        ret = 1;
+    }
+    mm_destroy(mm);
+    return ret;
 }
 #endif
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/mm.h patched/mm.h
--- orig/mm.h	2010-01-19 17:49:49.000000000 +0100
+++ patched/mm.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -46,33 +46,31 @@
 #define MM_LOCK_RW 1
 #define MM_LOCK_RD 0
 
-MM*    _mm_create(size_t size, const char* key);
-void   _mm_set_attach(MM* mm, void* attach_addr);
-void*  _mm_attach(size_t size, const char* key);
-size_t _mm_size(MM* mm);
-void   _mm_destroy(MM* mm);
-int    _mm_lock(MM* mm, int kind);
-int    _mm_unlock(MM* mm);
-size_t _mm_available(MM* mm);
-size_t _mm_maxsize(MM* mm);
-void*  _mm_malloc_lock(MM* mm, size_t size);
-void   _mm_free_lock(MM* mm, void* p);
-void*  _mm_malloc_nolock(MM* mm, size_t size);
-void   _mm_free_nolock(MM* mm, void* p);
-size_t _mm_sizeof(MM* mm, void* x);
-
-
-const char* mm_shm_type();
-const char* mm_sem_type();
-void mm_check_mem(void *x);
+    MM*    _mm_create(size_t size, const char* key);
+    void   _mm_set_attach(MM* mm, void* attach_addr);
+    void*  _mm_attach(size_t size, const char* key);
+    size_t _mm_size(MM* mm);
+    void   _mm_destroy(MM* mm);
+    int    _mm_lock(MM* mm, int kind);
+    int    _mm_unlock(MM* mm);
+    size_t _mm_available(MM* mm);
+    size_t _mm_maxsize(MM* mm);
+    void*  _mm_malloc_lock(MM* mm, size_t size);
+    void   _mm_free_lock(MM* mm, void* p);
+    void*  _mm_malloc_nolock(MM* mm, size_t size);
+    void   _mm_free_nolock(MM* mm, void* p);
+    size_t _mm_sizeof(MM* mm, void* x);
+
+
+    const char* mm_shm_type();
+    const char* mm_sem_type();
+    void mm_check_mem(void *x);
 
 #define MM_PROT_NONE  1
 #define MM_PROT_READ  2
 #define MM_PROT_WRITE 4
 #define MM_PROT_EXEC  8
 
-int mm_protect(MM* mm, int mode);
-
 #define mm_create(A, B)        _mm_create(A, B)
 #define mm_set_attach(A, B)    _mm_set_attach(A, B)
 #define mm_attach(A, B)        _mm_attach(A, B)
@@ -93,3 +91,12 @@
 #endif
 
 #endif
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/opcodes.c patched/opcodes.c
--- orig/opcodes.c	2010-02-25 11:56:33.000000000 +0100
+++ patched/opcodes.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.sourceforge.net                                  |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id: opcodes.c 412 2010-02-25 10:56:33Z hans $
+   $Id: opcodes.c 411 2010-02-25 10:54:31Z hans $
 */
 
 #include "opcodes.h"
@@ -35,199 +35,255 @@
 #  define OPDEF(NAME, OPS) {OPS}
 #endif
 
-#  define OP1_VAR_2 OP1_STD
-
 #define LAST_OPCODE (sizeof(opcodes)/sizeof(opcodes[0]))
 
 static const opcode_dsc opcodes[] = {
-  OPDEF("NOP",                       EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 0 */
-  OPDEF("ADD",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 1 */
-  OPDEF("SUB",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 2 */
-  OPDEF("MUL",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 3 */
-  OPDEF("DIV",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 4 */
-  OPDEF("MOD",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 5 */
-  OPDEF("SL",                        EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 6 */
-  OPDEF("SR",                        EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 7 */
-  OPDEF("CONCAT",                    EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 8 */
-  OPDEF("BW_OR",                     EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 9 */
-  OPDEF("BW_AND",                    EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 10 */
-  OPDEF("BW_XOR",                    EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 11 */
-  OPDEF("BW_NOT",                    EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP), /* 12 */
-  OPDEF("BOOL_NOT",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 13 */
-  OPDEF("BOOL_XOR",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 14 */
-  OPDEF("IS_IDENTICAL",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 15 */
-  OPDEF("IS_NOT_IDENTICAL",          EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 16 */
-  OPDEF("IS_EQUAL",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 17 */
-  OPDEF("IS_NOT_EQUAL",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 18 */
-  OPDEF("IS_SMALLER",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 19 */
-  OPDEF("IS_SMALLER_OR_EQUAL",       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 20 */
-  OPDEF("CAST",                      EXT_CAST   | OP1_STD    | OP2_UNUSED | RES_TMP), /* 21 */
-  OPDEF("QM_ASSIGN",                 EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP), /* 22 */
-  OPDEF("ASSIGN_ADD",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 23 */
-  OPDEF("ASSIGN_SUB",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 24 */
-  OPDEF("ASSIGN_MUL",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 25 */
-  OPDEF("ASSIGN_DIV",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 26 */
-  OPDEF("ASSIGN_MOD",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 27 */
-  OPDEF("ASSIGN_SL",                 EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 28 */
-  OPDEF("ASSIGN_SR",                 EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 29 */
-  OPDEF("ASSIGN_CONCAT",             EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 30 */
-  OPDEF("ASSIGN_BW_OR",              EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 31 */
-  OPDEF("ASSIGN_BW_AND",             EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 32 */
-  OPDEF("ASSIGN_BW_XOR",             EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 33 */
-  OPDEF("PRE_INC",                   EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_VAR), /* 34 */
-  OPDEF("PRE_DEC",                   EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_VAR), /* 35 */
-  OPDEF("POST_INC",                  EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_TMP), /* 36 */
-  OPDEF("POST_DEC",                  EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_TMP), /* 37 */
-  OPDEF("ASSIGN",                    EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 38 */
-  OPDEF("ASSIGN_REF",                EXT_UNUSED | OP1_VAR    | OP2_VAR    | RES_VAR), /* 39 */
-  OPDEF("ECHO",                      EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 40 */
-  OPDEF("PRINT",                     EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP), /* 41 */
-  OPDEF("JMP",                       EXT_UNUSED | OP1_JMPADDR| OP2_UNUSED | RES_UNUSED), /* 42 */
-  OPDEF("JMPZ",                      EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_UNUSED), /* 43 */
-  OPDEF("JMPNZ",                     EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_UNUSED), /* 44 */
-  OPDEF("JMPZNZ",                    EXT_OPLINE | OP1_STD    | OP2_OPLINE | RES_UNUSED), /* 45 */
-  OPDEF("JMPZ_EX",                   EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_TMP), /* 46 */
-  OPDEF("JMPNZ_EX",                  EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_TMP), /* 47 */
-  OPDEF("CASE",                      EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 48 */
-  OPDEF("SWITCH_FREE",               EXT_BIT    | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 49 */
-  OPDEF("BRK",                       EXT_UNUSED | OP1_BRK    | OP2_STD    | RES_UNUSED), /* 50 */
-  OPDEF("CONT",                      EXT_UNUSED | OP1_CONT   | OP2_STD    | RES_UNUSED), /* 51 */
-  OPDEF("BOOL",                      EXT_UNUSED | OPS_STD    | OP2_UNUSED | RES_TMP), /* 52 */
-  OPDEF("INIT_STRING",               EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_TMP), /* 53 */
-  OPDEF("ADD_CHAR",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 54 */
-  OPDEF("ADD_STRING",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 55 */
-  OPDEF("ADD_VAR",                   EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 56 */
-  OPDEF("BEGIN_SILENCE",             EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_TMP), /* 57 */
-  OPDEF("END_SILENCE",               EXT_UNUSED | OP1_TMP    | OP2_UNUSED | RES_UNUSED), /* 58 */
-  OPDEF("INIT_FCALL_BY_NAME",        EXT_INIT_FCALL | OP1_STD | OP2_STD   | RES_UNUSED), /* 59 */
-  OPDEF("DO_FCALL",                  EXT_FCALL  | OP1_STD    | OP2_OPLINE | RES_VAR), /* 60 */
-  OPDEF("DO_FCALL_BY_NAME",          EXT_FCALL  | OP1_STD    | OP2_OPLINE | RES_VAR), /* 61 */
-  OPDEF("RETURN",                    EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 62 */
-  OPDEF("RECV",                      EXT_UNUSED | OP1_ARG    | OP2_UNUSED | RES_VAR), /* 63 */
-  OPDEF("RECV_INIT",                 EXT_UNUSED | OP1_ARG    | OP2_STD    | RES_VAR), /* 64 */
-  OPDEF("SEND_VAL",                  EXT_SEND   | OP1_STD    | OP2_ARG    | RES_UNUSED), /* 65 */
-  OPDEF("SEND_VAR",                  EXT_SEND   | OP1_VAR    | OP2_ARG    | RES_UNUSED), /* 66 */
-  OPDEF("SEND_REF",                  EXT_SEND   | OP1_VAR    | OP2_ARG    | RES_UNUSED), /* 67 */
-  OPDEF("NEW",                       EXT_UNUSED | OP1_CLASS  | OP2_UNUSED | RES_VAR), /* 68 */
+    OPDEF("NOP",                       EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 0 */
+    OPDEF("ADD",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 1 */
+    OPDEF("SUB",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 2 */
+    OPDEF("MUL",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 3 */
+    OPDEF("DIV",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 4 */
+    OPDEF("MOD",                       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 5 */
+    OPDEF("SL",                        EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 6 */
+    OPDEF("SR",                        EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 7 */
+    OPDEF("CONCAT",                    EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 8 */
+    OPDEF("BW_OR",                     EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 9 */
+    OPDEF("BW_AND",                    EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 10 */
+    OPDEF("BW_XOR",                    EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 11 */
+    OPDEF("BW_NOT",                    EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP), /* 12 */
+    OPDEF("BOOL_NOT",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 13 */
+    OPDEF("BOOL_XOR",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 14 */
+    OPDEF("IS_IDENTICAL",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 15 */
+    OPDEF("IS_NOT_IDENTICAL",          EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 16 */
+    OPDEF("IS_EQUAL",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 17 */
+    OPDEF("IS_NOT_EQUAL",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 18 */
+    OPDEF("IS_SMALLER",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 19 */
+    OPDEF("IS_SMALLER_OR_EQUAL",       EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 20 */
+    OPDEF("CAST",                      EXT_CAST   | OP1_STD    | OP2_UNUSED | RES_TMP), /* 21 */
+    OPDEF("QM_ASSIGN",                 EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP), /* 22 */
+    OPDEF("ASSIGN_ADD",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 23 */
+    OPDEF("ASSIGN_SUB",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 24 */
+    OPDEF("ASSIGN_MUL",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 25 */
+    OPDEF("ASSIGN_DIV",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 26 */
+    OPDEF("ASSIGN_MOD",                EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 27 */
+    OPDEF("ASSIGN_SL",                 EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 28 */
+    OPDEF("ASSIGN_SR",                 EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 29 */
+    OPDEF("ASSIGN_CONCAT",             EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 30 */
+    OPDEF("ASSIGN_BW_OR",              EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 31 */
+    OPDEF("ASSIGN_BW_AND",             EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 32 */
+    OPDEF("ASSIGN_BW_XOR",             EXT_ASSIGN | OP1_STD    | OP2_STD    | RES_VAR), /* 33 */
+    OPDEF("PRE_INC",                   EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_VAR), /* 34 */
+    OPDEF("PRE_DEC",                   EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_VAR), /* 35 */
+    OPDEF("POST_INC",                  EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_TMP), /* 36 */
+    OPDEF("POST_DEC",                  EXT_UNUSED | OP1_VAR    | OP2_UNUSED | RES_TMP), /* 37 */
+    OPDEF("ASSIGN",                    EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 38 */
+    OPDEF("ASSIGN_REF",                EXT_UNUSED | OP1_VAR    | OP2_VAR    | RES_VAR), /* 39 */
+    OPDEF("ECHO",                      EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 40 */
+    OPDEF("PRINT",                     EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP), /* 41 */
+    OPDEF("JMP",                       EXT_UNUSED | OP1_JMPADDR| OP2_UNUSED | RES_UNUSED), /* 42 */
+    OPDEF("JMPZ",                      EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_UNUSED), /* 43 */
+    OPDEF("JMPNZ",                     EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_UNUSED), /* 44 */
+    OPDEF("JMPZNZ",                    EXT_OPLINE | OP1_STD    | OP2_OPLINE | RES_UNUSED), /* 45 */
+    OPDEF("JMPZ_EX",                   EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_TMP), /* 46 */
+    OPDEF("JMPNZ_EX",                  EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_TMP), /* 47 */
+    OPDEF("CASE",                      EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 48 */
+    OPDEF("SWITCH_FREE",               EXT_BIT    | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 49 */
+    OPDEF("BRK",                       EXT_UNUSED | OP1_BRK    | OP2_STD    | RES_UNUSED), /* 50 */
+    OPDEF("CONT",                      EXT_UNUSED | OP1_CONT   | OP2_STD    | RES_UNUSED), /* 51 */
+    OPDEF("BOOL",                      EXT_UNUSED | OPS_STD    | OP2_UNUSED | RES_TMP), /* 52 */
+    OPDEF("INIT_STRING",               EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_TMP), /* 53 */
+    OPDEF("ADD_CHAR",                  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 54 */
+    OPDEF("ADD_STRING",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 55 */
+    OPDEF("ADD_VAR",                   EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 56 */
+    OPDEF("BEGIN_SILENCE",             EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_TMP), /* 57 */
+    OPDEF("END_SILENCE",               EXT_UNUSED | OP1_TMP    | OP2_UNUSED | RES_UNUSED), /* 58 */
+    OPDEF("INIT_FCALL_BY_NAME",        EXT_INIT_FCALL | OP1_STD | OP2_STD   | RES_UNUSED), /* 59 */
+    OPDEF("DO_FCALL",                  EXT_FCALL  | OP1_STD    | OP2_UNUSED | RES_VAR), /* 60 */
+    OPDEF("DO_FCALL_BY_NAME",          EXT_FCALL  | OP1_STD    | OP2_UNUSED | RES_VAR), /* 61 */
+    OPDEF("RETURN",                    EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 62 */
+    OPDEF("RECV",                      EXT_UNUSED | OP1_ARG    | OP2_UNUSED | RES_VAR), /* 63 */
+    OPDEF("RECV_INIT",                 EXT_UNUSED | OP1_ARG    | OP2_STD    | RES_VAR), /* 64 */
+    OPDEF("SEND_VAL",                  EXT_SEND   | OP1_STD    | OP2_ARG    | RES_UNUSED), /* 65 */
+    OPDEF("SEND_VAR",                  EXT_SEND   | OP1_VAR    | OP2_ARG    | RES_UNUSED), /* 66 */
+    OPDEF("SEND_REF",                  EXT_SEND   | OP1_VAR    | OP2_ARG    | RES_UNUSED), /* 67 */
+    OPDEF("NEW",                       EXT_UNUSED | OP1_CLASS  | OP2_UNUSED | RES_VAR), /* 68 */
 #ifdef ZEND_ENGINE_2_3
-  OPDEF("INIT_NS_FCALL_BY_NAME",     EXT_STD    | OP1_STD    | OP1_STD    | RES_UNUSED), /* 69 */
+    OPDEF("INIT_NS_FCALL_BY_NAME",     EXT_STD    | OP1_STD    | OP1_STD    | RES_UNUSED), /* 69 */
+#else
+    OPDEF("JMP_NO_CTOR",               EXT_UNUSED | OP1_STD    | OP2_OPLINE | RES_UNUSED), /* 69 */
+#endif
+    OPDEF("FREE",                      EXT_UNUSED | OP1_TMP    | OP2_UNUSED | RES_UNUSED), /* 70 */
+    OPDEF("INIT_ARRAY",                EXT_BIT    | OP1_STD    | OP2_STD    | RES_TMP), /* 71 */
+    OPDEF("ADD_ARRAY_ELEMENT",         EXT_BIT    | OP1_STD    | OP2_STD    | RES_TMP), /* 72 */
+    OPDEF("INCLUDE_OR_EVAL",           EXT_UNUSED | OP1_STD    | OP2_INCLUDE| RES_VAR), /* 73 */
+    OPDEF("UNSET_VAR",                 EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_UNUSED), /* 74 */
+    OPDEF("UNSET_DIM",                 EXT_STD    | OP1_STD    | OP2_STD    | RES_UNUSED), /* 75 */
+    OPDEF("UNSET_OBJ",                 EXT_STD    | OP1_STD    | OP2_STD    | RES_UNUSED), /* 76 */
+    OPDEF("FE_RESET",                  EXT_BIT    | OP1_STD    | OP2_OPLINE | RES_VAR), /* 77 */
+    OPDEF("FE_FETCH",                  EXT_FE     | OP1_STD    | OP2_OPLINE | RES_TMP), /* 78 */
+    OPDEF("EXIT",                      EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 79 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("FETCH_R",                   EXT_FETCHTYPE | OP1_STD | OP2_STD | RES_VAR),    /* 80 */
+#else
+    OPDEF("FETCH_R",                   EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 80 */
+#endif
+    OPDEF("FETCH_DIM_R",               EXT_FETCH  | OP1_VAR    | OP2_STD    | RES_VAR), /* 81 */
+    OPDEF("FETCH_OBJ_R",               EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 82 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("FETCH_W",                   EXT_FETCHTYPE | OP1_STD | OP2_STD    | RES_VAR), /* 83 */
+#else
+    OPDEF("FETCH_W",                   EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 83 */
+#endif
+    OPDEF("FETCH_DIM_W",               EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 84 */
+    OPDEF("FETCH_OBJ_W",               EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 85 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("FETCH_RW",                  EXT_FETCHTYPE | OP1_STD | OP2_STD    | RES_VAR), /* 86 */
+#else
+    OPDEF("FETCH_RW",                  EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 86 */
+#endif
+    OPDEF("FETCH_DIM_RW",              EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 87 */
+    OPDEF("FETCH_OBJ_RW",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 88 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("FETCH_IS",                  EXT_FETCHTYPE | OP1_STD | OP2_STD    | RES_VAR), /* 89 */
+#else
+    OPDEF("FETCH_IS",                  EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 89 */
+#endif
+    OPDEF("FETCH_DIM_IS",              EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 90 */
+    OPDEF("FETCH_OBJ_IS",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 91 */
+#ifdef ZEND_ENGINE_2_4
+    /* TODO: extended_value also contains EXT_FETCHTYPE info in the form of a bitmask 
+             this whole thing needs a serious overhaul... */
+    OPDEF("FETCH_FUNC_ARG",            EXT_ARG    | OP1_STD    | OP2_STD    | RES_VAR), /* 92 */
+#else
+    OPDEF("FETCH_FUNC_ARG",            EXT_ARG    | OP1_STD    | OP2_FETCH  | RES_VAR), /* 92 */
+#endif
+    OPDEF("FETCH_DIM_FUNC_ARG",        EXT_ARG    | OP1_VAR    | OP2_STD    | RES_VAR), /* 93 */
+    OPDEF("FETCH_OBJ_FUNC_ARG",        EXT_ARG    | OP1_STD    | OP2_STD    | RES_VAR), /* 94 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("FETCH_UNSET",               EXT_FETCHTYPE | OP1_STD | OP2_STD    | RES_VAR), /* 95 */
+#else
+    OPDEF("FETCH_UNSET",               EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 95 */
+#endif
+    OPDEF("FETCH_DIM_UNSET",           EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 96 */
+    OPDEF("FETCH_OBJ_UNSET",           EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 97 */
+    OPDEF("FETCH_DIM_TMP_VAR",         EXT_FETCH  | OP1_STD    | OP2_STD    | RES_VAR), /* 98 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("FETCH_CONSTANT",            EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 99 */
 #else
-  OPDEF("JMP_NO_CTOR",               EXT_UNUSED | OP1_STD    | OP2_OPLINE | RES_UNUSED), /* 69 */
+    OPDEF("FETCH_CONSTANT",            EXT_UNUSED | OP1_UCLASS | OP2_STD    | RES_TMP), /* 99 */
 #endif
-  OPDEF("FREE",                      EXT_UNUSED | OP1_TMP    | OP2_UNUSED | RES_UNUSED), /* 70 */
-  OPDEF("INIT_ARRAY",                EXT_BIT    | OP1_STD    | OP2_STD    | RES_TMP), /* 71 */
-  OPDEF("ADD_ARRAY_ELEMENT",         EXT_BIT    | OP1_STD    | OP2_STD    | RES_TMP), /* 72 */
-  OPDEF("INCLUDE_OR_EVAL",           EXT_UNUSED | OP1_STD    | OP2_INCLUDE| RES_VAR), /* 73 */
-  OPDEF("UNSET_VAR",                 EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_UNUSED), /* 74 */
-  OPDEF("UNSET_DIM",                 EXT_STD    | OP1_STD    | OP2_STD    | RES_UNUSED), /* 75 */
-  OPDEF("UNSET_OBJ",                 EXT_STD    | OP1_STD    | OP2_STD    | RES_UNUSED), /* 76 */
-  OPDEF("FE_RESET",                  EXT_BIT    | OP1_STD    | OP2_OPLINE | RES_VAR), /* 77 */
-  OPDEF("FE_FETCH",                  EXT_FE     | OP1_STD    | OP2_OPLINE | RES_TMP), /* 78 */
-  OPDEF("EXIT",                      EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 79 */
-  OPDEF("FETCH_R",                   EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 80 */
-  OPDEF("FETCH_DIM_R",               EXT_FETCH  | OP1_VAR    | OP2_STD    | RES_VAR), /* 81 */
-  OPDEF("FETCH_OBJ_R",               EXT_UNUSED | OP1_VAR_2  | OP2_STD    | RES_VAR), /* 82 */
-  OPDEF("FETCH_W",                   EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 83 */
-  OPDEF("FETCH_DIM_W",               EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 84 */
-  OPDEF("FETCH_OBJ_W",               EXT_UNUSED | OP1_VAR_2  | OP2_STD    | RES_VAR), /* 85 */
-  OPDEF("FETCH_RW",                  EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 86 */
-  OPDEF("FETCH_DIM_RW",              EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 87 */
-  OPDEF("FETCH_OBJ_RW",              EXT_UNUSED | OP1_VAR_2  | OP2_STD    | RES_VAR), /* 88 */
-  OPDEF("FETCH_IS",                  EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 89 */
-  OPDEF("FETCH_DIM_IS",              EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 90 */
-  OPDEF("FETCH_OBJ_IS",              EXT_UNUSED | OP1_VAR_2  | OP2_STD    | RES_VAR), /* 91 */
-  OPDEF("FETCH_FUNC_ARG",            EXT_ARG    | OP1_STD    | OP2_FETCH  | RES_VAR), /* 92 */
-  OPDEF("FETCH_DIM_FUNC_ARG",        EXT_ARG    | OP1_VAR    | OP2_STD    | RES_VAR), /* 93 */
-  OPDEF("FETCH_OBJ_FUNC_ARG",        EXT_ARG    | OP1_VAR_2  | OP2_STD    | RES_VAR), /* 94 */
-  OPDEF("FETCH_UNSET",               EXT_UNUSED | OP1_STD    | OP2_FETCH  | RES_VAR), /* 95 */
-  OPDEF("FETCH_DIM_UNSET",           EXT_UNUSED | OP1_VAR    | OP2_STD    | RES_VAR), /* 96 */
-  OPDEF("FETCH_OBJ_UNSET",           EXT_UNUSED | OP1_VAR_2  | OP2_STD    | RES_VAR), /* 97 */
-  OPDEF("FETCH_DIM_TMP_VAR",         EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 98 */
-  OPDEF("FETCH_CONSTANT",            EXT_UNUSED | OP1_UCLASS | OP2_STD    | RES_TMP), /* 99 */
 #ifdef ZEND_ENGINE_2_3
-  OPDEF("GOTO",                      EXT_STD    | OP1_JMPADDR | OP2_STD    | RES_UNUSED), /* 100 */
+    OPDEF("GOTO",                      EXT_STD    | OP1_JMPADDR | OP2_STD    | RES_UNUSED), /* 100 */
+#else
+    OPDEF("UNDEF-100",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 100 */
+#endif
+    OPDEF("EXT_STMT",                  EXT_STD    | OP1_STD    | OP2_STD    | RES_STD), /* 101 */
+    OPDEF("EXT_FCALL_BEGIN",           EXT_STD    | OP1_STD    | OP2_STD    | RES_STD), /* 102 */
+    OPDEF("EXT_FCALL_END",             EXT_STD    | OP1_STD    | OP2_STD    | RES_STD), /* 103 */
+    OPDEF("EXT_NOP",                   EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 104 */
+    OPDEF("TICKS",                     EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 105 */
+    OPDEF("SEND_VAR_NO_REF",           EXT_SEND_NOREF| OP1_VAR | OP2_ARG    | RES_UNUSED),  /* 106 */
+    OPDEF("CATCH",                     EXT_OPLINE | OP1_CLASS  | OP2_STD    | RES_UNUSED), /* 107 */
+    OPDEF("THROW",                     EXT_UNUSED | OP1_STD    | OP2_OPLINE | RES_UNUSED), /* 108 */
+    OPDEF("FETCH_CLASS",               EXT_FCLASS | OP1_STD    | OP2_STD    | RES_CLASS), /* 109 */
+    OPDEF("CLONE",                     EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_VAR), /* 110 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("RETURN_BY_REF",             EXT_STD    | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 111 */
+#else
+    OPDEF("UNDEF-111",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 111 */
+#endif
+    OPDEF("INIT_METHOD_CALL",          EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 112 */
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("INIT_STATIC_METHOD_CALL",   EXT_UNUSED | OP1_STD    | OP2_STD    | RES_UNUSED), /* 113 */
+#else
+    OPDEF("INIT_STATIC_METHOD_CALL",   EXT_UNUSED | OP1_UCLASS | OP2_STD    | RES_UNUSED), /* 113 */
+#endif
+#ifdef ZEND_ENGINE_2_4
+    OPDEF("ISSET_ISEMPTY_VAR",         EXT_ISSET  | OP1_STD    | OP2_STD    | RES_TMP), /* 114 */
 #else
-  OPDEF("UNDEF-100",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 100 */
+    OPDEF("ISSET_ISEMPTY_VAR",         EXT_ISSET  | OP1_STD    | OP2_FETCH  | RES_TMP), /* 114 */
 #endif
-  OPDEF("EXT_STMT",                  EXT_STD    | OP1_STD    | OP2_STD    | RES_STD), /* 101 */
-  OPDEF("EXT_FCALL_BEGIN",           EXT_STD    | OP1_STD    | OP2_STD    | RES_STD), /* 102 */
-  OPDEF("EXT_FCALL_END",             EXT_STD    | OP1_STD    | OP2_STD    | RES_STD), /* 103 */
-  OPDEF("EXT_NOP",                   EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 104 */
-  OPDEF("TICKS",                     EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 105 */
-  OPDEF("SEND_VAR_NO_REF",           EXT_SEND_NOREF| OP1_VAR | OP2_ARG    | RES_UNUSED),  /* 106 */
-  OPDEF("CATCH",                     EXT_OPLINE | OP1_CLASS  | OP2_STD    | RES_UNUSED), /* 107 */
-  OPDEF("THROW",                     EXT_UNUSED | OP1_STD    | OP2_OPLINE | RES_UNUSED), /* 108 */
-  OPDEF("FETCH_CLASS",               EXT_FCLASS | OP1_STD    | OP2_STD    | RES_CLASS), /* 109 */
-  OPDEF("CLONE",                     EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_VAR), /* 110 */
-
-  OPDEF("UNDEF-111",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 111 */
-
-  OPDEF("INIT_METHOD_CALL",          EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 112 */
-  OPDEF("INIT_STATIC_METHOD_CALL",   EXT_UNUSED | OP1_UCLASS | OP2_STD    | RES_UNUSED), /* 113 */
-  OPDEF("ISSET_ISEMPTY_VAR",         EXT_ISSET  | OP1_STD    | OP2_FETCH  | RES_TMP), /* 114 */
-  OPDEF("ISSET_ISEMPTY_DIM_OBJ",     EXT_ISSET  | OP1_STD    | OP2_STD    | RES_TMP), /* 115 */
-
-  OPDEF("UNDEF-116",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 116 */
-  OPDEF("UNDEF-117",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 117 */
-  OPDEF("UNDEF-118",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 118 */
-  OPDEF("UNDEF-119",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 119 */
-  OPDEF("UNDEF-120",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 120 */
-  OPDEF("UNDEF-121",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 121 */
-  OPDEF("UNDEF-122",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 122 */
-  OPDEF("UNDEF-123",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 123 */
-  OPDEF("UNDEF-124",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 124 */
-  OPDEF("UNDEF-125",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 125 */
-  OPDEF("UNDEF-126",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 126 */
-  OPDEF("UNDEF-127",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 127 */
-  OPDEF("UNDEF-128",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 128 */
-  OPDEF("UNDEF-129",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 129 */
-  OPDEF("UNDEF-130",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 130 */
-  OPDEF("UNDEF-131",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 131 */
-
-  OPDEF("PRE_INC_OBJ",               EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 132 */
-  OPDEF("PRE_DEC_OBJ",               EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 133 */
-  OPDEF("POST_INC_OBJ",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 134 */
-  OPDEF("POST_DEC_OBJ",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 135 */
-  OPDEF("ASSIGN_OBJ",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 136 */
-  OPDEF("OP_DATA",                   EXT_UNUSED | OP1_STD    | OP2_STD    | RES_STD), /* 137 */
-  OPDEF("INSTANCEOF",                EXT_UNUSED | OP1_STD    | OP2_CLASS  | RES_TMP), /* 138 */
-  OPDEF("DECLARE_CLASS",             EXT_UNUSED | OP1_STD    | OP2_STD    | RES_CLASS), /* 139 */
-  OPDEF("DECLARE_INHERITED_CLASS",   EXT_CLASS  | OP1_STD    | OP2_STD    | RES_CLASS), /* 140 */
-  OPDEF("DECLARE_FUNCTION",          EXT_UNUSED | OP1_STD    | OP2_STD    | RES_UNUSED), /* 141 */
-  OPDEF("RAISE_ABSTRACT_ERROR",      EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 142 */
+    OPDEF("ISSET_ISEMPTY_DIM_OBJ",     EXT_ISSET  | OP1_STD    | OP2_STD    | RES_TMP), /* 115 */
+
+    OPDEF("UNDEF-116",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 116 */
+    OPDEF("UNDEF-117",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 117 */
+    OPDEF("UNDEF-118",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 118 */
+    OPDEF("UNDEF-119",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 119 */
+    OPDEF("UNDEF-120",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 120 */
+    OPDEF("UNDEF-121",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 121 */
+    OPDEF("UNDEF-122",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 122 */
+    OPDEF("UNDEF-123",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 123 */
+    OPDEF("UNDEF-124",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 124 */
+    OPDEF("UNDEF-125",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 125 */
+    OPDEF("UNDEF-126",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 126 */
+    OPDEF("UNDEF-127",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 127 */
+    OPDEF("UNDEF-128",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 128 */
+    OPDEF("UNDEF-129",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 129 */
+    OPDEF("UNDEF-130",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 130 */
+    OPDEF("UNDEF-131",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 131 */
+
+    OPDEF("PRE_INC_OBJ",               EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 132 */
+    OPDEF("PRE_DEC_OBJ",               EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 133 */
+    OPDEF("POST_INC_OBJ",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 134 */
+    OPDEF("POST_DEC_OBJ",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP), /* 135 */
+    OPDEF("ASSIGN_OBJ",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR), /* 136 */
+    OPDEF("OP_DATA",                   EXT_UNUSED | OP1_STD    | OP2_STD    | RES_STD), /* 137 */
+    OPDEF("INSTANCEOF",                EXT_UNUSED | OP1_STD    | OP2_CLASS  | RES_TMP), /* 138 */
+    OPDEF("DECLARE_CLASS",             EXT_UNUSED | OP1_STD    | OP2_STD    | RES_CLASS), /* 139 */
+    OPDEF("DECLARE_INHERITED_CLASS",   EXT_CLASS  | OP1_STD    | OP2_STD    | RES_CLASS), /* 140 */
+    OPDEF("DECLARE_FUNCTION",          EXT_UNUSED | OP1_STD    | OP2_STD    | RES_UNUSED), /* 141 */
+    OPDEF("RAISE_ABSTRACT_ERROR",      EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 142 */
 #ifdef ZEND_ENGINE_2_3
-  OPDEF("DECLARE_CONST",             EXT_DECLARE| OP1_STD    | OP2_STD    | RES_UNUSED), /* 143 */
+    OPDEF("DECLARE_CONST",             EXT_DECLARE| OP1_STD    | OP2_STD    | RES_UNUSED), /* 143 */
 #else
-  OPDEF("UNDEF-143",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 143 */
+    OPDEF("UNDEF-143",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 143 */
 #endif
 #ifdef ZEND_ENGINE_2_3
-  OPDEF("ADD_INTERFACE",             EXT_IFACE  | OP1_CLASS  | OP2_STD  | RES_UNUSED), /* 144 */
+    OPDEF("ADD_INTERFACE",             EXT_IFACE  | OP1_CLASS  | OP2_STD  | RES_UNUSED), /* 144 */
 #else
-  OPDEF("ADD_INTERFACE",             EXT_IFACE  | OP1_CLASS  | OP2_CLASS  | RES_UNUSED), /* 144 */
+    OPDEF("ADD_INTERFACE",             EXT_IFACE  | OP1_CLASS  | OP2_CLASS  | RES_UNUSED), /* 144 */
 #endif
 #ifdef ZEND_ENGINE_2_3
-  OPDEF("DECLARE_INHERITED_CLASS_DELAYED",         EXT_CLASS | OP1_STD  | OP2_STD    | RES_OPLINE), /* 145 */
+    OPDEF("DECLARE_INHERITED_CLASS_DELAYED",         EXT_CLASS | OP1_STD  | OP2_STD    | RES_OPLINE), /* 145 */
 #else
-  OPDEF("UNDEF-145",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 145 */
+    OPDEF("UNDEF-145",                 EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 145 */
 #endif
-  OPDEF("VERIFY_ABSTRACT_CLASS",     EXT_UNUSED | OP1_CLASS  | OP2_UNUSED | RES_UNUSED), /* 146 */
-  OPDEF("ASSIGN_DIM",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR),  /* 147 */
-  OPDEF("ISSET_ISEMPTY_PROP_OBJ",    EXT_ISSET  | OP1_STD    | OP2_STD    | RES_TMP), /* 148 */
-  OPDEF("HANDLE_EXCEPTION",          EXT_STD    | OP1_UNUSED | OP2_UNUSED | RES_STD),  /* 149 */
-  OPDEF("USER_OPCODE",               EXT_STD    | OP1_UNUSED | OP2_UNUSED | RES_STD)  /* 150 */
+    OPDEF("VERIFY_ABSTRACT_CLASS",     EXT_UNUSED | OP1_CLASS  | OP2_UNUSED | RES_UNUSED), /* 146 */
+    OPDEF("ASSIGN_DIM",                EXT_UNUSED | OP1_STD    | OP2_STD    | RES_VAR),   /* 147 */
+    OPDEF("ISSET_ISEMPTY_PROP_OBJ",    EXT_ISSET  | OP1_STD    | OP2_STD    | RES_TMP),   /* 148 */
+    OPDEF("HANDLE_EXCEPTION",          EXT_STD    | OP1_UNUSED | OP2_UNUSED | RES_STD),   /* 149 */
+    OPDEF("USER_OPCODE",               EXT_STD    | OP1_UNUSED | OP2_UNUSED | RES_STD)    /* 150 */
 # ifdef ZEND_ENGINE_2_3
-  ,
-  OPDEF("UNDEF-151",                EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 151 */
-  OPDEF("JMP_SET",                  EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_TMP),    /* 152 */
-  OPDEF("DECLARE_LAMBDA_FUNCTION",  EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP)     /* 153 */
+    ,
+    OPDEF("UNDEF-151",                EXT_UNUSED | OP1_UNUSED | OP2_UNUSED | RES_UNUSED), /* 151 */
+    OPDEF("JMP_SET",                  EXT_UNUSED | OP1_STD    | OP2_JMPADDR| RES_TMP),    /* 152 */
+    OPDEF("DECLARE_LAMBDA_FUNCTION",  EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED)  /* 153 */
 # endif
+#ifdef ZEND_ENGINE_2_4
+    ,
+    OPDEF("ADD_TRAIT",                EXT_FCLASS | OP1_STD    | OP2_STD    | RES_UNUSED), /* 154 */
+    OPDEF("BIND_TRAITS",              EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_UNUSED), /* 155 */
+    OPDEF("SEPARATE",                 EXT_UNUSED | OP1_STD    | OP2_STD    | RES_STD),    /* 156 */
+    OPDEF("QM_ASSIGN_VAR",            EXT_UNUSED | OP1_STD    | OP2_UNUSED | RES_TMP),    /* 157 */
+    OPDEF("JMP_SET_VAR",              EXT_UNUSED | OP1_STD    | OP2_STD    | RES_TMP)     /* 158 */
+#endif
 };
 
-const opcode_dsc* get_opcode_dsc(unsigned int n) {
-  if (n < LAST_OPCODE) {
-    return &opcodes[n];
-  } else {
-    return NULL;
-  }
+const opcode_dsc* get_opcode_dsc(unsigned int n)
+{
+    if (n < LAST_OPCODE) {
+        return &opcodes[n];
+    } else {
+        return NULL;
+    }
 }
 #endif
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/opcodes.h patched/opcodes.h
--- orig/opcodes.h	2010-01-20 15:58:03.000000000 +0100
+++ patched/opcodes.h	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -48,6 +48,7 @@
 #define EXT_CLASS      0x00e00
 #define EXT_ASSIGN     0x00f00
 #define EXT_FE         0x01000
+#define EXT_FETCHTYPE  0x01100
 
 #define OP1_MASK       0x000f0
 #define OP1_UNUSED     0x000f0
@@ -85,19 +86,72 @@
 
 #define OPS_STD       EXT_STD | OP1_STD | OP2_STD | RES_STD
 
-#ifdef ZEND_ENGINE_2
-#  define VAR_NUM(var) ((unsigned int)(((temp_variable *)((intptr_t) var))-((temp_variable *)NULL)))
-#  define VAR_VAL(var) ((unsigned int)((var)*sizeof(temp_variable)))
+#define VAR_NUM(var) ((unsigned int)(((temp_variable *)((intptr_t) var))-((temp_variable *)NULL)))
+#define VAR_VAL(var) ((unsigned int)((var)*sizeof(temp_variable)))
+
+#ifdef ZEND_ENGINE_2_4
+#define OP1_TYPE(op) (op)->op1_type
+#define OP2_TYPE(op) (op)->op2_type
+#define RES_TYPE(op) (op)->result_type
+
+/* OP1_VAR/OP2_VAR/RES_VAR already defined above, hence the VARR */
+#define OP1_VARR(op) (op)->op1.var
+#define OP2_VARR(op) (op)->op2.var
+#define RES_VARR(op) (op)->result.var
+
+#define OP1_OPLINE_NUM(op) (op)->op1.opline_num
+#define OP2_OPLINE_NUM(op) (op)->op2.opline_num
+#define RES_OPLINE_NUM(op) (op)->result.opline_num
+
+#define OP1_JMP_ADDR(op) (op)->op1.jmp_addr
+#define OP2_JMP_ADDR(op) (op)->op2.jmp_addr
+#define RES_JMP_ADDR(op) (op)->result.jmp_addr
+
+
+#define OP1_CONST(op) op_array->literals[(op)->op1.constant].constant
+#define OP2_CONST(op) op_array->literals[(op)->op2.constant].constant
+#define RES_CONST(op) op_array->literals[(op)->result.constant].constant
+
+#define OP1_CONST_TYPE(op) OP1_CONST((op)).type
+#define OP2_CONST_TYPE(op) OP2_CONST((op)).type
+#define RES_CONST_TYPE(op) RES_CONST((op)).type
+
+#define RES_USED(op) (op)->result_type
+
 #else
-#  define VAR_NUM(var) ((unsigned int)(var))
-#  define VAR_VAL(var) ((unsigned int)(var))
+
+#define OP1_TYPE(op) (op)->op1.op_type
+#define OP2_TYPE(op) (op)->op2.op_type
+#define RES_TYPE(op) (op)->result.op_type
+
+#define OP1_VARR(op) (op)->op1.u.var
+#define OP2_VARR(op) (op)->op2.u.var
+#define RES_VARR(op) (op)->result.u.var
+
+#define OP1_OPLINE_NUM(op) (op)->op1.u.opline_num
+#define OP2_OPLINE_NUM(op) (op)->op2.u.opline_num
+#define RES_OPLINE_NUM(op) (op)->result.u.opline_num
+
+#define OP1_JMP_ADDR(op) (op)->op1.u.jmp_addr
+#define OP2_JMP_ADDR(op) (op)->op2.u.jmp_addr
+#define RES_JMP_ADDR(op) (op)->result.u.jmp_addr
+
+#define OP1_CONST(op) (op)->op1.u.constant
+#define OP2_CONST(op) (op)->op2.u.constant
+#define RES_CONST(op) (op)->result.u.constant
+
+#define OP1_CONST_TYPE(op) OP1_CONST((op)).type
+#define OP2_CONST_TYPE(op) OP2_CONST((op)).type
+#define RES_CONST_TYPE(op) RES_CONST((op)).type
+
+#define RES_USED(op) (op)->result.u.EA.type
 #endif
 
 typedef struct {
 #ifdef WITH_EACCELERATOR_DISASSEMBLER
-  const char*  opname;
+    const char*  opname;
 #endif
-  unsigned int ops;
+    unsigned int ops;
 } opcode_dsc;
 
 const opcode_dsc* get_opcode_dsc(unsigned int n);
@@ -107,3 +161,12 @@
 #endif
 
 #endif
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/optimize.c patched/optimize.c
--- orig/optimize.c	2010-02-04 17:00:21.000000000 +0100
+++ patched/optimize.c	2012-08-16 15:34:36.000000000 +0200
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | eAccelerator project                                                 |
    +----------------------------------------------------------------------+
-   | Copyright (c) 2004 - 2010 eAccelerator                               |
+   | Copyright (c) 2004 - 2012 eAccelerator                               |
    | http://eaccelerator.net                                              |
    +----------------------------------------------------------------------+
    | This program is free software; you can redistribute it and/or        |
@@ -22,7 +22,7 @@
    |                                                                      |
    | A copy is availble at http://www.gnu.org/copyleft/gpl.txt            |
    +----------------------------------------------------------------------+
-   $Id$
+   $Id: $
 */
 
 #include "eaccelerator.h"
@@ -33,6 +33,9 @@
 #include "zend.h"
 #include "zend_API.h"
 #include "zend_constants.h"
+#ifdef ZEND_ENGINE_2_4
+#include "zend_string.h"
+#endif
 #include "opcodes.h"
 
 #include "debug.h"
@@ -42,325 +45,307 @@
 struct _BBlink;
 
 typedef struct _BB {
-  zend_op*        start;
-  int             len;
-  int             used;
-  /*
-   * HOESH: To protect merging. Primary
-   * it abblies to try & catch blocks.
-   * ZEND_ENGINE_2 specific, but can take place
-   */
-  int             protect_merge;
-  struct _BB*     jmp_1;
-  struct _BB*     jmp_2;
-  struct _BB*     jmp_ext;
-  struct _BB*     follow;
-  struct _BBlink* pred;  // Gonna be a chain of BBs
-  struct _BB*     next;
+    zend_op*        start;
+    unsigned int    len;
+    zend_bool       used;
+    zend_bool       protect_merge;
+
+    struct _BB*     jmp_1;
+    struct _BB*     jmp_2;
+    struct _BB*     jmp_ext;
+    struct _BB*     jmp_tc;
+
+    struct _BB*     follow;
+    struct _BBlink* pred;  // Gonna be a chain of BBs
+    struct _BB*     next;
 } BB;
 
 typedef struct _BBlink {
-  struct _BB*     bb;
-  struct _BBlink* next;
+    struct _BB*     bb;
+    struct _BBlink* next;
 } BBlink;
 
 #ifdef DEBUG
-static void dump_bb(BB* bb, zend_op_array *op_array) {
-  BB* p = bb;
-  BBlink *q;
-  DBG(ea_debug_printf, (EA_DEBUG, "=== CFG FOR %s:%s ===\n", op_array->filename, op_array->function_name));
-  while (p != NULL) {
-    DBG(ea_debug_printf, (EA_DEBUG, "  bb%u start=%u len=%d used=%d\n",
-                 (unsigned int)(p-bb),
-                 (unsigned int)(p->start-op_array->opcodes),
-                 p->len,
-                 p->used));
-    if (p->jmp_1) {
-      DBG(ea_debug_printf, (EA_DEBUG, "    jmp_1 bb%u start=%u  len=%d used=%d\n",
-                  (unsigned int)(p->jmp_1-bb),
-                  (unsigned int)(p->jmp_1->start-op_array->opcodes),
-                  p->jmp_1->len,
-                  p->jmp_1->used));
-    }
-    if (p->jmp_2) {
-      DBG(ea_debug_printf, (EA_DEBUG, "    jmp_2 bb%u start=%u  len=%d used=%d\n",
-                  (unsigned int)(p->jmp_2-bb),
-                  (unsigned int)(p->jmp_2->start-op_array->opcodes),
-                  p->jmp_2->len,
-                  p->jmp_2->used));
-    }
-    if (p->jmp_ext) {
-      DBG(ea_debug_printf, (EA_DEBUG, "    jmp_ext bb%u start=%u  len=%d used=%d\n",
-                  (unsigned int)(p->jmp_ext-bb),
-                  (unsigned int)(p->jmp_ext->start-op_array->opcodes),
-                  p->jmp_ext->len,
-                  p->jmp_ext->used));
-    }
-    if (p->follow) {
-      DBG(ea_debug_printf, (EA_DEBUG, "    follow bb%u start=%u  len=%d used=%d\n",
-                  (unsigned int)(p->follow-bb),
-                  (unsigned int)(p->follow->start-op_array->opcodes),
-                  p->follow->len,
-                  p->follow->used));
-    }
-    q = p->pred;
-    while (q != NULL) {
-      DBG(ea_debug_printf, (EA_DEBUG, "    pred bb%u start=%u  len=%d used=%d (",
-                  (unsigned int)(q->bb-bb),
-                  (unsigned int)(q->bb->start-op_array->opcodes),
-                  q->bb->len,
-                  q->bb->used));
-      if (q->bb->jmp_1 == p) {
-        DBG(ea_debug_printf, (EA_DEBUG, "jmp_1 "));
-      }
-      if (q->bb->jmp_2 == p) {
-        DBG(ea_debug_printf, (EA_DEBUG, "jmp_2 "));
-      }
-      if (q->bb->jmp_ext == p) {
-        DBG(ea_debug_printf, (EA_DEBUG, "jmp_ext "));
-      }
-      if (q->bb->follow == p) {
-        DBG(ea_debug_printf, (EA_DEBUG, "follow "));
-      }
-      DBG(ea_debug_printf, (EA_DEBUG, ")\n"));
-      q = q->next;
+static void dump_bb(BB* bb, zend_op_array *op_array)
+{
+    BB* p = bb;
+    BBlink *q;
+    DBG(ea_debug_printf, (EA_DEBUG, "=== CFG FOR %s:%s ===\n", op_array->filename, op_array->function_name));
+    while (p) {
+        DBG(ea_debug_printf, (EA_DEBUG, "  bb%u start=%u len=%d used=%d\n",
+                              (unsigned int)(p-bb),
+                              (unsigned int)(p->start-op_array->opcodes),
+                              p->len,
+                              p->used));
+        if (p->jmp_1) {
+            DBG(ea_debug_printf, (EA_DEBUG, "    jmp_1 bb%u start=%u  len=%d used=%d\n",
+                                  (unsigned int)(p->jmp_1-bb),
+                                  (unsigned int)(p->jmp_1->start-op_array->opcodes),
+                                  p->jmp_1->len,
+                                  p->jmp_1->used));
+        }
+        if (p->jmp_2) {
+            DBG(ea_debug_printf, (EA_DEBUG, "    jmp_2 bb%u start=%u  len=%d used=%d\n",
+                                  (unsigned int)(p->jmp_2-bb),
+                                  (unsigned int)(p->jmp_2->start-op_array->opcodes),
+                                  p->jmp_2->len,
+                                  p->jmp_2->used));
+        }
+        if (p->jmp_ext) {
+            DBG(ea_debug_printf, (EA_DEBUG, "    jmp_ext bb%u start=%u  len=%d used=%d\n",
+                                  (unsigned int)(p->jmp_ext-bb),
+                                  (unsigned int)(p->jmp_ext->start-op_array->opcodes),
+                                  p->jmp_ext->len,
+                                  p->jmp_ext->used));
+        }
+        if (p->jmp_tc) {
+            DBG(ea_debug_printf, (EA_DEBUG, "    jmp_tc bb%u start=%u  len=%d used=%d\n",
+                                  (unsigned int)(p->jmp_tc-bb),
+                                  (unsigned int)(p->jmp_tc->start-op_array->opcodes),
+                                  p->jmp_tc->len,
+                                  p->jmp_tc->used));
+        }
+        if (p->follow) {
+            DBG(ea_debug_printf, (EA_DEBUG, "    follow bb%u start=%u  len=%d used=%d\n",
+                                  (unsigned int)(p->follow-bb),
+                                  (unsigned int)(p->follow->start-op_array->opcodes),
+                                  p->follow->len,
+                                  p->follow->used));
+        }
+        q = p->pred;
+        while (q != NULL) {
+            DBG(ea_debug_printf, (EA_DEBUG, "    pred bb%u start=%u  len=%d used=%d (",
+                                  (unsigned int)(q->bb-bb),
+                                  (unsigned int)(q->bb->start-op_array->opcodes),
+                                  q->bb->len,
+                                  q->bb->used));
+            if (q->bb->jmp_1 == p) {
+                DBG(ea_debug_printf, (EA_DEBUG, "jmp_1 "));
+            }
+            if (q->bb->jmp_2 == p) {
+                DBG(ea_debug_printf, (EA_DEBUG, "jmp_2 "));
+            }
+            if (q->bb->jmp_ext == p) {
+                DBG(ea_debug_printf, (EA_DEBUG, "jmp_ext "));
+            }
+            if (q->bb->jmp_tc == p) {
+                DBG(ea_debug_printf, (EA_DEBUG, "jmp_tc "));
+            }
+            if (q->bb->follow == p) {
+                DBG(ea_debug_printf, (EA_DEBUG, "follow "));
+            }
+            DBG(ea_debug_printf, (EA_DEBUG, ")\n"));
+            q = q->next;
+        }
+        p = p->next;
     }
-    p = p->next;
-  }
-  DBG(ea_debug_printf, (EA_DEBUG, "=== END OF CFG ===========================\n"));
-}
-
-static void dump_array(int nb,void *pos,char type)
-{  int j;
-
-   switch(type) {
-   case 'i': {
-     int *ptr=pos;
-     for (j=0;j<nb;j++) {
-       zend_printf("%d:%6d ",j,*ptr);
-       ptr++;
-     }
-   }
-   break; 
-   case 'x': {
-     int *ptr=pos;
-     for (j=0;j<nb;j++) {
-       zend_printf("%d:%x ",j,*ptr);
-       ptr++;
-     }
-   }
-   break; 
-   case 'c': {
-     unsigned char *ptr=pos;
-     for (j=0;j<nb;j++) {
-/*       if (*ptr>=32 && *ptr<128) zend_printf("%d:%c",j,*ptr);
-       else if (*ptr>=128) zend_printf("%d:%2x",j,*ptr);
-       else if (*ptr<16) zend_printf("%d:&%1x",j,*ptr);
-       else zend_printf("%d:$%1x",j,(*ptr)-16); */
-       zend_printf("%d:%1x ",j,*ptr);
-       ptr++;
-     }
-   }
-   break;   
-   default:
-     for (j=0;j<nb;j++)
-       zend_printf("# ");
-   }
-   zend_printf("<br>\n");
+    DBG(ea_debug_printf, (EA_DEBUG, "=== END OF CFG ===========================\n"));
 }
 #endif
 
+#ifdef ZEND_ENGINE_2_4
+#define SET_TO_NOP(op) \
+  (op)->opcode = ZEND_NOP; \
+  (op)->op1_type = IS_UNUSED; \
+  (op)->op2_type = IS_UNUSED; \
+  (op)->result_type = IS_UNUSED;
+#else
 #define SET_TO_NOP(op) \
   (op)->opcode = ZEND_NOP; \
   (op)->op1.op_type = IS_UNUSED; \
   (op)->op2.op_type = IS_UNUSED; \
   (op)->result.op_type = IS_UNUSED;
+#endif
 
 static void compute_live_var(BB* bb, zend_op_array* op_array, char* global)
 {
-  BB* p = bb;
-  char* def;
-  char* used;
+    BB* p = bb;
+    char* def;
+    char* used;
 
 #ifdef ZEND_ENGINE_2_3
-  ALLOCA_FLAG(use_heap)
+    ALLOCA_FLAG(use_heap)
 #endif
 
-  memset(global, 0, op_array->T * sizeof(char));
-  if (p != NULL && p->next != NULL) {
-    int bb_count = 0;
+    memset(global, 0, op_array->T * sizeof(char));
+
+    if (p != NULL && p->next != NULL) {
+        int bb_count = 0;
 #ifdef ZEND_ENGINE_2_3
-    def = do_alloca(op_array->T * sizeof(char), use_heap);
+        def = do_alloca(op_array->T * sizeof(char), use_heap);
 #else
-    def = do_alloca(op_array->T * sizeof(char));
+        def = do_alloca(op_array->T * sizeof(char));
 #endif
-#if 0
-    DBG(ea_debug_printf, (EA_DEBUG, "compute_live_var %s::%s", op_array->filename, op_array->function_name));
+        while (p) {
+            zend_op* op = p->start;
+            zend_op* end = op + p->len;
+            memset(def, 0, op_array->T * sizeof(char));
+            while (op < end) {
+                if ((OP1_TYPE(op) == IS_VAR || OP1_TYPE(op) == IS_TMP_VAR) &&
+                        !def[VAR_NUM(OP1_VARR(op))] && !global[VAR_NUM(OP1_VARR(op))]) {
+                    global[VAR_NUM(OP1_VARR(op))] = 1;
+                }
+                if ((OP2_TYPE(op) == IS_VAR || OP2_TYPE(op) == IS_TMP_VAR) &&
+                        !def[VAR_NUM(OP2_VARR(op))] && !global[VAR_NUM(OP2_VARR(op))]) {
+                    if (op->opcode != ZEND_OP_DATA) {
+                        global[VAR_NUM(OP2_VARR(op))] = 1;
+                    }
+                }
+#ifdef ZEND_ENGINE_2_3
+                if ((op->opcode == ZEND_DECLARE_INHERITED_CLASS || op->opcode == ZEND_DECLARE_INHERITED_CLASS_DELAYED) &&
+#else
+                if (op->opcode == ZEND_DECLARE_INHERITED_CLASS &&
 #endif
-    while (p != NULL) {
-      zend_op* op = p->start;
-      zend_op* end = op + p->len;
-      memset(def, 0, op_array->T * sizeof(char));
-      while (op < end) {
-        if ((op->op1.op_type == IS_VAR || op->op1.op_type == IS_TMP_VAR) &&
-            !def[VAR_NUM(op->op1.u.var)] && !global[VAR_NUM(op->op1.u.var)]) {
-          global[VAR_NUM(op->op1.u.var)] = 1;
-        }
-        if ((op->op2.op_type == IS_VAR || op->op2.op_type == IS_TMP_VAR) &&
-            !def[VAR_NUM(op->op2.u.var)] && !global[VAR_NUM(op->op2.u.var)]) {
-          if (op->opcode != ZEND_OP_DATA) {
-            global[VAR_NUM(op->op2.u.var)] = 1;
-          }
-        }
-#ifdef ZEND_ENGINE_2_3
-        if ((op->opcode == ZEND_DECLARE_INHERITED_CLASS || op->opcode == ZEND_DECLARE_INHERITED_CLASS_DELAYED) &&
-#else
-        if (op->opcode == ZEND_DECLARE_INHERITED_CLASS &&
-#endif
-            !def[VAR_NUM(op->extended_value)] &&
-            !global[VAR_NUM(op->extended_value)]) {
-          global[VAR_NUM(op->extended_value)] = 1;
-        }
-        if ((op->result.op_type == IS_VAR &&
-             (op->opcode == ZEND_RECV || op->opcode == ZEND_RECV_INIT ||
-              (op->result.u.EA.type & EXT_TYPE_UNUSED) == 0)) ||
-            (op->result.op_type == IS_TMP_VAR)) {
-          if (!def[VAR_NUM(op->result.u.var)] && !global[VAR_NUM(op->result.u.var)]) {
-            switch (op->opcode) {
-              case ZEND_RECV:
-              case ZEND_RECV_INIT:
-              case ZEND_ADD_ARRAY_ELEMENT:
-                global[VAR_NUM(op->result.u.var)] = 1;
-             }
-          }
-          def[VAR_NUM(op->result.u.var)] = 1;
+                        !def[VAR_NUM(op->extended_value)] &&
+                        !global[VAR_NUM(op->extended_value)]) {
+                    global[VAR_NUM(op->extended_value)] = 1;
+                }
+                if ((RES_TYPE(op) & IS_VAR &&
+                        (op->opcode == ZEND_RECV || op->opcode == ZEND_RECV_INIT ||
+                         (RES_USED(op) & EXT_TYPE_UNUSED) == 0)) ||
+                        (RES_TYPE(op) & IS_TMP_VAR)) {
+                    if (!def[VAR_NUM(RES_VARR(op))] && !global[VAR_NUM(RES_VARR(op))]) {
+                        switch (op->opcode) {
+                        case ZEND_RECV:
+                        case ZEND_RECV_INIT:
+                        case ZEND_ADD_ARRAY_ELEMENT:
+                            global[VAR_NUM(RES_VARR(op))] = 1;
+                            break;
+                        }
+                    }
+                    def[VAR_NUM(RES_VARR(op))] = 1;
+                }
+                op++;
+            }
+            p = p->next;
+            bb_count++;
         }
-        op++;
-      }
-      p = p->next;
-      bb_count++;
-    }
+
 #ifdef ZEND_ENGINE_2_3
-    free_alloca(def, use_heap);
+        free_alloca(def, use_heap);
 #else
-    free_alloca(def);
+        free_alloca(def);
 #endif
-  }
+    }
 #ifdef ZEND_ENGINE_2_3
     used = do_alloca(op_array->T * sizeof(char), use_heap);
 #else
     used = do_alloca(op_array->T * sizeof(char));
 #endif
     p = bb;
-    while (p != NULL) {
-      zend_op* op = p->start;
-      zend_op* end = op + p->len;
-      memset(used, 0, op_array->T * sizeof(char));
-      while (op < end) {
-        end--;
-        if (((end->result.op_type == IS_VAR &&
-             (end->opcode == ZEND_RECV || end->opcode == ZEND_RECV_INIT ||
-              (end->result.u.EA.type & EXT_TYPE_UNUSED) == 0)) ||
-             (end->result.op_type == IS_TMP_VAR)) &&
-            !global[VAR_NUM(end->result.u.var)] && !used[VAR_NUM(end->result.u.var)]) {
-           switch(end->opcode) {
-             case ZEND_JMPZ_EX:
-               end->opcode = ZEND_JMPZ;
-               end->result.op_type = IS_UNUSED;
-               break;
-             case ZEND_JMPNZ_EX:
-               end->opcode = ZEND_JMPNZ;
-               end->result.op_type = IS_UNUSED;
-               break;
-             case ZEND_ASSIGN_ADD:
-             case ZEND_ASSIGN_SUB:
-             case ZEND_ASSIGN_MUL:
-             case ZEND_ASSIGN_DIV:
-             case ZEND_ASSIGN_MOD:
-             case ZEND_ASSIGN_SL:
-             case ZEND_ASSIGN_SR:
-             case ZEND_ASSIGN_CONCAT:
-             case ZEND_ASSIGN_BW_OR:
-             case ZEND_ASSIGN_BW_AND:
-             case ZEND_ASSIGN_BW_XOR:
-             case ZEND_PRE_INC:
-             case ZEND_PRE_DEC:
-             case ZEND_POST_INC:
-             case ZEND_POST_DEC:
-             case ZEND_ASSIGN:
-             case ZEND_ASSIGN_REF:
-             case ZEND_DO_FCALL:
-             case ZEND_DO_FCALL_BY_NAME:
-               if (end->result.op_type == IS_VAR) {
-                 end->result.u.EA.type |= EXT_TYPE_UNUSED;
-               }
-               break;
-             case ZEND_UNSET_VAR:
-             case ZEND_UNSET_DIM:
-             case ZEND_UNSET_OBJ:
-               end->result.op_type = IS_UNUSED;
-               break;
-             case ZEND_RECV:
-             case ZEND_RECV_INIT:
-             case ZEND_INCLUDE_OR_EVAL:
-             case ZEND_NEW:
-             case ZEND_FE_FETCH:
-             case ZEND_PRINT:
-             case ZEND_INIT_METHOD_CALL:
-             case ZEND_INIT_STATIC_METHOD_CALL:
-             case ZEND_ASSIGN_DIM:
-             case ZEND_ASSIGN_OBJ:
-             case ZEND_DECLARE_CLASS:
-             case ZEND_DECLARE_INHERITED_CLASS:
+    while (p) {
+        zend_op* op = p->start;
+        zend_op* end = op + p->len;
+        memset(used, 0, op_array->T * sizeof(char));
+        while (op < end) {
+            end--;
+            if (((RES_TYPE(end) & IS_VAR &&
+                    (end->opcode == ZEND_RECV || end->opcode == ZEND_RECV_INIT ||
+                     (RES_USED(end) & EXT_TYPE_UNUSED) == 0)) ||
+                    (RES_TYPE(end) & IS_TMP_VAR)) &&
+                    !global[VAR_NUM(RES_VARR(end))] && !used[VAR_NUM(RES_VARR(end))]) {
+                switch(end->opcode) {
+                case ZEND_JMPZ_EX:
+                    end->opcode = ZEND_JMPZ;
+                    RES_TYPE(end) = IS_UNUSED;
+                    break;
+                case ZEND_JMPNZ_EX:
+                    end->opcode = ZEND_JMPNZ;
+                    RES_TYPE(end) = IS_UNUSED;
+                    break;
+                case ZEND_ASSIGN_ADD:
+                case ZEND_ASSIGN_SUB:
+                case ZEND_ASSIGN_MUL:
+                case ZEND_ASSIGN_DIV:
+                case ZEND_ASSIGN_MOD:
+                case ZEND_ASSIGN_SL:
+                case ZEND_ASSIGN_SR:
+                case ZEND_ASSIGN_CONCAT:
+                case ZEND_ASSIGN_BW_OR:
+                case ZEND_ASSIGN_BW_AND:
+                case ZEND_ASSIGN_BW_XOR:
+                case ZEND_PRE_INC:
+                case ZEND_PRE_DEC:
+                case ZEND_POST_INC:
+                case ZEND_POST_DEC:
+                case ZEND_ASSIGN:
+                case ZEND_ASSIGN_REF:
+                case ZEND_DO_FCALL:
+                case ZEND_DO_FCALL_BY_NAME:
+                    if (RES_TYPE(end) & IS_VAR) {
+                        RES_USED(end) |= EXT_TYPE_UNUSED;
+                    }
+                    break;
+                case ZEND_UNSET_VAR:
+                case ZEND_UNSET_DIM:
+                case ZEND_UNSET_OBJ:
+                    RES_TYPE(end) = IS_UNUSED;
+                    break;
+                case ZEND_RECV:
+                case ZEND_RECV_INIT:
+                case ZEND_INCLUDE_OR_EVAL:
+                case ZEND_NEW:
+                case ZEND_FE_FETCH:
+                case ZEND_PRINT:
+                case ZEND_INIT_METHOD_CALL:
+                case ZEND_INIT_STATIC_METHOD_CALL:
+                case ZEND_ASSIGN_DIM:
+                case ZEND_ASSIGN_OBJ:
+                case ZEND_DECLARE_CLASS:
+                case ZEND_DECLARE_INHERITED_CLASS:
 #ifdef ZEND_DECLARE_INHERITED_CLASS_DELAYED
-             case ZEND_DECLARE_INHERITED_CLASS_DELAYED:
+                case ZEND_DECLARE_INHERITED_CLASS_DELAYED:
 #endif
-              break;
-            default:
-              if (end->op1.op_type == IS_CONST) {
-                zval_dtor(&end->op1.u.constant);
-              }
-              if (end->op2.op_type == IS_CONST) {
-                zval_dtor(&end->op2.u.constant);
-              }
-              SET_TO_NOP(end);
-          }
-        } else if (end->result.op_type == IS_VAR &&
-                   (end->result.u.EA.type & EXT_TYPE_UNUSED) != 0 &&
-                   end->opcode != ZEND_RECV && end->opcode != ZEND_RECV_INIT &&
-                   used[VAR_NUM(end->result.u.var)]) {
-          end->result.u.EA.type &= ~EXT_TYPE_UNUSED;
-        }
-        if ((end->result.op_type == IS_VAR &&
-            (end->opcode == ZEND_RECV || end->opcode == ZEND_RECV_INIT ||
-             (end->result.u.EA.type & EXT_TYPE_UNUSED) == 0)) ||
-            (end->result.op_type == IS_TMP_VAR)) {
-          switch (end->opcode) {
-            case ZEND_RECV:
-            case ZEND_RECV_INIT:
-            case ZEND_ADD_ARRAY_ELEMENT:
-              used[VAR_NUM(end->result.u.var)] = 1;
-              break;
-            default:
-              used[VAR_NUM(end->result.u.var)] = 0;
-           }
-        }
-        if (end->op1.op_type == IS_VAR || end->op1.op_type == IS_TMP_VAR) {
-          used[VAR_NUM(end->op1.u.var)] = 1;
-        }
-        if (end->op2.op_type == IS_VAR || end->op2.op_type == IS_TMP_VAR) {
-          used[VAR_NUM(end->op2.u.var)] = 1;
-        }
+                    break;
+                default:
+#ifndef ZEND_ENGINE_2_4
+                    /* TODO: check this */
+                    if (OP1_TYPE(end) == IS_CONST) {
+                        zval_dtor(&end->op1.u.constant);
+                    }
+                    if (OP2_TYPE(end) == IS_CONST) {
+                        zval_dtor(&end->op2.u.constant);
+                    }
+#endif
+                    SET_TO_NOP(end);
+                }
+            } else if (RES_TYPE(end) & IS_VAR &&
+                       (RES_USED(end) & EXT_TYPE_UNUSED) != 0 &&
+                       end->opcode != ZEND_RECV && end->opcode != ZEND_RECV_INIT &&
+                       used[VAR_NUM(RES_VARR(end))]) {
+                RES_USED(end) &= ~EXT_TYPE_UNUSED;
+            }
+            if ((RES_TYPE(end) & IS_VAR &&
+                    (end->opcode == ZEND_RECV || end->opcode == ZEND_RECV_INIT ||
+                     (RES_USED(end) & EXT_TYPE_UNUSED) == 0)) ||
+                    (RES_TYPE(end) & IS_TMP_VAR)) {
+                switch (end->opcode) {
+                case ZEND_RECV:
+                case ZEND_RECV_INIT:
+                case ZEND_ADD_ARRAY_ELEMENT:
+                    used[VAR_NUM(RES_VARR(end))] = 1;
+                    break;
+                default:
+                    used[VAR_NUM(RES_VARR(end))] = 0;
+                }
+            }
+            if (OP1_TYPE(end) == IS_VAR || OP1_TYPE(end) == IS_TMP_VAR) {
+                used[VAR_NUM(OP1_VARR(end))] = 1;
+            }
+            if (OP2_TYPE(end) == IS_VAR || OP2_TYPE(end) == IS_TMP_VAR) {
+                used[VAR_NUM(OP2_VARR(end))] = 1;
+            }
 #ifdef ZEND_ENGINE_2_3
-        if (end->opcode == ZEND_DECLARE_INHERITED_CLASS || end->opcode == ZEND_DECLARE_INHERITED_CLASS_DELAYED) {
+            if (end->opcode == ZEND_DECLARE_INHERITED_CLASS || end->opcode == ZEND_DECLARE_INHERITED_CLASS_DELAYED) {
 #else
-        if (end->opcode == ZEND_DECLARE_INHERITED_CLASS) {
+            if (end->opcode == ZEND_DECLARE_INHERITED_CLASS) {
 #endif
-          used[VAR_NUM(end->extended_value)] = 1;
+                used[VAR_NUM(end->extended_value)] = 1;
+            }
         }
-      }
-      p = p->next;
+        p = p->next;
     }
+
 #ifdef ZEND_ENGINE_2_3
     free_alloca(used, use_heap);
 #else
@@ -408,84 +393,100 @@
 
 static void mark_used_bb(BB* bb)
 {
-  if (bb->used) return;
-  bb->used = 1;
-  if (bb->jmp_1 != NULL) {
-    mark_used_bb(bb->jmp_1);
-    BB_ADD_PRED(bb->jmp_1, bb);
-  }
-  if (bb->jmp_2 != NULL) {
-    mark_used_bb(bb->jmp_2);
-    BB_ADD_PRED(bb->jmp_2, bb);
-  }
-  if (bb->jmp_ext != NULL) {
-    mark_used_bb(bb->jmp_ext);
-    BB_ADD_PRED(bb->jmp_ext, bb);
-  }
-  if (bb->follow != NULL) {
-    mark_used_bb(bb->follow);
-    BB_ADD_PRED(bb->follow, bb);
-  }
+    if (bb->used) {
+        return;
+    }
+    bb->used = 1;
+    if (bb->jmp_1 != NULL) {
+        mark_used_bb(bb->jmp_1);
+        BB_ADD_PRED(bb->jmp_1, bb);
+    }
+    if (bb->jmp_2 != NULL) {
+        mark_used_bb(bb->jmp_2);
+        BB_ADD_PRED(bb->jmp_2, bb);
+    }
+    if (bb->jmp_ext != NULL) {
+        mark_used_bb(bb->jmp_ext);
+        BB_ADD_PRED(bb->jmp_ext, bb);
+    }
+    if (bb->jmp_tc != NULL) {
+        mark_used_bb(bb->jmp_tc);
+        BB_ADD_PRED(bb->jmp_tc, bb);
+    }
+    if (bb->follow != NULL) {
+        mark_used_bb(bb->follow);
+        BB_ADD_PRED(bb->follow, bb);
+    }
 }
 
 static void mark_used_bb2(BB* bb)
 {
-  if (bb->used) return;
-  bb->used = 1;
-  if (bb->jmp_1 != NULL) {
-    mark_used_bb2(bb->jmp_1);
-  }
-  if (bb->jmp_2 != NULL) {
-    mark_used_bb2(bb->jmp_2);
-  }
-  if (bb->jmp_ext != NULL) {
-    mark_used_bb2(bb->jmp_ext);
-  }
-  if (bb->follow != NULL) {
-    mark_used_bb2(bb->follow);
-  }
+    if (bb->used) {
+        return;
+    }
+    bb->used = 1;
+    if (bb->jmp_1 != NULL) {
+        mark_used_bb2(bb->jmp_1);
+    }
+    if (bb->jmp_2 != NULL) {
+        mark_used_bb2(bb->jmp_2);
+    }
+    if (bb->jmp_ext != NULL) {
+        mark_used_bb2(bb->jmp_ext);
+    }
+    if (bb->jmp_tc != NULL) {
+        mark_used_bb2(bb->jmp_tc);
+    }
+    if (bb->follow != NULL) {
+        mark_used_bb2(bb->follow);
+    }
 }
 
 static void rm_bb(BB* bb)
 {
-  if (bb->used == 0) {
-    return;
-  }
-  bb->used = 0;
-  if (bb->jmp_1 != NULL) {
-    BB_DEL_PRED(bb->jmp_1, bb);
-  }
-  if (bb->jmp_2 != NULL) {
-    BB_DEL_PRED(bb->jmp_2, bb);
-  }
-  if (bb->jmp_ext != NULL) {
-    BB_DEL_PRED(bb->jmp_ext, bb);
-  }
-  if (bb->follow != NULL) {
-    BB_DEL_PRED(bb->follow, bb);
-  }
+    if (!bb->used) {
+        return;
+    }
+    bb->used = 0;
+    if (bb->jmp_1 != NULL) {
+        BB_DEL_PRED(bb->jmp_1, bb);
+    }
+    if (bb->jmp_2 != NULL) {
+        BB_DEL_PRED(bb->jmp_2, bb);
+    }
+    if (bb->jmp_ext != NULL) {
+        BB_DEL_PRED(bb->jmp_ext, bb);
+    }
+    if (bb->jmp_tc != NULL) {
+        BB_DEL_PRED(bb->jmp_tc, bb);
+    }
+    if (bb->follow != NULL) {
+        BB_DEL_PRED(bb->follow, bb);
+    }
 }
 
 static void del_bb(BB* bb)
 {
-  zend_op* op = bb->start;
-  zend_op* end = op + bb->len;
+    zend_op* op = bb->start;
+    zend_op* end = op + bb->len;
 
-  rm_bb(bb);
-  while (op < end) {
-    --end;
-    if (end->op1.op_type == IS_CONST) {
-      zval_dtor(&end->op1.u.constant);
-    }
-    if (end->op2.op_type == IS_CONST) {
-      zval_dtor(&end->op2.u.constant);
+    rm_bb(bb);
+    while (op < end) {
+        --end;
+#ifndef ZEND_ENGINE_2_4
+        if (OP1_TYPE(end) == IS_CONST) {
+            zval_dtor(&end->op1.u.constant);
+        }
+        if (OP2_TYPE(end) == IS_CONST) {
+            zval_dtor(&end->op2.u.constant);
+        }
+#endif
+        SET_TO_NOP(end);
     }
-    SET_TO_NOP(end);
-  }
-  bb->len  = 0;
-  bb->used = 0;
+    bb->len  = 0;
+    bb->used = 0;
 }
-
+/*
 static void replace_bb(BB* src, BB* dst)
 {
   BBlink* p = src->pred;
@@ -512,967 +513,977 @@
   }
   src->pred = NULL;
 }
-
+*/
 static void optimize_jmp(BB* bb, zend_op_array* op_array)
 {
-  BB* p;
+    BB* p;
 
-  while(1) {
-    int ok = 1;
+    while(1) {
+        int ok = 1;
 
-    /* Remove Unused Basic Blocks */
-    p = bb;
-    while (p->next != NULL) {
-      if (p->next->used && p->next->pred) {
-        p = p->next;
-      } else {
-        del_bb(p->next);
-        p->next = p->next->next;
-        ok = 0;
-      }
-    }
+        /* Remove Unused Basic Blocks */
+        p = bb;
+        while (p->next != NULL) {
+            if (p->next->used && p->next->pred) {
+                p = p->next;
+            } else {
+                del_bb(p->next);
+                p->next = p->next->next;
+                ok = 0;
+            }
+        }
 
-    /* JMP optimization */
-    p = bb;
-    while (p != NULL) {
-      while (p->next != NULL && (!p->next->used || p->next->pred == NULL)) {
-        del_bb(p->next);
-        p->next = p->next->next;
-        ok = 0;
-      }
-      if (p->used && p->len > 0) {
-        zend_op* op = &p->start[p->len-1];
+        /* JMP optimization */
+        p = bb;
+        while (p) {
+            while (p->next != NULL && (!p->next->used || p->next->pred == NULL)) {
+                del_bb(p->next);
+                p->next = p->next->next;
+                ok = 0;
+            }
+            if (p->used && p->len > 0) {
+                zend_op* op = &p->start[p->len-1];
 
-        switch (op->opcode) {
-          case ZEND_JMP:
+                switch (op->opcode) {
+                case ZEND_JMP:
 jmp:
-            /* L1: JMP L1+1  => NOP
-            */
-            if (p->jmp_1 == p->next) {
-              if (p->follow) {
-                BB_DEL_PRED(p->follow, p);
-              }
-              p->follow = p->jmp_1;
-              p->jmp_1   = NULL;
-              SET_TO_NOP(op);
-              --(p->len);
-              ok = 0;
-              break;
-            }
-            /*     JMP L1  =>  JMP L2
-                   ...         ...
-               L1: JMP L2      JMP L2
-            */
-            while (p->jmp_1->len == 1 &&
-                p->jmp_1->start->opcode == ZEND_JMP &&
-                p->jmp_1 != p) {
-              BB* x_p = p->jmp_1;
-              BB_DEL_PRED(p->jmp_1, p);
-              RM_BB(x_p);
-              p->jmp_1 = x_p->jmp_1;
-              BB_ADD_PRED(p->jmp_1, p);
-              ok = 0;
-            }
-            break;
-          case ZEND_JMPZNZ:
+                    /* L1: JMP L1+1  => NOP
+                    */
+                    if (p->jmp_1 == p->next) {
+                        if (p->follow) {
+                            BB_DEL_PRED(p->follow, p);
+                        }
+                        p->follow = p->jmp_1;
+                        p->jmp_1   = NULL;
+                        SET_TO_NOP(op);
+                        --(p->len);
+                        ok = 0;
+                        break;
+                    }
+                    /*     JMP L1  =>  JMP L2
+                           ...         ...
+                       L1: JMP L2      JMP L2
+                    */
+                    while (p->jmp_1->len == 1 &&
+                            p->jmp_1->start->opcode == ZEND_JMP &&
+                            p->jmp_1 != p) {
+                        BB* x_p = p->jmp_1;
+                        BB_DEL_PRED(p->jmp_1, p);
+                        RM_BB(x_p);
+                        p->jmp_1 = x_p->jmp_1;
+                        BB_ADD_PRED(p->jmp_1, p);
+                        ok = 0;
+                    }
+                    break;
+                case ZEND_JMPZNZ:
 jmp_znz:
-            /* JMPZNZ  ?,L1,L1  =>  JMP L1
-            */
-            if (p->jmp_ext == p->jmp_2) {
-              op->opcode = ZEND_JMP;
-              op->extended_value = 0;
-              op->op1.op_type = IS_UNUSED;
-              op->op2.op_type = IS_UNUSED;
-              p->jmp_1 = p->jmp_2;
-              p->jmp_2 = NULL;
-              p->jmp_ext = NULL;
-              ok = 0;
-              goto jmp;
-            } else if (op->op1.op_type == IS_CONST) {
-              /* JMPZNZ  0,L1,L2  =>  JMP L1
-              */
-              if (!zend_is_true(&op->op1.u.constant)) {
-                op->opcode = ZEND_JMP;
-                op->extended_value = 0;
-                op->op1.op_type = IS_UNUSED;
-                op->op2.op_type = IS_UNUSED;
-                if (p->jmp_ext != p->jmp_2) {
-                  BB_DEL_PRED(p->jmp_ext, p);
-                  RM_BB(p->jmp_ext);
-                }
-                p->jmp_1   = p->jmp_2;
-                p->jmp_2   = NULL;
-                p->jmp_ext = NULL;
-                p->follow  = NULL;
-                ok = 0;
-                goto jmp;
-              /* JMPZNZ  1,L1,L2  =>  JMP L2
-              */
-              } else {
-                op->opcode = ZEND_JMP;
-                op->extended_value = 0;
-                op->op1.op_type = IS_UNUSED;
-                op->op2.op_type = IS_UNUSED;
-                if (p->jmp_ext != p->jmp_2) {
-                  BB_DEL_PRED(p->jmp_2, p);
-                  RM_BB(p->jmp_2);
-                }
-                p->jmp_1   = p->jmp_ext;
-                p->jmp_2   = NULL;
-                p->jmp_ext = NULL;
-                p->follow  = NULL;
-                ok = 0;
-                goto jmp;
-              }
-            /* L1: JMPZNZ ?,L2,L1+1  => JMPZ ?,L2
-            */
-            } else if (p->jmp_ext == p->next) {
-              op->opcode = ZEND_JMPZ;
-              op->extended_value = 0;
-              p->follow = p->jmp_ext;
-              p->jmp_ext = NULL;
-              ok = 0;
-              goto jmp_z;
-            /* L1: JMPZNZ ?,L1+1,L2  => JMPNZ ?,L2
-            */
-            } else if (p->jmp_2 == p->next) {
-              op->opcode = ZEND_JMPNZ;
-              op->extended_value = 0;
-              p->follow = p->jmp_2;
-              p->jmp_2  = p->jmp_ext;
-              p->jmp_ext = NULL;
-              ok = 0;
-              goto jmp_nz;
-            } else if (p->jmp_2->len == 1 &&
-                       op->op1.op_type == IS_TMP_VAR) {
-            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L3,L2
-                   ...                  ...
-               L1: JMPZ   $x,L3         JMPZ   $x,L3
-            */
-            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L3,L2
-                   ...                  ...
-               L1: JMPZNZ $x,L3,L4      JMPZNZ $x,L3,L4
-            */
-            if        ((p->jmp_2->start->opcode == ZEND_JMPZ ||
-                        p->jmp_2->start->opcode == ZEND_JMPZNZ) &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_2;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_znz;
-            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1+1,L2
-                   ...                  ...
-               L1: JMPNZ  $x,L3         JMPNZ  $x,L3
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_JMPNZ &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_znz;
-            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1,L3
-                   ...                  ...
-               L2: JMPNZ  $x,L3         JMPNZ  $x,L3
-            */
-            } else if (p->jmp_ext->start->opcode == ZEND_JMPNZ &&
-                       p->jmp_ext->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_ext->start->op1.u.var) {
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_ext, p);
-                RM_BB(p->jmp_ext);
-              }
-              p->jmp_ext = p->jmp_ext->jmp_2;
-              BB_ADD_PRED(p->jmp_ext, p);
-              ok = 0;
-              goto jmp_znz;
-            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1,L4
-                   ...                  ...
-               L2: JMPZNZ $x,L3,L4      JMPZNZ $x,L3,L4
-            */
-            } else if (p->jmp_ext->start->opcode == ZEND_JMPZNZ &&
-                       p->jmp_ext->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_ext->start->op1.u.var) {
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_ext, p);
-                RM_BB(p->jmp_ext);
-              }
-              p->jmp_ext = p->jmp_ext->jmp_ext;
-              BB_ADD_PRED(p->jmp_ext, p);
-              ok = 0;
-              goto jmp_znz;
-            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1,L2+1
-                   ...                  ...
-               L2: JMPZ   $x,L3         JMPZ   $x,L3
-            */
-            } else if (p->jmp_ext->start->opcode == ZEND_JMPZ &&
-                       p->jmp_ext->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_ext->start->op1.u.var) {
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_ext, p);
-                RM_BB(p->jmp_ext);
-              }
-              p->jmp_ext = p->jmp_ext->follow;
-              BB_ADD_PRED(p->jmp_ext, p);
-              ok = 0;
-              goto jmp_znz;
-            }
-            }
-            while (p->jmp_2->len == 1 && p->jmp_2->start->opcode == ZEND_JMP) {
-              BB* x_p = p->jmp_2;
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(x_p);
-              }
-              p->jmp_2 = x_p->jmp_1;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-            }
-            while (p->jmp_ext->len == 1 && p->jmp_ext->start->opcode == ZEND_JMP) {
-              BB* x_p = p->jmp_ext;
-              if (p->jmp_2 != p->jmp_ext) {
-                BB_DEL_PRED(p->jmp_ext, p);
-                RM_BB(x_p);
-              }
-              p->jmp_ext = x_p->jmp_1;
-              BB_ADD_PRED(p->jmp_ext, p);
-              ok = 0;
-            }
-            break;
-          case ZEND_JMPZ:
+                    /* JMPZNZ  ?,L1,L1  =>  JMP L1
+                    */
+                    if (p->jmp_ext == p->jmp_2) {
+                        op->opcode = ZEND_JMP;
+                        op->extended_value = 0;
+                        OP1_TYPE(op) = IS_UNUSED;
+                        OP2_TYPE(op) = IS_UNUSED;
+                        p->jmp_1 = p->jmp_2;
+                        p->jmp_2 = NULL;
+                        p->jmp_ext = NULL;
+                        ok = 0;
+                        goto jmp;
+                    } else if (OP1_TYPE(op) == IS_CONST) {
+                        /* JMPZNZ  0,L1,L2  =>  JMP L1
+                        */
+                        if (!zend_is_true(&OP1_CONST(op))) {
+                            op->opcode = ZEND_JMP;
+                            op->extended_value = 0;
+                            OP1_TYPE(op) = IS_UNUSED;
+                            OP2_TYPE(op) = IS_UNUSED;
+                            if (p->jmp_ext != p->jmp_2) {
+                                BB_DEL_PRED(p->jmp_ext, p);
+                                RM_BB(p->jmp_ext);
+                            }
+                            p->jmp_1   = p->jmp_2;
+                            p->jmp_2   = NULL;
+                            p->jmp_ext = NULL;
+                            p->follow  = NULL;
+                            ok = 0;
+                            goto jmp;
+                            /* JMPZNZ  1,L1,L2  =>  JMP L2
+                            */
+                        } else {
+                            op->opcode = ZEND_JMP;
+                            op->extended_value = 0;
+                            OP1_TYPE(op) = IS_UNUSED;
+                            OP2_TYPE(op) = IS_UNUSED;
+                            if (p->jmp_ext != p->jmp_2) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_1   = p->jmp_ext;
+                            p->jmp_2   = NULL;
+                            p->jmp_ext = NULL;
+                            p->follow  = NULL;
+                            ok = 0;
+                            goto jmp;
+                        }
+                        /* L1: JMPZNZ ?,L2,L1+1  => JMPZ ?,L2
+                        */
+                    } else if (p->jmp_ext == p->next) {
+                        op->opcode = ZEND_JMPZ;
+                        op->extended_value = 0;
+                        p->follow = p->jmp_ext;
+                        p->jmp_ext = NULL;
+                        ok = 0;
+                        goto jmp_z;
+                        /* L1: JMPZNZ ?,L1+1,L2  => JMPNZ ?,L2
+                        */
+                    } else if (p->jmp_2 == p->next) {
+                        op->opcode = ZEND_JMPNZ;
+                        op->extended_value = 0;
+                        p->follow = p->jmp_2;
+                        p->jmp_2  = p->jmp_ext;
+                        p->jmp_ext = NULL;
+                        ok = 0;
+                        goto jmp_nz;
+                    } else if (p->jmp_2->len == 1 &&
+                               OP1_TYPE(op) == IS_TMP_VAR) {
+                        /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L3,L2
+                               ...                  ...
+                           L1: JMPZ   $x,L3         JMPZ   $x,L3
+                        */
+                        /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L3,L2
+                               ...                  ...
+                           L1: JMPZNZ $x,L3,L4      JMPZNZ $x,L3,L4
+                        */
+                        if        ((p->jmp_2->start->opcode == ZEND_JMPZ ||
+                                    p->jmp_2->start->opcode == ZEND_JMPZNZ) &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->jmp_ext) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_2;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_znz;
+                            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1+1,L2
+                                   ...                  ...
+                               L1: JMPNZ  $x,L3         JMPNZ  $x,L3
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_JMPNZ &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->jmp_ext) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_znz;
+                            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1,L3
+                                   ...                  ...
+                               L2: JMPNZ  $x,L3         JMPNZ  $x,L3
+                            */
+                        } else if (p->jmp_ext->start->opcode == ZEND_JMPNZ &&
+                                   OP1_TYPE(p->jmp_ext->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_ext->start)) {
+                            if (p->jmp_2 != p->jmp_ext) {
+                                BB_DEL_PRED(p->jmp_ext, p);
+                                RM_BB(p->jmp_ext);
+                            }
+                            p->jmp_ext = p->jmp_ext->jmp_2;
+                            BB_ADD_PRED(p->jmp_ext, p);
+                            ok = 0;
+                            goto jmp_znz;
+                            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1,L4
+                                   ...                  ...
+                               L2: JMPZNZ $x,L3,L4      JMPZNZ $x,L3,L4
+                            */
+                        } else if (p->jmp_ext->start->opcode == ZEND_JMPZNZ &&
+                                   OP1_TYPE(p->jmp_ext->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_ext->start)) {
+                            if (p->jmp_2 != p->jmp_ext) {
+                                BB_DEL_PRED(p->jmp_ext, p);
+                                RM_BB(p->jmp_ext);
+                            }
+                            p->jmp_ext = p->jmp_ext->jmp_ext;
+                            BB_ADD_PRED(p->jmp_ext, p);
+                            ok = 0;
+                            goto jmp_znz;
+                            /*     JMPZNZ $x,L1,L2  =>  JMPZNZ $x,L1,L2+1
+                                   ...                  ...
+                               L2: JMPZ   $x,L3         JMPZ   $x,L3
+                            */
+                        } else if (p->jmp_ext->start->opcode == ZEND_JMPZ &&
+                                   OP1_TYPE(p->jmp_ext->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_ext->start)) {
+                            if (p->jmp_2 != p->jmp_ext) {
+                                BB_DEL_PRED(p->jmp_ext, p);
+                                RM_BB(p->jmp_ext);
+                            }
+                            p->jmp_ext = p->jmp_ext->follow;
+                            BB_ADD_PRED(p->jmp_ext, p);
+                            ok = 0;
+                            goto jmp_znz;
+                        }
+                    }
+                    while (p->jmp_2->len == 1 && p->jmp_2->start->opcode == ZEND_JMP) {
+                        BB* x_p = p->jmp_2;
+                        if (p->jmp_2 != p->jmp_ext) {
+                            BB_DEL_PRED(p->jmp_2, p);
+                            RM_BB(x_p);
+                        }
+                        p->jmp_2 = x_p->jmp_1;
+                        BB_ADD_PRED(p->jmp_2, p);
+                        ok = 0;
+                    }
+                    while (p->jmp_ext->len == 1 && p->jmp_ext->start->opcode == ZEND_JMP) {
+                        BB* x_p = p->jmp_ext;
+                        if (p->jmp_2 != p->jmp_ext) {
+                            BB_DEL_PRED(p->jmp_ext, p);
+                            RM_BB(x_p);
+                        }
+                        p->jmp_ext = x_p->jmp_1;
+                        BB_ADD_PRED(p->jmp_ext, p);
+                        ok = 0;
+                    }
+                    break;
+                case ZEND_JMPZ:
 jmp_z:
-            /* L1: JMPZ  ?,L1+1  =>  NOP
-            */
-            if (p->follow == p->jmp_2) {
-              p->jmp_2   = NULL;
-              SET_TO_NOP(op);
-              --(p->len);
-              ok = 0;
-              break;
-            } else if (op->op1.op_type == IS_CONST) {
-              /* JMPZ  0,L1  =>  JMP L1
-              */
-              if (!zend_is_true(&op->op1.u.constant)) {
-                op->opcode = ZEND_JMP;
-                op->op1.op_type = IS_UNUSED;
-                op->op2.op_type = IS_UNUSED;
-                if (p->follow != p->jmp_2) {
-                  BB_DEL_PRED(p->follow, p);
-                  RM_BB(p->follow);
-                }
-                p->jmp_1  = p->jmp_2;
-                p->jmp_2  = NULL;
-                p->follow = NULL;
-                ok = 0;
-                goto jmp;
-              /* JMPZ  1,L1  =>  NOP
-              */
-              } else {
-                if (p->follow != p->jmp_2) {
-                  BB_DEL_PRED(p->jmp_2, p);
-                  RM_BB(p->jmp_2);
+                    /* L1: JMPZ  ?,L1+1  =>  NOP
+                    */
+                    if (p->follow == p->jmp_2) {
+                        p->jmp_2   = NULL;
+                        SET_TO_NOP(op);
+                        --(p->len);
+                        ok = 0;
+                        break;
+                    } else if (OP1_TYPE(op) == IS_CONST) {
+                        /* JMPZ  0,L1  =>  JMP L1
+                        */
+                        if (!zend_is_true(&OP1_CONST(op))) {
+                            op->opcode = ZEND_JMP;
+                            OP1_TYPE(op) = IS_UNUSED;
+                            OP2_TYPE(op) = IS_UNUSED;
+                            if (p->follow != p->jmp_2) {
+                                BB_DEL_PRED(p->follow, p);
+                                RM_BB(p->follow);
+                            }
+                            p->jmp_1  = p->jmp_2;
+                            p->jmp_2  = NULL;
+                            p->follow = NULL;
+                            ok = 0;
+                            goto jmp;
+                            /* JMPZ  1,L1  =>  NOP
+                            */
+                        } else {
+                            if (p->follow != p->jmp_2) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2   = NULL;
+                            SET_TO_NOP(op);
+                            --(p->len);
+                            ok = 0;
+                            break;
+                        }
+                        /* JMPZ ?,L1  =>  JMPZNZ  ?,L1,L2
+                           JMP  L2        JMP     L2
+                        */
+                    } else if (p->follow->len == 1 && p->follow->start->opcode == ZEND_JMP) {
+                        BB* x_p = p->follow;
+                        op->opcode = ZEND_JMPZNZ;
+                        if (p->jmp_2 != p->follow) {
+                            BB_DEL_PRED(p->follow, p);
+                            RM_BB(x_p);
+                        }
+                        p->follow = NULL;
+                        p->jmp_ext = x_p->jmp_1;
+                        BB_ADD_PRED(p->jmp_ext, p);
+                        ok = 0;
+                        goto jmp_znz;
+                    } else if (p->jmp_2->len == 1 &&
+                               OP1_TYPE(op) == IS_TMP_VAR) {
+                        /*     JMPZ $x,L1  =>  JMPZ $x,L2
+                               ...             ...
+                           L1: JMPZ $x,L2      JMPZ $x,L2
+                           ----------------------------------------
+                               JMPZ   $x,L1     =>  JMPZ  $x,L2
+                               ...                   ...
+                           L1: JMPZNZ $x,L2,L3      JMPZNZ $x,L2,L3
+                        */
+                        if       ((p->jmp_2->start->opcode == ZEND_JMPZ ||
+                                   p->jmp_2->start->opcode == ZEND_JMPZNZ) &&
+                                  OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                  OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_2;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_z;
+                            /*     JMPZ  $x,L1  =>  JMPZ  $x,L1+1
+                                   ...              ...
+                               L1: JMPNZ $x,L2      JMPNZ $x,L2
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_JMPNZ &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_z;
+                        }
+                    }
+                    goto jmp_2;
+                case ZEND_JMPNZ:
+jmp_nz:
+                    /* L1: JMPNZ  ?,L1+1  =>  NOP
+                    */
+                    if (p->follow == p->jmp_2) {
+                        p->jmp_2   = NULL;
+                        SET_TO_NOP(op);
+                        --(p->len);
+                        ok = 0;
+                        break;
+                    } else if (OP1_TYPE(op) == IS_CONST) {
+                        /* JMPNZ  1,L1  =>  JMP L1
+                        */
+                        if (zend_is_true(&OP1_CONST(op))) {
+                            op->opcode = ZEND_JMP;
+                            OP1_TYPE(op) = IS_UNUSED;
+                            OP2_TYPE(op) = IS_UNUSED;
+                            if (p->follow != p->jmp_2) {
+                                BB_DEL_PRED(p->follow, p);
+                                RM_BB(p->follow);
+                            }
+                            p->jmp_1  = p->jmp_2;
+                            p->jmp_2  = NULL;
+                            p->follow = NULL;
+                            ok = 0;
+                            goto jmp;
+                            /* JMPNZ  0,L1  =>  NOP
+                            */
+                        } else {
+                            if (p->follow != p->jmp_2) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2   = NULL;
+                            SET_TO_NOP(op);
+                            --(p->len);
+                            ok = 0;
+                            break;
+                        }
+                        /* JMPNZ ?,L1  =>  JMPZNZ  ?,L2,L1
+                           JMP   L2        JMP     L2
+                        */
+                    } else if (p->follow->len == 1 && p->follow->start->opcode == ZEND_JMP) {
+                        BB* x_p = p->follow;
+                        op->opcode = ZEND_JMPZNZ;
+                        if (p->jmp_2 != p->follow) {
+                            BB_DEL_PRED(p->follow, p);
+                            RM_BB(p->follow);
+                        }
+                        p->follow = NULL;
+                        p->jmp_ext = p->jmp_2;
+                        p->jmp_2 = x_p->jmp_1;
+                        BB_ADD_PRED(p->jmp_2, p);
+                        ok = 0;
+                        goto jmp_znz;
+                        /*     JMPNZ $x,L1  =>  JMPNZ $x,L2
+                               ...              ...
+                           L1: JMPNZ $x,L2      JMPNZ $x,L2
+                        */
+                    } else if (p->jmp_2->len == 1 &&
+                               OP1_TYPE(op) == IS_TMP_VAR) {
+                        if        (p->jmp_2->start->opcode == ZEND_JMPNZ &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_2;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz;
+                            /*     JMPNZ  $x,L1  =>  JMPNZ  $x,L1+1
+                                   ...               ...
+                               L1: JMPZ   $x,L2      JMPZ $x,L2
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_JMPZ &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz;
+                            /*     JMPNZ  $x,L1     =>  JMPNZ  $x,L3
+                                   ...                   ...
+                               L1: JMPZNZ $x,L2,L3      JMPZNZ $x,L2,L3
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_JMPZNZ &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   OP1_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_ext;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz;
+                        }
+                    }
+                    goto jmp_2;
+                case ZEND_JMPZ_EX:
+jmp_z_ex:
+                    /* L1: JMPZ_EX  $x,L1+1,$x  =>  NOP
+                    */
+                    if (p->follow == p->jmp_2 &&
+                            OP1_TYPE(op) == IS_TMP_VAR &&
+                            RES_TYPE(op) == IS_TMP_VAR &&
+                            OP1_VARR(op) == RES_VARR(op)) {
+                        p->jmp_2   = NULL;
+                        SET_TO_NOP(op);
+                        --(p->len);
+                        ok = 0;
+                        break;
+                        /* L1: JMPZ_EX  $x,L1+1,$y  =>  BOOL $x,$y
+                        */
+                    } else if (p->follow == p->jmp_2) {
+                        p->jmp_2   = NULL;
+                        op->opcode = ZEND_BOOL;
+                        OP2_TYPE(op) = IS_UNUSED;
+                        ok = 0;
+                        break;
+                    } else if (p->jmp_2->len == 1 &&
+                               RES_TYPE(op) == IS_TMP_VAR) {
+                        /*     JMPZ_EX ?,L1,$x  =>  JMPZ_EX ?,L2,$x
+                               ...                  ...
+                           L1: JMPZ    $x,L2        JMPZ    $x,L2
+                           ------------------------------------------
+                               JMPZ_EX ?,L1,$x  =>  JMPZ_EX ?,L2,$x
+                               ...                  ...
+                           L1: JMPZNZ  $x,L2,L3     JMPZNZ  $x,L2,L3
+                           ------------------------------------------
+                               JMPZ_EX ?,L1,$x  =>  JMPZ_EX ?,L2,$x
+                               ...                  ...
+                           L1: JMPZ_EX $x,L2,$x     JMPZ_EX $x,L2,$x
+                        */
+                        if       (((p->jmp_2->start->opcode == ZEND_JMPZ ||
+                                    p->jmp_2->start->opcode == ZEND_JMPZNZ) &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start)) ||
+                                  (p->jmp_2->start->opcode == ZEND_JMPZ_EX &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start) &&
+                                   RES_VARR(op) == RES_VARR(p->jmp_2->start))) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_2;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_z_ex;
+                            /*     JMPZ_EX ?,L1,$x   =>  JMPZ_EX ?,L2+1,$x
+                                   ...                   ...
+                               L1: JMPNZ    $x,L2        JMPNZ    $x,L2
+                               ------------------------------------------
+                                   JMPZ_EX ?,L1,$x   =>  JMPZ_EX  ?,L2+1,$x
+                                   ...                   ...
+                               L1: JMPNZ_EX $x,L2,$x     JMPNZ_EX $x,L2,$x
+                            */
+                        } else if ((p->jmp_2->start->opcode == ZEND_JMPNZ &&
+                                    OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_VARR(op) == OP1_VARR(p->jmp_2->start)) ||
+                                   (p->jmp_2->start->opcode == ZEND_JMPNZ_EX &&
+                                    OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_VARR(op) == OP1_VARR(p->jmp_2->start) &&
+                                    RES_VARR(op) == RES_VARR(p->jmp_2->start))) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_z_ex;
+                            /*     JMPZ_EX ?,L1,$x   =>  JMPZ_EX ?,L1+1,$y
+                                   ...                   ...
+                               L1: BOOL    $x,$y         BOOL    $x,$y
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_BOOL &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            memcpy(&op->result, &p->jmp_2->start->result, sizeof(p->jmp_2->start->result));
+#ifdef ZEND_ENGINE_2_4
+                            RES_TYPE(op) = RES_TYPE(p->jmp_2->start);
+#endif
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_z_ex;
+                            /*     JMPZ_EX ?,L1,$x   =>  JMPZ    ?,L1+1
+                                   ...                   ...
+                               L1: FREE    $x            FREE    $x
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_FREE &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            op->opcode = ZEND_JMPZ;
+                            RES_TYPE(op) = IS_UNUSED;
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_z;
+                        }
+                        /*     JMPZ_EX ?,L1,$x   =>  JMPZ ?,L1+1
+                               ...                   ...
+                           L1: FREE    $x            FREE $x
+                        */
+                    } else if (RES_TYPE(op) == IS_TMP_VAR &&
+                               p->jmp_2->start->opcode == ZEND_FREE &&
+                               OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                               RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                        if (p->jmp_2->len > 1) {
+                            /* splitting */
+                            BB* new_bb = (p->jmp_2+1);
+                            new_bb->used   = 1;
+                            new_bb->start  = p->jmp_2->start+1;
+                            new_bb->len    = p->jmp_2->len-1;
+                            p->jmp_2->len  = 1;
+                            new_bb->next   = p->jmp_2->next;
+                            p->jmp_2->next = new_bb;
+                            new_bb->pred   = NULL;
+                            if (p->jmp_2->jmp_1) {
+                                new_bb->jmp_1     = p->jmp_2->jmp_1;
+                                BB_ADD_PRED(new_bb->jmp_1, new_bb);
+                                BB_DEL_PRED(new_bb->jmp_1, p->jmp_2);
+                                p->jmp_2->jmp_1   = NULL;
+                            }
+                            if (p->jmp_2->jmp_2) {
+                                new_bb->jmp_2     = p->jmp_2->jmp_2;
+                                BB_ADD_PRED(new_bb->jmp_2, new_bb);
+                                BB_DEL_PRED(new_bb->jmp_2, p->jmp_2);
+                                p->jmp_2->jmp_2   = NULL;
+                            }
+                            if (p->jmp_2->jmp_ext) {
+                                new_bb->jmp_ext     = p->jmp_2->jmp_ext;
+                                BB_ADD_PRED(new_bb->jmp_ext, new_bb);
+                                BB_DEL_PRED(new_bb->jmp_ext, p->jmp_2);
+                                p->jmp_2->jmp_ext   = NULL;
+                            }
+                            op->opcode = ZEND_JMPZ;
+                            RES_TYPE(op) = IS_UNUSED;
+                            if (p->jmp_2->follow) {
+                                new_bb->follow     = p->jmp_2->follow;
+                                BB_ADD_PRED(new_bb->follow, new_bb);
+                                BB_DEL_PRED(new_bb->follow, p->jmp_2);
+                                p->jmp_2->follow   = NULL;
+                            }
+                            p->jmp_2->follow = new_bb;
+                            BB_ADD_PRED(p->jmp_2->follow, p->jmp_2);
+                        }
+                        if (p->jmp_2 != p->follow) {
+                            BB_DEL_PRED(p->jmp_2, p);
+                            RM_BB(p->jmp_2);
+                        }
+                        p->jmp_2 = p->jmp_2->follow;
+                        BB_ADD_PRED(p->jmp_2, p);
+                        ok = 0;
+                        goto jmp_z;
+                    }
+                    goto jmp_2;
+                case ZEND_JMPNZ_EX:
+jmp_nz_ex:
+                    /* L1: JMPNZ_EX  $x,L1+1,$x  =>  NOP
+                    */
+                    if (p->follow == p->jmp_2 &&
+                            OP1_TYPE(op) == IS_TMP_VAR &&
+                            RES_TYPE(op) == IS_TMP_VAR &&
+                            OP1_VARR(op) == RES_VARR(op)) {
+                        p->jmp_2   = NULL;
+                        SET_TO_NOP(op);
+                        --(p->len);
+                        ok = 0;
+                        break;
+                        /* L1: JMPNZ_EX  $x,L1+1,$y  =>  BOOL $x,$y
+                        */
+                    } else if (p->follow == p->jmp_2) {
+                        p->jmp_2   = NULL;
+                        op->opcode = ZEND_BOOL;
+                        OP2_TYPE(op) = IS_UNUSED;
+                        ok = 0;
+                        break;
+                    } else if (p->jmp_2->len == 1 &&
+                               RES_TYPE(op) == IS_TMP_VAR) {
+                        /*     JMPNZ_EX ?,L1,$x  =>  JMPNZ_EX ?,L2,$x
+                               ...                   ...
+                           L1: JMPNZ    $x,L2        JMPNZ    $x,L2
+                           ------------------------------------------
+                               JMPNZ_EX ?,L1,$x  =>  JMPNZ_EX ?,L2,$x
+                               ...                   ...
+                           L1: JMPNZ_EX $x,L2,$x     JMPNZ_EX $x,L2,$x
+                        */
+                        if        ((p->jmp_2->start->opcode == ZEND_JMPNZ &&
+                                    OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_VARR(op) == OP1_VARR(p->jmp_2->start)) ||
+                                   (p->jmp_2->start->opcode == ZEND_JMPNZ_EX &&
+                                    OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_VARR(op) == OP1_VARR(p->jmp_2->start) &&
+                                    RES_VARR(op) == RES_VARR(p->jmp_2->start))) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_2;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz_ex;
+                            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L3,$x
+                                   ...                    ...
+                               L1: JMPZNZ   $x,L2,L3      JMPZNZ   $x,L2,L3
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_JMPZNZ &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->jmp_ext;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz_ex;
+                            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L1+1,$x
+                                   ...                    ...
+                               L1: JMPZ    $x,L2          JMPZ    $x,L2
+                               ------------------------------------------
+                                   JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX  ?,L1+1,$x
+                                   ...                    ...
+                               L1: JMPZ_EX $x,L2,$x      JMPZ_EX $x,L2,$x
+                            */
+                        } else if ((p->jmp_2->start->opcode == ZEND_JMPZ &&
+                                    OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_VARR(op) == OP1_VARR(p->jmp_2->start)) ||
+                                   (p->jmp_2->start->opcode == ZEND_JMPZ_EX &&
+                                    OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                    RES_VARR(op) == OP1_VARR(p->jmp_2->start) &&
+                                    RES_VARR(op) == RES_VARR(p->jmp_2->start))) {
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz_ex;
+                            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L1+1,$y
+                                   ...                   ...
+                               L1: BOOL    $x,$y         BOOL    $x,$y
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_BOOL &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            memcpy(&op->result, &p->jmp_2->start->result, sizeof(p->jmp_2->start->result));
+#ifdef ZEND_ENGINE_2_4
+                            RES_TYPE(op) = RES_TYPE(p->jmp_2->start);
+#endif
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz_ex;
+                            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ ?,L1+1
+                                   ...                    ...
+                               L1: FREE    $x             FREE    $x
+                            */
+                        } else if (p->jmp_2->start->opcode == ZEND_FREE &&
+                                   OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                                   RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                            op->opcode = ZEND_JMPNZ;
+                            RES_TYPE(op) = IS_UNUSED;
+                            if (p->jmp_2 != p->follow) {
+                                BB_DEL_PRED(p->jmp_2, p);
+                                RM_BB(p->jmp_2);
+                            }
+                            p->jmp_2 = p->jmp_2->follow;
+                            BB_ADD_PRED(p->jmp_2, p);
+                            ok = 0;
+                            goto jmp_nz;
+                        }
+                        /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L1+1,$x
+                               ...                    ...
+                           L1: FREE    $x             FREE    $x
+                        */
+                    } else if (RES_TYPE(op) == IS_TMP_VAR &&
+                               p->jmp_2->start->opcode == ZEND_FREE &&
+                               OP1_TYPE(p->jmp_2->start) == IS_TMP_VAR &&
+                               RES_VARR(op) == OP1_VARR(p->jmp_2->start)) {
+                        if (p->jmp_2->len > 1) {
+                            /* splitting */
+                            BB* new_bb = (p->jmp_2+1);
+                            new_bb->used   = 1;
+                            new_bb->start  = p->jmp_2->start+1;
+                            new_bb->len    = p->jmp_2->len-1;
+                            p->jmp_2->len  = 1;
+                            new_bb->next   = p->jmp_2->next;
+                            p->jmp_2->next = new_bb;
+                            new_bb->pred   = NULL;
+                            if (p->jmp_2->jmp_1) {
+                                new_bb->jmp_1     = p->jmp_2->jmp_1;
+                                BB_ADD_PRED(new_bb->jmp_1, new_bb);
+                                BB_DEL_PRED(new_bb->jmp_1, p->jmp_2);
+                                p->jmp_2->jmp_1   = NULL;
+                            }
+                            if (p->jmp_2->jmp_2) {
+                                new_bb->jmp_2     = p->jmp_2->jmp_2;
+                                BB_ADD_PRED(new_bb->jmp_2, new_bb);
+                                BB_DEL_PRED(new_bb->jmp_2, p->jmp_2);
+                                p->jmp_2->jmp_2   = NULL;
+                            }
+                            if (p->jmp_2->jmp_ext) {
+                                new_bb->jmp_ext     = p->jmp_2->jmp_ext;
+                                BB_ADD_PRED(new_bb->jmp_ext, new_bb);
+                                BB_DEL_PRED(new_bb->jmp_ext, p->jmp_2);
+                                p->jmp_2->jmp_ext   = NULL;
+                            }
+                            if (p->jmp_2->follow) {
+                                new_bb->follow     = p->jmp_2->follow;
+                                BB_ADD_PRED(new_bb->follow, new_bb);
+                                BB_DEL_PRED(new_bb->follow, p->jmp_2);
+                                p->jmp_2->follow   = NULL;
+                            }
+                            p->jmp_2->follow = new_bb;
+                            BB_ADD_PRED(p->jmp_2->follow, p->jmp_2);
+                        }
+                        op->opcode = ZEND_JMPNZ;
+                        RES_TYPE(op) = IS_UNUSED;
+                        if (p->jmp_2 != p->follow) {
+                            BB_DEL_PRED(p->jmp_2, p);
+                            RM_BB(p->jmp_2);
+                        }
+                        p->jmp_2 = p->jmp_2->follow;
+                        BB_ADD_PRED(p->jmp_2, p);
+                        ok = 0;
+                        goto jmp_nz;
+                    }
+                    goto jmp_2;
+                case ZEND_NEW:
+                case ZEND_FE_FETCH:
+jmp_2:
+                    while (p->jmp_2->len == 1 && p->jmp_2->start->opcode == ZEND_JMP) {
+                        BB* x_p = p->jmp_2;
+                        if (p->jmp_2 != p->follow) {
+                            BB_DEL_PRED(p->jmp_2, p);
+                            RM_BB(x_p);
+                        }
+                        p->jmp_2 = x_p->jmp_1;
+                        BB_ADD_PRED(p->jmp_2, p);
+                        ok = 0;
+                    }
                 }
-                p->jmp_2   = NULL;
-                SET_TO_NOP(op);
-                --(p->len);
-                ok = 0;
-                break;
-              }
-            /* JMPZ ?,L1  =>  JMPZNZ  ?,L1,L2
-               JMP  L2        JMP     L2
-            */
-            } else if (p->follow->len == 1 && p->follow->start->opcode == ZEND_JMP) {
-              BB* x_p = p->follow;
-              op->opcode = ZEND_JMPZNZ;
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->follow, p);
-                RM_BB(x_p);
-              }
-              p->follow = NULL;
-              p->jmp_ext = x_p->jmp_1;
-              BB_ADD_PRED(p->jmp_ext, p);
-              ok = 0;
-              goto jmp_znz;
-            } else if (p->jmp_2->len == 1 &&
-                       op->op1.op_type == IS_TMP_VAR) {
-            /*     JMPZ $x,L1  =>  JMPZ $x,L2
-                   ...             ...
-               L1: JMPZ $x,L2      JMPZ $x,L2
-               ----------------------------------------
-                   JMPZ   $x,L1     =>  JMPZ  $x,L2
-                   ...                   ...
-               L1: JMPZNZ $x,L2,L3      JMPZNZ $x,L2,L3
-            */
-            if       ((p->jmp_2->start->opcode == ZEND_JMPZ ||
-                       p->jmp_2->start->opcode == ZEND_JMPZNZ) &&
-                      p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                      op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_2;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z;
-            /*     JMPZ  $x,L1  =>  JMPZ  $x,L1+1
-                   ...              ...
-               L1: JMPNZ $x,L2      JMPNZ $x,L2
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_JMPNZ &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z;
-            }
             }
-            goto jmp_2;
-          case ZEND_JMPNZ:
-jmp_nz:
-            /* L1: JMPNZ  ?,L1+1  =>  NOP
-            */
-            if (p->follow == p->jmp_2) {
-              p->jmp_2   = NULL;
-              SET_TO_NOP(op);
-              --(p->len);
-              ok = 0;
-              break;
-            } else if (op->op1.op_type == IS_CONST) {
-              /* JMPNZ  1,L1  =>  JMP L1
-              */
-              if (zend_is_true(&op->op1.u.constant)) {
-                op->opcode = ZEND_JMP;
-                op->op1.op_type = IS_UNUSED;
-                op->op2.op_type = IS_UNUSED;
-                if (p->follow != p->jmp_2) {
-                  BB_DEL_PRED(p->follow, p);
-                  RM_BB(p->follow);
-                }
-                p->jmp_1  = p->jmp_2;
-                p->jmp_2  = NULL;
-                p->follow = NULL;
-                ok = 0;
-                goto jmp;
-              /* JMPNZ  0,L1  =>  NOP
-              */
-              } else {
-                if (p->follow != p->jmp_2) {
-                  BB_DEL_PRED(p->jmp_2, p);
-                  RM_BB(p->jmp_2);
+
+            /* Merging Basic Blocks */
+            if (p->used && p->pred != NULL && p->pred->bb->used && p->pred->next == NULL &&
+                    p->pred->bb->follow == p &&
+                    p->pred->bb->next == p &&
+                    p->pred->bb->jmp_1 == NULL &&
+                    p->pred->bb->jmp_2 == NULL &&
+                    p->pred->bb->jmp_ext == NULL &&
+                    /* HOESH: See structure declaration */
+                    p->protect_merge == 0) {
+                BB* x = p->pred->bb;
+                BB_DEL_PRED(p, x);
+                x->len = &p->start[p->len] - x->start;
+                if (p->jmp_1 != NULL) {
+                    x->jmp_1 = p->jmp_1;
+                    BB_DEL_PRED(p->jmp_1, p);
+                    BB_ADD_PRED(p->jmp_1, x);
                 }
-                p->jmp_2   = NULL;
-                SET_TO_NOP(op);
-                --(p->len);
+                if (p->jmp_2 != NULL) {
+                    x->jmp_2   = p->jmp_2;
+                    BB_DEL_PRED(p->jmp_2, p);
+                    BB_ADD_PRED(p->jmp_2, x);
+                }
+                if (p->jmp_ext != NULL) {
+                    x->jmp_ext   = p->jmp_ext;
+                    BB_DEL_PRED(p->jmp_ext, p);
+                    BB_ADD_PRED(p->jmp_ext, x);
+                }
+                x->follow  = p->follow;
+                if (p->follow != NULL) {
+                    BB_DEL_PRED(p->follow, p);
+                    BB_ADD_PRED(p->follow, x);
+                }
+                p->used  = 0;
+                p->len   = 0;
                 ok = 0;
-                break;
-              }
-            /* JMPNZ ?,L1  =>  JMPZNZ  ?,L2,L1
-               JMP   L2        JMP     L2
-            */
-            } else if (p->follow->len == 1 && p->follow->start->opcode == ZEND_JMP) {
-              BB* x_p = p->follow;
-              op->opcode = ZEND_JMPZNZ;
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->follow, p);
-                RM_BB(p->follow);
-              }
-              p->follow = NULL;
-              p->jmp_ext = p->jmp_2;
-              p->jmp_2 = x_p->jmp_1;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_znz;
-            /*     JMPNZ $x,L1  =>  JMPNZ $x,L2
-                   ...              ...
-               L1: JMPNZ $x,L2      JMPNZ $x,L2
-            */
-            } else if (p->jmp_2->len == 1 &&
-                       op->op1.op_type == IS_TMP_VAR) {
-            if        (p->jmp_2->start->opcode == ZEND_JMPNZ &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_2;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz;
-            /*     JMPNZ  $x,L1  =>  JMPNZ  $x,L1+1
-                   ...               ...
-               L1: JMPZ   $x,L2      JMPZ $x,L2
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_JMPZ &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz;
-            /*     JMPNZ  $x,L1     =>  JMPNZ  $x,L3
-                   ...                   ...
-               L1: JMPZNZ $x,L2,L3      JMPZNZ $x,L2,L3
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_JMPZNZ &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->op1.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_ext;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz;
             }
-            }
-            goto jmp_2;
-          case ZEND_JMPZ_EX:
-jmp_z_ex:
-            /* L1: JMPZ_EX  $x,L1+1,$x  =>  NOP
-            */
-            if (p->follow == p->jmp_2 &&
-                op->op1.op_type == IS_TMP_VAR &&
-                op->result.op_type == IS_TMP_VAR &&
-                op->op1.u.var == op->result.u.var) {
-              p->jmp_2   = NULL;
-              SET_TO_NOP(op);
-              --(p->len);
-              ok = 0;
-              break;
-            /* L1: JMPZ_EX  $x,L1+1,$y  =>  BOOL $x,$y
-            */
-            } else if (p->follow == p->jmp_2) {
-              p->jmp_2   = NULL;
-              op->opcode = ZEND_BOOL;
-              op->op2.op_type = IS_UNUSED;
-              ok = 0;
-              break;
-            } else if (p->jmp_2->len == 1 &&
-                       op->result.op_type == IS_TMP_VAR) {
-            /*     JMPZ_EX ?,L1,$x  =>  JMPZ_EX ?,L2,$x
-                   ...                  ...
-               L1: JMPZ    $x,L2        JMPZ    $x,L2
-               ------------------------------------------
-                   JMPZ_EX ?,L1,$x  =>  JMPZ_EX ?,L2,$x
-                   ...                  ...
-               L1: JMPZNZ  $x,L2,L3     JMPZNZ  $x,L2,L3
-               ------------------------------------------
-                   JMPZ_EX ?,L1,$x  =>  JMPZ_EX ?,L2,$x
-                   ...                  ...
-               L1: JMPZ_EX $x,L2,$x     JMPZ_EX $x,L2,$x
-            */
-            if       (((p->jmp_2->start->opcode == ZEND_JMPZ ||
-                         p->jmp_2->start->opcode == ZEND_JMPZNZ) &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var) ||
-                       (p->jmp_2->start->opcode == ZEND_JMPZ_EX &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        p->jmp_2->start->result.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var &&
-                        op->result.u.var == p->jmp_2->start->result.u.var)) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_2;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z_ex;
-            /*     JMPZ_EX ?,L1,$x   =>  JMPZ_EX ?,L2+1,$x
-                   ...                   ...
-               L1: JMPNZ    $x,L2        JMPNZ    $x,L2
-               ------------------------------------------
-                   JMPZ_EX ?,L1,$x   =>  JMPZ_EX  ?,L2+1,$x
-                   ...                   ...
-               L1: JMPNZ_EX $x,L2,$x     JMPNZ_EX $x,L2,$x
-            */
-            } else if ((p->jmp_2->start->opcode == ZEND_JMPNZ &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var) ||
-                       (p->jmp_2->start->opcode == ZEND_JMPNZ_EX &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        p->jmp_2->start->result.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var &&
-                        op->result.u.var == p->jmp_2->start->result.u.var)) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z_ex;
-            /*     JMPZ_EX ?,L1,$x   =>  JMPZ_EX ?,L1+1,$y
-                   ...                   ...
-               L1: BOOL    $x,$y         BOOL    $x,$y
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_BOOL &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              memcpy(&op->result, &p->jmp_2->start->result, sizeof(zval));
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z_ex;
-            /*     JMPZ_EX ?,L1,$x   =>  JMPZ    ?,L1+1
-                   ...                   ...
-               L1: FREE    $x            FREE    $x
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_FREE &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              op->opcode = ZEND_JMPZ;
-              op->result.op_type = IS_UNUSED;
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z;
-            }
-            /*     JMPZ_EX ?,L1,$x   =>  JMPZ ?,L1+1
-                   ...                   ...
-               L1: FREE    $x            FREE $x
-            */
-            } else if (op->result.op_type == IS_TMP_VAR &&
-                       p->jmp_2->start->opcode == ZEND_FREE &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2->len > 1) {
-                /* splitting */
-                BB* new_bb = (p->jmp_2+1);
-                new_bb->used   = 1;
-                new_bb->start  = p->jmp_2->start+1;
-                new_bb->len    = p->jmp_2->len-1;
-                p->jmp_2->len  = 1;
-                new_bb->next   = p->jmp_2->next;
-                p->jmp_2->next = new_bb;
-                new_bb->pred   = NULL;
-                if (p->jmp_2->jmp_1) {
-                  new_bb->jmp_1     = p->jmp_2->jmp_1;
-                  BB_ADD_PRED(new_bb->jmp_1, new_bb);
-                  BB_DEL_PRED(new_bb->jmp_1, p->jmp_2);
-                  p->jmp_2->jmp_1   = NULL;
-                }
-                if (p->jmp_2->jmp_2) {
-                  new_bb->jmp_2     = p->jmp_2->jmp_2;
-                  BB_ADD_PRED(new_bb->jmp_2, new_bb);
-                  BB_DEL_PRED(new_bb->jmp_2, p->jmp_2);
-                  p->jmp_2->jmp_2   = NULL;
-                }
-                if (p->jmp_2->jmp_ext) {
-                  new_bb->jmp_ext     = p->jmp_2->jmp_ext;
-                  BB_ADD_PRED(new_bb->jmp_ext, new_bb);
-                  BB_DEL_PRED(new_bb->jmp_ext, p->jmp_2);
-                  p->jmp_2->jmp_ext   = NULL;
+
+            p = p->next;
+        }
+
+        if (ok) {
+            /* Eliminate JMP to RETURN or EXIT */
+            p = bb;
+            while (p != NULL) {
+                if (p->used && p->len > 0) {
+                    zend_op* op = &p->start[p->len-1];
+                    if (op->opcode == ZEND_JMP &&
+                            p->jmp_1->len == 1 &&
+                            (p->jmp_1->start->opcode == ZEND_RETURN ||
+#ifdef ZEND_ENGINE_2_4
+                             p->jmp_1->start->opcode == ZEND_RETURN_BY_REF ||
+#endif
+                             p->jmp_1->start->opcode == ZEND_EXIT)) {
+                        if (op->extended_value == ZEND_BRK || op->extended_value == ZEND_CONT) {
+                            op->extended_value = 0;
+                        } else {
+                            BB_DEL_PRED(p->jmp_1, p);
+                            RM_BB(p->jmp_1);
+                            memcpy(op, p->jmp_1->start, sizeof(zend_op));
+                            if (OP1_TYPE(op) == IS_CONST) {
+                                zval_copy_ctor(&OP1_CONST(op));
+                            }
+                            p->jmp_1 = NULL;
+                            ok = 0;
+                        }
+                    }
                 }
-                op->opcode = ZEND_JMPZ;
-                op->result.op_type = IS_UNUSED;
-                if (p->jmp_2->follow) {
-                  new_bb->follow     = p->jmp_2->follow;
-                  BB_ADD_PRED(new_bb->follow, new_bb);
-                  BB_DEL_PRED(new_bb->follow, p->jmp_2);
-                  p->jmp_2->follow   = NULL;
-                }
-                p->jmp_2->follow = new_bb;
-                BB_ADD_PRED(p->jmp_2->follow, p->jmp_2);
-              }
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_z;
-            }
-            goto jmp_2;
-          case ZEND_JMPNZ_EX:
-jmp_nz_ex:
-            /* L1: JMPNZ_EX  $x,L1+1,$x  =>  NOP
-            */
-            if (p->follow == p->jmp_2 &&
-                op->op1.op_type == IS_TMP_VAR &&
-                op->result.op_type == IS_TMP_VAR &&
-                op->op1.u.var == op->result.u.var) {
-              p->jmp_2   = NULL;
-              SET_TO_NOP(op);
-              --(p->len);
-              ok = 0;
-              break;
-            /* L1: JMPNZ_EX  $x,L1+1,$y  =>  BOOL $x,$y
-            */
-            } else if (p->follow == p->jmp_2) {
-              p->jmp_2   = NULL;
-              op->opcode = ZEND_BOOL;
-              op->op2.op_type = IS_UNUSED;
-              ok = 0;
-              break;
-            } else if (p->jmp_2->len == 1 &&
-                       op->result.op_type == IS_TMP_VAR) {
-            /*     JMPNZ_EX ?,L1,$x  =>  JMPNZ_EX ?,L2,$x
-                   ...                   ...
-               L1: JMPNZ    $x,L2        JMPNZ    $x,L2
-               ------------------------------------------
-                   JMPNZ_EX ?,L1,$x  =>  JMPNZ_EX ?,L2,$x
-                   ...                   ...
-               L1: JMPNZ_EX $x,L2,$x     JMPNZ_EX $x,L2,$x
-            */
-            if        ((p->jmp_2->start->opcode == ZEND_JMPNZ &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var) ||
-                       (p->jmp_2->start->opcode == ZEND_JMPNZ_EX &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        p->jmp_2->start->result.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var &&
-                        op->result.u.var == p->jmp_2->start->result.u.var)) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_2;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz_ex;
-            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L3,$x
-                   ...                    ...
-               L1: JMPZNZ   $x,L2,L3      JMPZNZ   $x,L2,L3
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_JMPZNZ &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->jmp_ext;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz_ex;
-            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L1+1,$x
-                   ...                    ...
-               L1: JMPZ    $x,L2          JMPZ    $x,L2
-               ------------------------------------------
-                   JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX  ?,L1+1,$x
-                   ...                    ...
-               L1: JMPZ_EX $x,L2,$x      JMPZ_EX $x,L2,$x
-            */
-            } else if ((p->jmp_2->start->opcode == ZEND_JMPZ &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var) ||
-                       (p->jmp_2->start->opcode == ZEND_JMPZ_EX &&
-                        p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                        p->jmp_2->start->result.op_type == IS_TMP_VAR &&
-                        op->result.u.var == p->jmp_2->start->op1.u.var &&
-                        op->result.u.var == p->jmp_2->start->result.u.var)) {
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz_ex;
-            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L1+1,$y
-                   ...                   ...
-               L1: BOOL    $x,$y         BOOL    $x,$y
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_BOOL &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              memcpy(&op->result, &p->jmp_2->start->result, sizeof(zval));
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz_ex;
-            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ ?,L1+1
-                   ...                    ...
-               L1: FREE    $x             FREE    $x
-            */
-            } else if (p->jmp_2->start->opcode == ZEND_FREE &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              op->opcode = ZEND_JMPNZ;
-              op->result.op_type = IS_UNUSED;
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz;
-            }
-            /*     JMPNZ_EX ?,L1,$x   =>  JMPNZ_EX ?,L1+1,$x
-                   ...                    ...
-               L1: FREE    $x             FREE    $x
-            */
-            } else if (op->result.op_type == IS_TMP_VAR &&
-                       p->jmp_2->start->opcode == ZEND_FREE &&
-                       p->jmp_2->start->op1.op_type == IS_TMP_VAR &&
-                       op->result.u.var == p->jmp_2->start->op1.u.var) {
-              if (p->jmp_2->len > 1) {
-                /* splitting */
-                BB* new_bb = (p->jmp_2+1);
-                new_bb->used   = 1;
-                new_bb->start  = p->jmp_2->start+1;
-                new_bb->len    = p->jmp_2->len-1;
-                p->jmp_2->len  = 1;
-                new_bb->next   = p->jmp_2->next;
-                p->jmp_2->next = new_bb;
-                new_bb->pred   = NULL;
-                if (p->jmp_2->jmp_1) {
-                  new_bb->jmp_1     = p->jmp_2->jmp_1;
-                  BB_ADD_PRED(new_bb->jmp_1, new_bb);
-                  BB_DEL_PRED(new_bb->jmp_1, p->jmp_2);
-                  p->jmp_2->jmp_1   = NULL;
-                }
-                if (p->jmp_2->jmp_2) {
-                  new_bb->jmp_2     = p->jmp_2->jmp_2;
-                  BB_ADD_PRED(new_bb->jmp_2, new_bb);
-                  BB_DEL_PRED(new_bb->jmp_2, p->jmp_2);
-                  p->jmp_2->jmp_2   = NULL;
-                }
-                if (p->jmp_2->jmp_ext) {
-                  new_bb->jmp_ext     = p->jmp_2->jmp_ext;
-                  BB_ADD_PRED(new_bb->jmp_ext, new_bb);
-                  BB_DEL_PRED(new_bb->jmp_ext, p->jmp_2);
-                  p->jmp_2->jmp_ext   = NULL;
-                }
-                if (p->jmp_2->follow) {
-                  new_bb->follow     = p->jmp_2->follow;
-                  BB_ADD_PRED(new_bb->follow, new_bb);
-                  BB_DEL_PRED(new_bb->follow, p->jmp_2);
-                  p->jmp_2->follow   = NULL;
-                }
-                p->jmp_2->follow = new_bb;
-                BB_ADD_PRED(p->jmp_2->follow, p->jmp_2);
-              }
-              op->opcode = ZEND_JMPNZ;
-              op->result.op_type = IS_UNUSED;
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(p->jmp_2);
-              }
-              p->jmp_2 = p->jmp_2->follow;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-              goto jmp_nz;
-            }
-            goto jmp_2;
-          case ZEND_NEW:
-          case ZEND_FE_FETCH:
-jmp_2:
-            while (p->jmp_2->len == 1 && p->jmp_2->start->opcode == ZEND_JMP) {
-              BB* x_p = p->jmp_2;
-              if (p->jmp_2 != p->follow) {
-                BB_DEL_PRED(p->jmp_2, p);
-                RM_BB(x_p);
-              }
-              p->jmp_2 = x_p->jmp_1;
-              BB_ADD_PRED(p->jmp_2, p);
-              ok = 0;
-            }
-        }
-      }
-
-      /* Merging Basic Blocks */
-      if (p->used && p->pred != NULL && p->pred->bb->used && p->pred->next == NULL &&
-          p->pred->bb->follow == p &&
-          p->pred->bb->next == p &&
-          p->pred->bb->jmp_1 == NULL &&
-          p->pred->bb->jmp_2 == NULL &&
-          p->pred->bb->jmp_ext == NULL &&
-		  /* HOESH: See structure declaration */
-		  p->protect_merge == 0)
-	  {
-        BB* x = p->pred->bb;
-        BB_DEL_PRED(p, x);
-        x->len = &p->start[p->len] - x->start;
-        if (p->jmp_1 != NULL) {
-          x->jmp_1 = p->jmp_1;
-          BB_DEL_PRED(p->jmp_1, p);
-          BB_ADD_PRED(p->jmp_1, x);
-        }
-        if (p->jmp_2 != NULL) {
-          x->jmp_2   = p->jmp_2;
-          BB_DEL_PRED(p->jmp_2, p);
-          BB_ADD_PRED(p->jmp_2, x);
-        }
-        if (p->jmp_ext != NULL) {
-          x->jmp_ext   = p->jmp_ext;
-          BB_DEL_PRED(p->jmp_ext, p);
-          BB_ADD_PRED(p->jmp_ext, x);
-        }
-        x->follow  = p->follow;
-        if (p->follow != NULL) {
-          BB_DEL_PRED(p->follow, p);
-          BB_ADD_PRED(p->follow, x);
-        }
-        p->used  = 0;
-        p->len   = 0;
-        ok = 0;
-      }
-
-      p = p->next;
-    }
-
-    if (ok) {
-      /* Eliminate JMP to RETURN or EXIT */
-      p = bb;
-      while (p != NULL) {
-        if (p->used && p->len > 0) {
-          zend_op* op = &p->start[p->len-1];
-          if (op->opcode == ZEND_JMP &&
-              p->jmp_1->len == 1 &&
-              (p->jmp_1->start->opcode == ZEND_RETURN ||
-               p->jmp_1->start->opcode == ZEND_EXIT))
-		  {
-		    if (op->extended_value == ZEND_BRK || op->extended_value == ZEND_CONT) {
-              op->extended_value = 0;
-		    } else {
-              BB_DEL_PRED(p->jmp_1, p);
-              RM_BB(p->jmp_1);
-              memcpy(op, p->jmp_1->start, sizeof(zend_op));
-              if (op->op1.op_type == IS_CONST)
-			  {
-                zval_copy_ctor(&op->op1.u.constant);
-              }
-              p->jmp_1 = NULL;
-              ok = 0;
+                p = p->next;
             }
-          }
         }
-        p = p->next;
-      }
-    }
-    if (ok) {
-      break;
+        if (ok) {
+            break;
+        }
     }
-  }
 }
 
-static int opt_get_constant(const char* name, int name_len, zend_constant** result TSRMLS_DC) {
-  union {
-    zend_constant *v;
-    void *ptr;
-  } c;
-  int retval;
-#ifdef ZEND_ENGINE_2_3
-  ALLOCA_FLAG(use_heap)
-  char *lookup_name = do_alloca(name_len+1, use_heap);
-#else
-  char *lookup_name = do_alloca(name_len+1);
-#endif
-  memcpy(lookup_name, name, name_len);
-  lookup_name[name_len] = '\0';
-
-  if (zend_hash_find(EG(zend_constants), lookup_name, name_len+1, &c.ptr)==SUCCESS) {
-    *result = c.v;
-    retval=1;
-  } else {
-    zend_str_tolower(lookup_name, name_len);
+static int opt_get_constant(const char* name, int name_len, zend_constant** result TSRMLS_DC)
+{
+    union {
+        zend_constant *v;
+        void *ptr;
+    } c;
+    int retval;
+#ifdef ZEND_ENGINE_2_3
+    ALLOCA_FLAG(use_heap)
+    char *lookup_name = do_alloca(name_len+1, use_heap);
+#else
+    char *lookup_name = do_alloca(name_len+1);
+#endif
+    memcpy(lookup_name, name, name_len);
+    lookup_name[name_len] = '\0';
 
     if (zend_hash_find(EG(zend_constants), lookup_name, name_len+1, &c.ptr)==SUCCESS) {
-      if ((c.v->flags & CONST_CS) && (memcmp(c.v->name, name, name_len)!=0)) {
-        retval=0;
-      } else {
         *result = c.v;
         retval=1;
-      }
     } else {
-      retval=0;
+        zend_str_tolower(lookup_name, name_len);
+
+        if (zend_hash_find(EG(zend_constants), lookup_name, name_len+1, &c.ptr)==SUCCESS) {
+            if ((c.v->flags & CONST_CS) && (memcmp(c.v->name, name, name_len)!=0)) {
+                retval=0;
+            } else {
+                *result = c.v;
+                retval=1;
+            }
+        } else {
+            retval=0;
+        }
     }
-  }
 #ifdef ZEND_ENGINE_2_3
-  free_alloca(lookup_name, use_heap);
+    free_alloca(lookup_name, use_heap);
 #else
-  free_alloca(lookup_name);
+    free_alloca(lookup_name);
 #endif
-  return retval;
+    return retval;
 }
 
-static int opt_function_exists(const char* name, int name_len TSRMLS_DC) {
-  char *lcname;
-  char *lcfname;
-  Bucket *p;
-
-  lcname = estrndup(name,name_len+1);
-  zend_str_tolower(lcname, name_len);
-  p = module_registry.pListHead;
-  while (p != NULL) {
-    zend_module_entry *m = (zend_module_entry*)p->pData;
-    if (m->type == MODULE_PERSISTENT) {
+static int opt_function_exists(const char* name, int name_len TSRMLS_DC)
+{
+    char *lcname;
+    char *lcfname;
+    Bucket *p;
+
+    lcname = estrndup(name,name_len+1);
+    zend_str_tolower(lcname, name_len);
+    p = module_registry.pListHead;
+    while (p != NULL) {
+        zend_module_entry *m = (zend_module_entry*)p->pData;
+        if (m->type == MODULE_PERSISTENT) {
 #ifdef ZEND_ENGINE_2_3
-      const zend_function_entry* f = m->functions;
+            const zend_function_entry* f = m->functions;
 #else
-      zend_function_entry* f = m->functions;
+            zend_function_entry* f = m->functions;
 #endif
-      if (f != NULL) {
-        while (f->fname) {
-        lcfname = estrdup(f->fname);
-        zend_str_tolower(lcfname, strlen(lcfname));
-        if (strcmp(lcname,lcfname) == 0) {
-          efree(lcfname);
-          efree(lcname);
-          return 1;
-        }
-          efree(lcfname);
-          f++;
+            if (f != NULL) {
+                while (f->fname) {
+                    lcfname = estrdup(f->fname);
+                    zend_str_tolower(lcfname, strlen(lcfname));
+                    if (strcmp(lcname,lcfname) == 0) {
+                        efree(lcfname);
+                        efree(lcname);
+                        return 1;
+                    }
+                    efree(lcfname);
+                    f++;
+                }
+            }
         }
-      }
+        p = p->pListNext;
     }
-    p = p->pListNext;
-  }
-  efree(lcname);
-  return 0;
+    efree(lcname);
+    return 0;
 }
 
-static int opt_extension_loaded(const char* name, int name_len TSRMLS_DC) {
-  Bucket *p = module_registry.pListHead;
-  while (p != NULL) {
-    zend_module_entry *m = (zend_module_entry*)p->pData;
-    if (m->type == MODULE_PERSISTENT && strcmp(m->name,name) == 0) {
-      return 1;
+static int opt_extension_loaded(const char* name, int name_len TSRMLS_DC)
+{
+    Bucket *p = module_registry.pListHead;
+    while (p != NULL) {
+        zend_module_entry *m = (zend_module_entry*)p->pData;
+        if (m->type == MODULE_PERSISTENT && strcmp(m->name,name) == 0) {
+            return 1;
+        }
+        p = p->pListNext;
     }
-    p = p->pListNext;
-  }
-  return 0;
+    return 0;
 }
 
-static int opt_result_is_numeric(zend_op* x) {
-  switch (x->opcode) {
+static int opt_result_is_numeric(zend_op* op, zend_op_array* op_array)
+{
+    switch (op->opcode) {
     case ZEND_ADD:
     case ZEND_SUB:
     case ZEND_MUL:
@@ -1480,19 +1491,23 @@
     case ZEND_MOD:
     case ZEND_SL:
     case ZEND_SR:
+
     case ZEND_BOOL:
     case ZEND_BOOL_NOT:
     case ZEND_BOOL_XOR:
+
     case ZEND_IS_IDENTICAL:
     case ZEND_IS_NOT_IDENTICAL:
     case ZEND_IS_EQUAL:
     case ZEND_IS_NOT_EQUAL:
     case ZEND_IS_SMALLER:
     case ZEND_IS_SMALLER_OR_EQUAL:
+
     case ZEND_PRE_DEC:
     case ZEND_PRE_INC:
     case ZEND_POST_DEC:
     case ZEND_POST_INC:
+
     case ZEND_ASSIGN_ADD:
     case ZEND_ASSIGN_SUB:
     case ZEND_ASSIGN_MUL:
@@ -1500,240 +1515,286 @@
     case ZEND_ASSIGN_MOD:
     case ZEND_ASSIGN_SL:
     case ZEND_ASSIGN_SR:
-      return 1;
-    case ZEND_CAST:
-      if (x->extended_value == IS_BOOL ||
-          x->extended_value == IS_LONG ||
-          x->extended_value == IS_DOUBLE) {
         return 1;
-      }
-      return 0;
+
+    case ZEND_CAST:
+        if (op->extended_value == IS_BOOL ||
+                op->extended_value == IS_LONG ||
+                op->extended_value == IS_DOUBLE) {
+            return 1;
+        }
+        return 0;
+
     case ZEND_DO_FCALL:
-      /* list generated in ext/standard with:
-         grep "proto int" *| awk '{ print $5}'|sed -r 's/^(.+)\((.*)/\1/'|sort -u
-         + some function aliases and other frequently used funcs
-      */
-      if (x->op1.op_type == IS_CONST &&
-          x->op1.u.constant.type == IS_STRING &&
-          (strcmp(x->op1.u.constant.value.str.val,"abs") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"array_push") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"array_unshift") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"assert") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"bindec") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"connection_aborted") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"connection_status") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"count") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"dl") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"extract") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"ezmlm_hash") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"file_put_contents") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fileatime") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"filectime") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"filegroup") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fileinode") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"filemtime") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fileowner") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fileperms") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"filesize") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fpassthru") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fprintf") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fputcsv") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fseek") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"ftell") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"ftok") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fwrite") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"get_magic_quotes_gpc") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"get_magic_quotes_runtime") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getlastmod") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getmygid") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getmyinode") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getmypid") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getmyuid") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getprotobyname") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getrandmax") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"getservbyname") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"hexdec") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"ignore_user_abort") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"intval") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"ip2long") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"levenshtein") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"link") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"linkinfo") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"mail") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"memory_get_peak_usage") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"memory_get_usage") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"mt_getrandmax") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"mt_rand") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"octdec") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"ord") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"pclose") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"printf") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"proc_close") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"rand") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"readfile") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"similar_text") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strcasecmp") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strcoll") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strcmp") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strcspn") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"stream_select") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"stream_set_write_buffer") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"stream_socket_enable_crypto") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"stream_socket_shutdown") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"stripos") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strlen") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strnatcasecmp") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strnatcmp") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strncmp") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strpos") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strripos") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strrpos") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"strspn") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"substr_compare") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"substr_count") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"symlink") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"system") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"umask") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"version_compare") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"vfprintf") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"vprintf") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"fputs") == 0 ||		/* func alias of fwrite */
-           strcmp(x->op1.u.constant.value.str.val,"set_file_buffer") == 0 ||	/* func alias of stream_set_write_buffer */
-           strcmp(x->op1.u.constant.value.str.val,"sizeof") == 0 ||		/* func alias of count */
-           strcmp(x->op1.u.constant.value.str.val,"ereg") == 0 ||
-           strcmp(x->op1.u.constant.value.str.val,"eregi") == 0)) {
-        return 1;
-      }
-      return 0;
+        /* list generated in ext/standard with:
+           grep "proto int" *| awk '{ print $5}'|sed -r 's/^(.+)\((.*)/\1/'|sort -u
+           + some function aliases and other frequently used funcs
+        */
+        if (OP1_TYPE(op) == IS_CONST &&
+                Z_TYPE(OP1_CONST(op)) == IS_STRING &&
+                (strcmp(Z_STRVAL(OP1_CONST(op)),"abs") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"array_push") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"array_unshift") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"assert") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"bindec") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"connection_aborted") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"connection_status") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"count") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"dl") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"extract") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ezmlm_hash") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"file_put_contents") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fileatime") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"filectime") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"filegroup") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fileinode") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"filemtime") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fileowner") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fileperms") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"filesize") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fpassthru") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fprintf") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fputcsv") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fseek") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ftell") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ftok") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fwrite") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"get_magic_quotes_gpc") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"get_magic_quotes_runtime") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getlastmod") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getmygid") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getmyinode") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getmypid") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getmyuid") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getprotobyname") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getrandmax") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"getservbyname") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"hexdec") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ignore_user_abort") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"intval") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ip2long") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"levenshtein") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"link") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"linkinfo") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"mail") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"memory_get_peak_usage") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"memory_get_usage") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"mt_getrandmax") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"mt_rand") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"octdec") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ord") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"pclose") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"printf") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"proc_close") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"rand") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"readfile") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"similar_text") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strcasecmp") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strcoll") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strcmp") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strcspn") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stream_select") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stream_set_chunk_size") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stream_set_read_buffer") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stream_set_write_buffer") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stream_socket_enable_crypto") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stream_socket_shutdown") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"stripos") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strlen") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strnatcasecmp") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strnatcmp") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strncmp") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strpos") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strripos") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strrpos") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"strspn") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"substr_compare") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"substr_count") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"symlink") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"system") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"umask") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"version_compare") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"vfprintf") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"vprintf") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"fputs") == 0 ||		/* func alias of fwrite */
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"set_file_buffer") == 0 ||	/* func alias of stream_set_write_buffer */
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"sizeof") == 0 ||		/* func alias of count */
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"ereg") == 0 ||
+                 strcmp(Z_STRVAL(OP1_CONST(op)),"eregi") == 0)) {
+            return 1;
+        }
+        return 0;
+
     default:
-      return 0;
-  }
-  return 0;
+        return 0;
+    }
+    return 0;
 }
 
+#ifdef ZEND_ENGINE_2_4
+/* Fetch types moved to op->extended_value in php 5.4.0 */
+#define FETCH_TYPE(op) ((op)->extended_value)
+#define SET_UNDEFINED(op) Ts[VAR_NUM((op).var)] = NULL;
+#define SET_DEFINED(op)   Ts[VAR_NUM((op)->result.var)] = (op);
+#define IS_DEFINED(op)    (Ts[VAR_NUM((op).var)] != NULL)
+#define DEFINED_OP(op)    (Ts[VAR_NUM((op).var)])
+#else
 #define FETCH_TYPE(op) ((op)->op2.u.EA.type)
 #define SET_UNDEFINED(op) Ts[VAR_NUM((op).u.var)] = NULL;
 #define SET_DEFINED(op)   Ts[VAR_NUM((op)->result.u.var)] = (op);
 #define IS_DEFINED(op)    (Ts[VAR_NUM((op).u.var)] != NULL)
 #define DEFINED_OP(op)    (Ts[VAR_NUM((op).u.var)])
+#endif
 
 static void optimize_bb(BB* bb, zend_op_array* op_array, char* global, int pass TSRMLS_DC)
 {
-  zend_op* prev = NULL;
-  zend_op* op = bb->start;
-  zend_op* end = op + bb->len;
-
-  HashTable assigns;
-  HashTable fetch_dim;
-
-#ifdef ZEND_ENGINE_2_3
-  ALLOCA_FLAG(use_heap)
-  zend_op** Ts = do_alloca(sizeof(zend_op*)*op_array->T, use_heap);
-#else
-  zend_op** Ts = do_alloca(sizeof(zend_op*)*op_array->T);
-#endif
-  memset(Ts, 0, sizeof(zend_op*)*op_array->T);
-
-  zend_hash_init(&assigns, 0, NULL, NULL, 0);
-  zend_hash_init(&fetch_dim, 0, NULL, NULL, 0);
-
-  while (op < end) {
-    /* Constant Folding */
-    if (op->op1.op_type == IS_TMP_VAR &&
-        IS_DEFINED(op->op1) &&
-        DEFINED_OP(op->op1)->opcode == ZEND_QM_ASSIGN &&
-        DEFINED_OP(op->op1)->op1.op_type == IS_CONST) {
-      zend_op *x = DEFINED_OP(op->op1);
-      if (op->opcode != ZEND_CASE) {
-        SET_UNDEFINED(op->op1);
-        memcpy(&op->op1, &x->op1, sizeof(znode));
-        SET_TO_NOP(x);
-      }
-    }
-    if (op->op2.op_type == IS_TMP_VAR &&
-        IS_DEFINED(op->op2) &&
-        DEFINED_OP(op->op2)->opcode == ZEND_QM_ASSIGN &&
-        DEFINED_OP(op->op2)->op1.op_type == IS_CONST) {
-      zend_op *x = DEFINED_OP(op->op2);
-      SET_UNDEFINED(op->op2);
-      memcpy(&op->op2, &x->op1, sizeof(znode));
-      SET_TO_NOP(x);
-    }
-
-    if (op->opcode == ZEND_IS_EQUAL) {
-      if (op->op1.op_type == IS_CONST &&
-          (op->op1.u.constant.type == IS_BOOL &&
-           op->op1.u.constant.value.lval == 0)) {
-        op->opcode = ZEND_BOOL_NOT;
-        memcpy(&op->op1, &op->op2, sizeof(znode));
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op1.op_type == IS_CONST &&
-                 op->op1.u.constant.type == IS_BOOL &&
-                 op->op1.u.constant.value.lval == 1) {
-        op->opcode = ZEND_BOOL;
-        memcpy(&op->op1, &op->op2, sizeof(znode));
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op2.op_type == IS_CONST &&
-                 op->op2.u.constant.type == IS_BOOL &&
-                 op->op2.u.constant.value.lval == 0) {
-        op->opcode = ZEND_BOOL_NOT;
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op2.op_type == IS_CONST &&
-          op->op2.u.constant.type == IS_BOOL &&
-          op->op2.u.constant.value.lval == 1) {
-        op->opcode = ZEND_BOOL;
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op2.op_type == IS_CONST &&
-          op->op2.u.constant.type == IS_LONG &&
-          op->op2.u.constant.value.lval == 0 &&
-          (op->op1.op_type == IS_TMP_VAR || op->op1.op_type == IS_VAR) &&
-          IS_DEFINED(op->op1) &&
-          opt_result_is_numeric(DEFINED_OP(op->op1))) {
-        op->opcode = ZEND_BOOL_NOT;
-        op->op2.op_type = IS_UNUSED;
-      }
-    } else if (op->opcode == ZEND_IS_NOT_EQUAL) {
-      if (op->op1.op_type == IS_CONST &&
-          op->op1.u.constant.type == IS_BOOL &&
-          op->op1.u.constant.value.lval == 0) {
-        op->opcode = ZEND_BOOL;
-        memcpy(&op->op1, &op->op2, sizeof(znode));
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op1.op_type == IS_CONST &&
-                 op->op1.u.constant.type == IS_BOOL &&
-                 op->op1.u.constant.value.lval == 1) {
-        op->opcode = ZEND_BOOL_NOT;
-        memcpy(&op->op1, &op->op2, sizeof(znode));
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op2.op_type == IS_CONST &&
-                 op->op2.u.constant.type == IS_BOOL &&
-                 op->op2.u.constant.value.lval == 0) {
-        op->opcode = ZEND_BOOL;
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op2.op_type == IS_CONST &&
-          op->op2.u.constant.type == IS_BOOL &&
-          op->op2.u.constant.value.lval == 1) {
-        op->opcode = ZEND_BOOL_NOT;
-        op->op2.op_type = IS_UNUSED;
-      } else if (op->op2.op_type == IS_CONST &&
-          op->op2.u.constant.type == IS_LONG &&
-          op->op2.u.constant.value.lval == 0 &&
-          (op->op1.op_type == IS_TMP_VAR || op->op1.op_type == IS_VAR) &&
-          IS_DEFINED(op->op1) &&
-          opt_result_is_numeric(DEFINED_OP(op->op1))) {
-        op->opcode = ZEND_BOOL;
-        op->op2.op_type = IS_UNUSED;
-      }
-    }
+    zend_op* prev = NULL;
+    zend_op* op = bb->start;
+    zend_op* end = op + bb->len;
+
+    HashTable assigns;
+    HashTable fetch_dim;
+
+#ifdef ZEND_ENGINE_2_3
+    ALLOCA_FLAG(use_heap)
+    zend_op** Ts = do_alloca(sizeof(zend_op*) * op_array->T, use_heap);
+#else
+    zend_op** Ts = do_alloca(sizeof(zend_op*) * op_array->T);
+#endif
+    memset(Ts, 0, sizeof(zend_op*) * op_array->T);
+
+    zend_hash_init(&assigns, 0, NULL, NULL, 0);
+    zend_hash_init(&fetch_dim, 0, NULL, NULL, 0);
 
-    if ((op->opcode == ZEND_ADD ||
+    while (op < end) {
+        /* Constant Folding */
+        if (OP1_TYPE(op) == IS_TMP_VAR &&
+                IS_DEFINED(op->op1) &&
+                DEFINED_OP(op->op1)->opcode == ZEND_QM_ASSIGN &&
+                OP1_TYPE(DEFINED_OP(op->op1)) == IS_CONST) {
+            if (op->opcode != ZEND_CASE) {
+                zend_op *x = DEFINED_OP(op->op1);
+                SET_UNDEFINED(op->op1);
+                memcpy(&op->op1, &x->op1, sizeof(x->op1));
+#ifdef ZEND_ENGINE_2_4
+                OP1_TYPE(op) = OP1_TYPE(x);
+#endif
+                SET_TO_NOP(x);
+            }
+        }
+        if (OP2_TYPE(op) == IS_TMP_VAR &&
+                IS_DEFINED(op->op2) &&
+                DEFINED_OP(op->op2)->opcode == ZEND_QM_ASSIGN &&
+                OP1_TYPE(DEFINED_OP(op->op2)) == IS_CONST) {
+            zend_op *x = DEFINED_OP(op->op2);
+            SET_UNDEFINED(op->op2);
+            memcpy(&op->op2, &x->op1, sizeof(x->op1));
+#ifdef ZEND_ENGINE_2_4
+            OP2_TYPE(op) = OP1_TYPE(x);
+#endif
+            SET_TO_NOP(x);
+        }
+
+        if (op->opcode == ZEND_IS_EQUAL) {
+            if (OP1_TYPE(op) == IS_CONST &&
+                    (Z_TYPE(OP1_CONST(op)) == IS_BOOL &&
+                     Z_LVAL(OP1_CONST(op)) == 0)) {
+                op->opcode = ZEND_BOOL_NOT;
+                memcpy(&op->op1, &op->op2, sizeof(op->op2));
+#ifdef ZEND_ENGINE_2_4
+                OP1_TYPE(op) = OP2_TYPE(op);
+#endif
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP1_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP1_CONST(op)) == IS_BOOL &&
+                       Z_LVAL(OP1_CONST(op)) == 1) {
+                op->opcode = ZEND_BOOL;
+                memcpy(&op->op1, &op->op2, sizeof(op->op2));
+#ifdef ZEND_ENGINE_2_4
+                OP1_TYPE(op) = OP2_TYPE(op);
+#endif
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP2_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP2_CONST(op)) == IS_BOOL &&
+                       Z_LVAL(OP2_CONST(op)) == 0) {
+                op->opcode = ZEND_BOOL_NOT;
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP2_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP2_CONST(op)) == IS_BOOL &&
+                       Z_LVAL(OP2_CONST(op)) == 1) {
+                op->opcode = ZEND_BOOL;
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP2_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP2_CONST(op)) == IS_LONG &&
+                       Z_LVAL(OP2_CONST(op)) == 0 &&
+                       (OP1_TYPE(op) == IS_TMP_VAR || OP1_TYPE(op) == IS_VAR) &&
+                       IS_DEFINED(op->op1) &&
+                       opt_result_is_numeric(DEFINED_OP(op->op1), op_array)) {
+                op->opcode = ZEND_BOOL_NOT;
+                OP2_TYPE(op) = IS_UNUSED;
+            }
+        } else if (op->opcode == ZEND_IS_NOT_EQUAL) {
+            if (OP1_TYPE(op) == IS_CONST &&
+                    Z_TYPE(OP1_CONST(op)) == IS_BOOL &&
+                    Z_LVAL(OP1_CONST(op)) == 0) {
+                op->opcode = ZEND_BOOL;
+                memcpy(&op->op1, &op->op2, sizeof(op->op2));
+#ifdef ZEND_ENGINE_2_4
+                OP1_TYPE(op) = OP2_TYPE(op);
+#endif
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP1_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP1_CONST(op)) == IS_BOOL &&
+                       Z_LVAL(OP1_CONST(op)) == 1) {
+                op->opcode = ZEND_BOOL_NOT;
+                memcpy(&op->op1, &op->op2, sizeof(op->op2));
+#ifdef ZEND_ENGINE_2_4
+                OP1_TYPE(op) = OP2_TYPE(op);
+#endif
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP2_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP2_CONST(op)) == IS_BOOL &&
+                       Z_LVAL(OP2_CONST(op)) == 0) {
+                op->opcode = ZEND_BOOL;
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP2_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP2_CONST(op)) == IS_BOOL &&
+                       Z_LVAL(OP2_CONST(op)) == 1) {
+                op->opcode = ZEND_BOOL_NOT;
+                OP2_TYPE(op) = IS_UNUSED;
+            } else if (OP2_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP2_CONST(op)) == IS_LONG &&
+                       Z_LVAL(OP2_CONST(op)) == 0 &&
+                       (OP1_TYPE(op) == IS_TMP_VAR || OP1_TYPE(op) == IS_VAR) &&
+                       IS_DEFINED(op->op1) &&
+                       opt_result_is_numeric(DEFINED_OP(op->op1), op_array)) {
+                op->opcode = ZEND_BOOL;
+                OP2_TYPE(op) = IS_UNUSED;
+            }
+        }
+
+        /* Eliminate ZEND_ECHO's with empty strings (as in echo '') */
+        if (op->opcode == ZEND_ECHO && OP1_TYPE(op) == IS_CONST &&
+            Z_TYPE(OP1_CONST(op)) == IS_STRING && Z_STRLEN(OP1_CONST(op)) == 0) {
+#ifndef ZEND_ENGINE_2_4
+            /* TODO We can't go around free'ing random literal strings in PHP 5.4
+                    For now, we just leave them. Nasty but works. */
+            STR_FREE(Z_STRVAL(OP1_CONST(op)));
+#endif
+            SET_TO_NOP(op);
+        }
+
+        if ((op->opcode == ZEND_ADD ||
                 op->opcode == ZEND_SUB ||
                 op->opcode == ZEND_MUL ||
                 op->opcode == ZEND_DIV ||
                 op->opcode == ZEND_MOD ||
                 op->opcode == ZEND_SL ||
                 op->opcode == ZEND_SR ||
+#ifndef ZEND_ENGINE_2_4
+                /* TODO PHP 5.4 */
                 op->opcode == ZEND_CONCAT ||
+#endif
                 op->opcode == ZEND_BW_OR ||
                 op->opcode == ZEND_BW_AND ||
                 op->opcode == ZEND_BW_XOR ||
@@ -1744,846 +1805,1037 @@
                 op->opcode == ZEND_IS_NOT_EQUAL ||
                 op->opcode == ZEND_IS_SMALLER ||
                 op->opcode == ZEND_IS_SMALLER_OR_EQUAL) &&
-               op->op1.op_type == IS_CONST &&
-               op->op2.op_type == IS_CONST &&
-               op->result.op_type == IS_TMP_VAR) {
-
-      typedef int (*binary_op_type)(zval *, zval *, zval*  TSRMLS_DC);
-
-      binary_op_type binary_op = (binary_op_type)get_binary_op(op->opcode);
-
-      if (binary_op != NULL) {
-        int old = EG(error_reporting);
-        zval res;
-        EG(error_reporting) = 0;
-        if (binary_op(&res, &op->op1.u.constant, &op->op2.u.constant TSRMLS_CC) != FAILURE) {
-          zval_dtor(&op->op1.u.constant);
-          zval_dtor(&op->op2.u.constant);
-          op->opcode = ZEND_QM_ASSIGN;
-          op->extended_value = 0;
-          op->op1.op_type = IS_CONST;
-          memcpy(&op->op1.u.constant, &res, sizeof(zval));
-          op->op2.op_type = IS_UNUSED;
-        }
-        EG(error_reporting) = old;
-      }
-    } else if ((op->opcode == ZEND_BW_NOT ||
-                op->opcode == ZEND_BOOL_NOT) &&
-               op->op1.op_type == IS_CONST &&
-               op->result.op_type == IS_TMP_VAR) {
-      int (*unary_op)(zval *result, zval *op1) =
-        unary_op = get_unary_op(op->opcode);
-      if (unary_op != NULL) {
-        int old = EG(error_reporting);
-        zval res;
-        EG(error_reporting) = 0;
-        if (unary_op(&res, &op->op1.u.constant) != FAILURE) {
-          zval_dtor(&op->op1.u.constant);
-          op->opcode = ZEND_QM_ASSIGN;
-          op->extended_value = 0;
-          op->op1.op_type = IS_CONST;
-          memcpy(&op->op1.u.constant, &res, sizeof(zval));
-          op->op2.op_type = IS_UNUSED;
-        }
-        EG(error_reporting) = old;
-      }
-    } else if ((op->opcode == ZEND_BOOL) &&
-               op->op1.op_type == IS_CONST &&
-               op->result.op_type == IS_TMP_VAR) {
-      zval res;
-      res.type = IS_BOOL;
-      res.value.lval = zend_is_true(&op->op1.u.constant);
-      zval_dtor(&op->op1.u.constant);
-      op->opcode = ZEND_QM_ASSIGN;
-      op->extended_value = 0;
-      op->op1.op_type = IS_CONST;
-      memcpy(&op->op1.u.constant, &res, sizeof(zval));
-      op->op2.op_type = IS_UNUSED;
-    } else if ((op->opcode == ZEND_CAST) &&
-               op->op1.op_type == IS_CONST &&
-               op->result.op_type == IS_TMP_VAR &&
-               op->extended_value != IS_ARRAY &&
-               op->extended_value != IS_OBJECT &&
-               op->extended_value != IS_RESOURCE) {
-      zval res;
-      memcpy(&res,&op->op1.u.constant,sizeof(zval));
-      zval_copy_ctor(&res);
-      switch (op->extended_value) {
-        case IS_NULL:
-          convert_to_null(&res);
-          break;
-        case IS_BOOL:
-          convert_to_boolean(&res);
-          break;
-        case IS_LONG:
-          convert_to_long(&res);
-          break;
-        case IS_DOUBLE:
-          convert_to_double(&res);
-          break;
-        case IS_STRING:
-          convert_to_string(&res);
-          break;
-        case IS_ARRAY:
-          convert_to_array(&res);
-          break;
-        case IS_OBJECT:
-          convert_to_object(&res);
-          break;
-      }
-      zval_dtor(&op->op1.u.constant);
-      op->opcode = ZEND_QM_ASSIGN;
-      op->extended_value = 0;
-      op->op1.op_type = IS_CONST;
-      memcpy(&op->op1.u.constant, &res, sizeof(zval));
-      op->op2.op_type = IS_UNUSED;
-
-    /* FREE(CONST) => NOP
-    */
-    } else if (op->opcode == ZEND_FREE &&
-               op->op1.op_type == IS_CONST) {
-      zval_dtor(&op->op1.u.constant);
-      SET_TO_NOP(op);
-
-    /* INIT_STRING ADD_CHAR ADD_STRING ADD_VAR folding */
-
-    /* INIT_STRING($y) => QM_ASSIGN('',$y)
-    */
-    } else if (op->opcode == ZEND_INIT_STRING) {
-      op->opcode = ZEND_QM_ASSIGN;
-      op->op1.op_type = IS_CONST;
-      op->op2.op_type = IS_UNUSED;
-      op->op1.u.constant.type = IS_STRING;
-      op->op1.u.constant.value.str.len = 0;
-      op->op1.u.constant.value.str.val = empty_string;
-    /* ADD_CHAR(CONST,CONST,$y) => QM_ASSIGN(CONST,$y)
-    */
-    } else if (op->opcode == ZEND_ADD_CHAR &&
-               op->op1.op_type == IS_CONST) {
-      size_t len;
-      op->opcode = ZEND_QM_ASSIGN;
-      op->op1.op_type = IS_CONST;
-      op->op2.op_type = IS_UNUSED;
-      convert_to_string(&op->op1.u.constant);
-      len = op->op1.u.constant.value.str.len + 1;
-      STR_REALLOC(op->op1.u.constant.value.str.val,len+1);
-      op->op1.u.constant.value.str.val[len-1] = (char) op->op2.u.constant.value.lval;
-      op->op1.u.constant.value.str.val[len] = 0;
-      op->op1.u.constant.value.str.len = len;
-    /* ADD_STRING(CONST,CONST,$y) => QM_ASSIGN(CONST,$y)
-    */
-    } else if (op->opcode == ZEND_ADD_STRING &&
-               op->op1.op_type == IS_CONST) {
-      size_t len;
-      op->opcode = ZEND_QM_ASSIGN;
-      op->op1.op_type = IS_CONST;
-      op->op2.op_type = IS_UNUSED;
-      convert_to_string(&op->op1.u.constant);
-      convert_to_string(&op->op2.u.constant);
-      len = op->op1.u.constant.value.str.len + op->op2.u.constant.value.str.len;
-      STR_REALLOC(op->op1.u.constant.value.str.val,len+1);
-      memcpy(op->op1.u.constant.value.str.val+op->op1.u.constant.value.str.len,
-             op->op2.u.constant.value.str.val, op->op2.u.constant.value.str.len);
-      op->op1.u.constant.value.str.val[len] = 0;
-      op->op1.u.constant.value.str.len = len;
-      STR_FREE(op->op2.u.constant.value.str.val);
-    /* ADD_VAR(CONST,VAR,$y) => CONCAT(CONST,$y)
-    */
-    } else if (op->opcode == ZEND_ADD_VAR &&
-               op->op1.op_type == IS_CONST) {
-      op->opcode = ZEND_CONCAT;
-    /* CONCAT('',$x,$y) + ADD_CHAR($y,CHAR,$z) => CONCAT($x, CONST, $z)
-    */
-    } else if (op->opcode == ZEND_ADD_CHAR &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1) &&
-               DEFINED_OP(op->op1)->opcode == ZEND_CONCAT &&
-               DEFINED_OP(op->op1)->op1.op_type == IS_CONST &&
-               DEFINED_OP(op->op1)->op1.u.constant.type == IS_STRING &&
-               DEFINED_OP(op->op1)->op1.u.constant.value.str.len == 0) {
-      char ch = (char) op->op2.u.constant.value.lval;
-      zend_op *x = DEFINED_OP(op->op1);
-      SET_UNDEFINED(op->op1);
-      memcpy(&op->op1, &x->op2, sizeof(op->op2));
-      op->opcode = ZEND_CONCAT;
-      op->op2.u.constant.type = IS_STRING;
-      op->op2.u.constant.value.str.val = emalloc(2);
-      op->op2.u.constant.value.str.val[0] = ch;
-      op->op2.u.constant.value.str.val[1] = '\000';
-      op->op2.u.constant.value.str.len = 1;
-      STR_FREE(x->op1.u.constant.value.str.val);
-      SET_TO_NOP(x);
-    /*
-       CONCAT('',$x,$y) + ADD_STRING($y,$v,$z) => CONCAT($x, $v, $z)
-       CONCAT('',$x,$y) + CONCAT($y,$v,$z)     => CONCAT($x, $v, $z)
-       CONCAT('',$x,$y) + ADD_VAR($y,$v,$z)    => CONCAT($x, $v, $z)
-    */
-    } else if ((op->opcode == ZEND_ADD_STRING ||
-                op->opcode == ZEND_CONCAT ||
-                op->opcode == ZEND_ADD_VAR) &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1) &&
-               DEFINED_OP(op->op1)->opcode == ZEND_CONCAT &&
-               DEFINED_OP(op->op1)->op1.op_type == IS_CONST &&
-               DEFINED_OP(op->op1)->op1.u.constant.type == IS_STRING &&
-               DEFINED_OP(op->op1)->op1.u.constant.value.str.len == 0) {
-      zend_op *x = DEFINED_OP(op->op1);
-      SET_UNDEFINED(op->op1);
-      op->opcode = ZEND_CONCAT;
-      memcpy(&op->op1, &x->op2, sizeof(op->op2));
-      STR_FREE(x->op1.u.constant.value.str.val);
-      SET_TO_NOP(x);
-    /* ADD_CHAR($x,CONST,$y) + ADD_CHAR($y,CHAR,$z) => ADD_STRING($x, CONST, $z)
-    */
-    } else if (op->opcode == ZEND_ADD_CHAR &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1) &&
-               DEFINED_OP(op->op1)->opcode == ZEND_ADD_CHAR) {
-      char ch1 = (char) DEFINED_OP(op->op1)->op2.u.constant.value.lval;
-      char ch2 = (char) op->op2.u.constant.value.lval;
-      DEFINED_OP(op->op1)->op2.u.constant.type = IS_STRING;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val = emalloc(3);
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[0] = ch1;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[1] = ch2;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[2] = '\000';
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.len = 2;
-      memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
-      DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
-      SET_DEFINED(DEFINED_OP(op->op1));
-      SET_TO_NOP(op);
-    /* CONCAT($x,CONST,$y) + ADD_CHAR($y,CONST,$z) => CONCAT($x, CONST, $z)
-       ADD_STRING($x,CONST,$y) + ADD_CHAR($y,CONST,$z) => ADD_STRING($x, CONST, $z)
-    */
-    } else if (op->opcode == ZEND_ADD_CHAR &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1) &&
-               (DEFINED_OP(op->op1)->opcode == ZEND_CONCAT ||
-                DEFINED_OP(op->op1)->opcode == ZEND_ADD_STRING) &&
-               DEFINED_OP(op->op1)->op2.op_type == IS_CONST) {
-      size_t len;
-      convert_to_string(&DEFINED_OP(op->op1)->op2.u.constant);
-      len = DEFINED_OP(op->op1)->op2.u.constant.value.str.len + 1;
-      STR_REALLOC(DEFINED_OP(op->op1)->op2.u.constant.value.str.val,len+1);
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[len-1] = (char) op->op2.u.constant.value.lval;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[len] = 0;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.len = len;
-      memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
-      if (DEFINED_OP(op->op1)->op1.op_type == DEFINED_OP(op->op1)->result.op_type &&
-          DEFINED_OP(op->op1)->op1.u.var == DEFINED_OP(op->op1)->result.u.var) {
-        DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
-      }
-      SET_DEFINED(DEFINED_OP(op->op1));
-      SET_TO_NOP(op);
-    /* ADD_CHAR($x,CONST,$y) + ADD_STRING($y,CONST,$z) => ADD_STRING($x, CONST, $z)
-       ADD_CHAR($x,CONST,$y) + CONCAT($y,CONST,$z) => CONCAT($x, CONST, $z)
-    */
-    } else if ((op->opcode == ZEND_ADD_STRING ||
-                op->opcode == ZEND_CONCAT) &&
-               op->op2.op_type == IS_CONST &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1) &&
-               DEFINED_OP(op->op1)->opcode == ZEND_ADD_CHAR) {
-      char ch = (char) DEFINED_OP(op->op1)->op2.u.constant.value.lval;
-      size_t len;
-      convert_to_string(&op->op2.u.constant);
-      len = op->op2.u.constant.value.str.len + 1;
-      DEFINED_OP(op->op1)->op2.u.constant.type = IS_STRING;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val = emalloc(len+1);
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[0] = ch;
-      memcpy(DEFINED_OP(op->op1)->op2.u.constant.value.str.val+1,
-             op->op2.u.constant.value.str.val, op->op2.u.constant.value.str.len);
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[len] = 0;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.len = len;
-      STR_FREE(op->op2.u.constant.value.str.val);
-      memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
-      DEFINED_OP(op->op1)->opcode = op->opcode;
-      if (DEFINED_OP(op->op1)->op1.op_type == DEFINED_OP(op->op1)->result.op_type &&
-          DEFINED_OP(op->op1)->op1.u.var == DEFINED_OP(op->op1)->result.u.var) {
-        DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
-      }
-      SET_DEFINED(DEFINED_OP(op->op1));
-      SET_TO_NOP(op);
-    /* ADD_STRING($x,CONST,$y) + ADD_STRING($y,CONST,$z) => ADD_STRING($x, CONST, $z)
-       ADD_STRING($x,CONST,$y) + CONCAT($y,CONST,$z) => CONCAT($x, CONST, $z)
-       CONCAT($x,CONST,$y) + ADD_STRING($y,CONST,$z) => CONCAT($x, CONST, $z)
-       CONCAT($x,CONST,$y) + CONCAT($y,CONST,$z) => CONCAT($x, CONST, $z)
-    */
-    } else if ((op->opcode == ZEND_ADD_STRING ||
-                op->opcode == ZEND_CONCAT) &&
-               op->op2.op_type == IS_CONST &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1) &&
-               (DEFINED_OP(op->op1)->opcode == ZEND_CONCAT ||
-                DEFINED_OP(op->op1)->opcode == ZEND_ADD_STRING) &&
-               DEFINED_OP(op->op1)->op2.op_type == IS_CONST) {
-      size_t len;
-      convert_to_string(&DEFINED_OP(op->op1)->op2.u.constant);
-      convert_to_string(&op->op2.u.constant);
-      len = DEFINED_OP(op->op1)->op2.u.constant.value.str.len + op->op2.u.constant.value.str.len;
-      STR_REALLOC(DEFINED_OP(op->op1)->op2.u.constant.value.str.val,len+1);
-      memcpy(DEFINED_OP(op->op1)->op2.u.constant.value.str.val+DEFINED_OP(op->op1)->op2.u.constant.value.str.len,
-             op->op2.u.constant.value.str.val, op->op2.u.constant.value.str.len);
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.val[len] = 0;
-      DEFINED_OP(op->op1)->op2.u.constant.value.str.len = len;
-      STR_FREE(op->op2.u.constant.value.str.val);
-      memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
-      if (op->opcode == ZEND_CONCAT) {
-        DEFINED_OP(op->op1)->opcode = ZEND_CONCAT;
-      }
-      if (DEFINED_OP(op->op1)->op1.op_type == DEFINED_OP(op->op1)->result.op_type &&
-          DEFINED_OP(op->op1)->op1.u.var == DEFINED_OP(op->op1)->result.u.var) {
-        DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
-      }
-      SET_DEFINED(DEFINED_OP(op->op1));
-      SET_TO_NOP(op);
-#ifndef ZEND_ENGINE_2_3
-    /* TODO: Doesn't work with PHP-5.3. Needs more research */
+                OP1_TYPE(op) == IS_CONST &&
+                OP2_TYPE(op) == IS_CONST &&
+                RES_TYPE(op) == IS_TMP_VAR) {
+
+            typedef int (*binary_op_type)(zval *, zval *, zval*  TSRMLS_DC);
+
+            binary_op_type binary_op = (binary_op_type)get_binary_op(op->opcode);
+
+            if (binary_op != NULL) {
+                int old = EG(error_reporting);
+                zval res;
+                EG(error_reporting) = 0;
+                if (binary_op(&res, &OP1_CONST(op), &OP2_CONST(op) TSRMLS_CC) != FAILURE) {
+#ifndef ZEND_ENGINE_2_4
+                    zval_dtor(&OP1_CONST(op));
+                    zval_dtor(&OP2_CONST(op));
+                    /* TODO check */
+#endif
+                    op->opcode = ZEND_QM_ASSIGN;
+                    op->extended_value = 0;
+                    INIT_PZVAL(&res);
+                    OP1_TYPE(op) = IS_CONST;
+                    memcpy(&OP1_CONST(op), &res, sizeof(zval));
+                    OP2_TYPE(op) = IS_UNUSED;
+                }
+                EG(error_reporting) = old;
+            }
+        } else if ((op->opcode == ZEND_BW_NOT ||
+                    op->opcode == ZEND_BOOL_NOT) &&
+                   OP1_TYPE(op) == IS_CONST &&
+                   RES_TYPE(op) == IS_TMP_VAR) {
+            int (*unary_op)(zval *result, zval *op1) =
+                unary_op = get_unary_op(op->opcode);
+            if (unary_op != NULL) {
+                int old = EG(error_reporting);
+                zval res;
+                EG(error_reporting) = 0;
+                if (unary_op(&res, &OP1_CONST(op)) != FAILURE) {
+#ifndef ZEND_ENGINE_2_4
+                    zval_dtor(&OP1_CONST(op));
+                    /* TODO check */
+#endif
+                    op->opcode = ZEND_QM_ASSIGN;
+                    op->extended_value = 0;
+                    INIT_PZVAL(&res);
+                    OP1_TYPE(op) = IS_CONST;
+                    memcpy(&OP1_CONST(op), &res, sizeof(zval));
+                    OP2_TYPE(op) = IS_UNUSED;
+                }
+                EG(error_reporting) = old;
+            }
+        } else if ((op->opcode == ZEND_BOOL) &&
+                   OP1_TYPE(op) == IS_CONST &&
+                   RES_TYPE(op) == IS_TMP_VAR) {
+            zval res;
+            INIT_PZVAL(&res);
+            res.type = IS_BOOL;
+            res.value.lval = zend_is_true(&OP1_CONST(op));
+#ifndef ZEND_ENGINE_2_4
+            zval_dtor(&OP1_CONST(op));
+            /* TODO check */
+#endif
+            op->opcode = ZEND_QM_ASSIGN;
+            op->extended_value = 0;
+            OP1_TYPE(op) = IS_CONST;
+            memcpy(&OP1_CONST(op), &res, sizeof(zval));
+            OP2_TYPE(op) = IS_UNUSED;
+        } else if ((op->opcode == ZEND_CAST) &&
+                   OP1_TYPE(op) == IS_CONST &&
+                   RES_TYPE(op) == IS_TMP_VAR &&
+                   op->extended_value != IS_ARRAY &&
+                   op->extended_value != IS_OBJECT &&
+                   op->extended_value != IS_RESOURCE) {
+            zval res;
+            memcpy(&res,&OP1_CONST(op),sizeof(zval));
+            zval_copy_ctor(&res);
+            switch (op->extended_value) {
+            case IS_NULL:
+                convert_to_null(&res);
+                break;
+            case IS_BOOL:
+                convert_to_boolean(&res);
+                break;
+            case IS_LONG:
+                convert_to_long(&res);
+                break;
+            case IS_DOUBLE:
+                convert_to_double(&res);
+                break;
+            case IS_STRING:
+                convert_to_string(&res);
+                break;
+            case IS_ARRAY:
+                convert_to_array(&res);
+                break;
+            case IS_OBJECT:
+                convert_to_object(&res);
+                break;
+            }
+#ifndef ZEND_ENGINE_2_4
+            zval_dtor(&OP1_CONST(op));
+#endif
+            op->opcode = ZEND_QM_ASSIGN;
+            op->extended_value = 0;
+            OP1_TYPE(op) = IS_CONST;
+            memcpy(&OP1_CONST(op), &res, sizeof(zval));
+            OP2_TYPE(op) = IS_UNUSED;
 
-    /* FETCH_X      local("GLOBALS"),$x => FETCH_X global($y),$z
-       FETCH_DIM_X  $x,$y,$z               NOP
-    */
-    } else if (
-               ((op->opcode == ZEND_FETCH_DIM_R &&
-                op->op1.op_type == IS_VAR &&
-/*???               op->extended_value == ZEND_FETCH_STANDARD &&*/
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_FETCH_R) ||
-               (op->opcode == ZEND_FETCH_DIM_W &&
-                op->op1.op_type == IS_VAR &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_FETCH_W) ||
-               (op->opcode == ZEND_FETCH_DIM_RW &&
-                op->op1.op_type == IS_VAR &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_FETCH_RW) ||
-               (op->opcode == ZEND_FETCH_DIM_IS &&
-                op->op1.op_type == IS_VAR &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_FETCH_IS) ||
-               (op->opcode == ZEND_FETCH_DIM_FUNC_ARG &&
-                op->op1.op_type == IS_VAR &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_FETCH_FUNC_ARG) ||
-               (op->opcode == ZEND_FETCH_DIM_UNSET &&
-                op->op1.op_type == IS_VAR &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_FETCH_UNSET)) &&
-                FETCH_TYPE(DEFINED_OP(op->op1)) == ZEND_FETCH_GLOBAL &&
-                DEFINED_OP(op->op1)->op1.op_type == IS_CONST &&
-                DEFINED_OP(op->op1)->op1.u.constant.type == IS_STRING &&
-                DEFINED_OP(op->op1)->op1.u.constant.value.str.len == (sizeof("GLOBALS")-1) &&
-                memcmp(DEFINED_OP(op->op1)->op1.u.constant.value.str.val, "GLOBALS", sizeof("GLOBALS")-1) == 0) {
-      zend_op *x = op+1;
-      if (x->opcode != op->opcode) {
-        x = DEFINED_OP(op->op1);
-        SET_UNDEFINED(op->op1);
-        STR_FREE(x->op1.u.constant.value.str.val);
-        FETCH_TYPE(x) = ZEND_FETCH_GLOBAL;
-        memcpy(&x->op1,&op->op2,sizeof(znode));
-        memcpy(&x->result,&op->result,sizeof(znode));
-        SET_DEFINED(x);
-        SET_TO_NOP(op);
-      }
+/* TODO PHP 5.4 */
+#ifndef ZEND_ENGINE_2_4
+            /* FREE(CONST) => NOP
+            */
+        } else if (op->opcode == ZEND_FREE &&
+                   OP1_TYPE(op) == IS_CONST) {
+            zval_dtor(&OP1_CONST(op));
+            SET_TO_NOP(op);
+#endif
+
+            /* INIT_STRING ADD_CHAR ADD_STRING ADD_VAR folding */
+
+            /* INIT_STRING($y) => QM_ASSIGN('',$y)
+            */
+        } else if (op->opcode == ZEND_INIT_STRING) {
+            op->opcode = ZEND_QM_ASSIGN;
+            OP1_TYPE(op) = IS_CONST;
+            OP2_TYPE(op) = IS_UNUSED;
+            Z_TYPE(OP1_CONST(op)) = IS_STRING;
+            Z_STRLEN(OP1_CONST(op)) = 0;
+            Z_STRVAL(OP1_CONST(op)) = empty_string;
+
+            /* ADD_CHAR(CONST,CONST,$y) => QM_ASSIGN(CONST,$y)
+            */
+#ifdef ZEND_ENGINE_2_4
+            /* TODO */
+#else
+        } else if (op->opcode == ZEND_ADD_CHAR &&
+                   OP1_TYPE(op) == IS_CONST) {
+            size_t len;
+            op->opcode = ZEND_QM_ASSIGN;
+            OP1_TYPE(op) = IS_CONST;
+            OP2_TYPE(op) = IS_UNUSED;
+            convert_to_string(&op->op1.u.constant);
+            len = op->op1.u.constant.value.str.len + 1;
+            STR_REALLOC(op->op1.u.constant.value.str.val,len+1);
+            op->op1.u.constant.value.str.val[len-1] = (char) op->op2.u.constant.value.lval;
+            op->op1.u.constant.value.str.val[len] = 0;
+            op->op1.u.constant.value.str.len = len;
+#endif
+            /* ADD_STRING(CONST,CONST,$y) => QM_ASSIGN(CONST,$y)
+            */
+        } else if (op->opcode == ZEND_ADD_STRING &&
+                   OP1_TYPE(op) == IS_CONST) {
+            size_t len;
+            op->opcode = ZEND_QM_ASSIGN;
+            OP1_TYPE(op) = IS_CONST;
+            OP2_TYPE(op) = IS_UNUSED;
+            convert_to_string(&OP1_CONST(op));
+            convert_to_string(&OP2_CONST(op));
+            len = Z_STRLEN(OP1_CONST(op)) + Z_STRLEN(OP2_CONST(op));
+            STR_REALLOC(Z_STRVAL(OP1_CONST(op)), len + 1);
+            memcpy(Z_STRVAL(OP1_CONST(op)) + Z_STRLEN(OP1_CONST(op)),
+                   Z_STRVAL(OP2_CONST(op)), Z_STRLEN(OP2_CONST(op)));
+            Z_STRVAL(OP1_CONST(op))[len] = 0;
+            Z_STRLEN(OP1_CONST(op)) = len;
+#ifndef ZEND_ENGINE_2_4
+            STR_FREE(Z_STRVAL(OP2_CONST(op)));
+            /* TODO */
+#endif
+            /* ADD_VAR(CONST,VAR,$y) => CONCAT(CONST,$y)
+            */
+        } else if (op->opcode == ZEND_ADD_VAR &&
+                   OP1_TYPE(op) == IS_CONST) {
+            op->opcode = ZEND_CONCAT;
+            /* CONCAT('',$x,$y) + ADD_CHAR($y,CHAR,$z) => CONCAT($x, CONST, $z)
+            */
+        } else if (op->opcode == ZEND_ADD_CHAR &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_CONCAT &&
+                   OP1_TYPE(DEFINED_OP(op->op1)) == IS_CONST &&
+                   Z_TYPE(OP1_CONST(DEFINED_OP(op->op1))) == IS_STRING &&
+                   Z_STRLEN(OP1_CONST(DEFINED_OP(op->op1))) == 0) {
+            char ch = (char) Z_LVAL(OP2_CONST(op));
+            zend_op *x = DEFINED_OP(op->op1);
+            SET_UNDEFINED(op->op1);
+            memcpy(&op->op1, &x->op2, sizeof(x->op2));
+#ifdef ZEND_ENGINE_2_4
+            op->op1_type = x->op2_type;
+#endif
+            op->opcode = ZEND_CONCAT;
+            Z_TYPE(OP2_CONST(op)) = IS_STRING;
+            Z_STRVAL(OP2_CONST(op)) = emalloc(2);
+            Z_STRVAL(OP2_CONST(op))[0] = ch;
+            Z_STRVAL(OP2_CONST(op))[1] = '\000';
+            Z_STRLEN(OP2_CONST(op)) = 1;
+#ifndef ZEND_ENGINE_2_4
+            STR_FREE(Z_STRVAL(OP1_CONST(x)));
 #endif
-    /* FETCH_IS               local("GLOBALS"),$x    ISSET_ISEMPTY_VAR $y(global),res
-       ISSET_ISEMPTY_DIM_OBJ  $x,$y,$res          => NOP
-    */
-    } else if (op->opcode == ZEND_ISSET_ISEMPTY_DIM_OBJ &&
-               op->op1.op_type == IS_VAR &&
+            SET_TO_NOP(x);
+            /*
+               CONCAT('',$x,$y) + ADD_STRING($y,$v,$z) => CONCAT($x, $v, $z)
+               CONCAT('',$x,$y) + CONCAT($y,$v,$z)     => CONCAT($x, $v, $z)
+               CONCAT('',$x,$y) + ADD_VAR($y,$v,$z)    => CONCAT($x, $v, $z)
+            */
+        } else if ((op->opcode == ZEND_ADD_STRING ||
+                    op->opcode == ZEND_CONCAT ||
+                    op->opcode == ZEND_ADD_VAR) &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_CONCAT &&
+                   OP1_TYPE(DEFINED_OP(op->op1)) == IS_CONST &&
+                   Z_TYPE(OP1_CONST(DEFINED_OP(op->op1))) == IS_STRING &&
+                   Z_STRLEN(OP1_CONST(DEFINED_OP(op->op1))) == 0) {
+            zend_op *x = DEFINED_OP(op->op1);
+            SET_UNDEFINED(op->op1);
+            op->opcode = ZEND_CONCAT;
+            memcpy(&op->op1, &x->op2, sizeof(x->op2));
+#ifdef ZEND_ENGINE_2_4
+            op->op1_type = x->op2_type;
+#endif
+#ifndef ZEND_ENGINE_2_4
+            /* TODO */
+            STR_FREE(Z_STRVAL(OP1_CONST(x)));
+#endif
+            SET_TO_NOP(x);
+            /* ADD_CHAR($x,CONST,$y) + ADD_CHAR($y,CHAR,$z) => ADD_STRING($x, CONST, $z)
+            */
+        } else if (op->opcode == ZEND_ADD_CHAR &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_ADD_CHAR) {
+            char ch1 = (char) Z_LVAL(OP2_CONST(DEFINED_OP(op->op1)));
+            char ch2 = (char) Z_LVAL(OP2_CONST(op));
+            Z_TYPE(OP2_CONST(DEFINED_OP(op->op1))) = IS_STRING;
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))) = emalloc(3);
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[0] = ch1;
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[1] = ch2;
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[2] = '\000';
+            Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) = 2;
+            memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+            DEFINED_OP(op->op1)->result_type = op->result_type;
+#endif
+            DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
+            SET_DEFINED(DEFINED_OP(op->op1));
+            SET_TO_NOP(op);
+            /* CONCAT($x,CONST,$y) + ADD_CHAR($y,CONST,$z) => CONCAT($x, CONST, $z)
+               ADD_STRING($x,CONST,$y) + ADD_CHAR($y,CONST,$z) => ADD_STRING($x, CONST, $z)
+            */
+        } else if (op->opcode == ZEND_ADD_CHAR &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   (DEFINED_OP(op->op1)->opcode == ZEND_CONCAT ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_ADD_STRING) &&
+                   OP2_TYPE(DEFINED_OP(op->op1)) == IS_CONST) {
+            size_t len;
+            convert_to_string(&OP2_CONST(DEFINED_OP(op->op1)));
+            len = Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) + 1;
+            STR_REALLOC(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))), len + 1);
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[len - 1] = (char) Z_LVAL(OP2_CONST(op));
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[len] = 0;
+            Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) = len;
+            memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+            DEFINED_OP(op->op1)->result_type = op->result_type;
+#endif
+            if (OP1_TYPE(DEFINED_OP(op->op1)) == RES_TYPE(DEFINED_OP(op->op1)) &&
+                    OP1_VARR(DEFINED_OP(op->op1)) == RES_VARR(DEFINED_OP(op->op1))) {
+                DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
+            }
+            SET_DEFINED(DEFINED_OP(op->op1));
+            SET_TO_NOP(op);
+            /* ADD_CHAR($x,CONST,$y) + ADD_STRING($y,CONST,$z) => ADD_STRING($x, CONST, $z)
+               ADD_CHAR($x,CONST,$y) + CONCAT($y,CONST,$z) => CONCAT($x, CONST, $z)
+            */
+        } else if ((op->opcode == ZEND_ADD_STRING ||
+                    op->opcode == ZEND_CONCAT) &&
+                   OP2_TYPE(op) == IS_CONST &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_ADD_CHAR) {
+            char ch = (char) Z_LVAL(OP2_CONST(DEFINED_OP(op->op1)));
+            size_t len;
+            convert_to_string(&OP2_CONST(op));
+            len = Z_STRLEN(OP2_CONST(op)) + 1;
+            Z_TYPE(OP2_CONST(DEFINED_OP(op->op1))) = IS_STRING;
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))) = emalloc(len + 1);
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[0] = ch;
+            memcpy(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))) + 1,
+                   Z_STRVAL(OP2_CONST(op)), Z_STRLEN(OP2_CONST(op)));
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[len] = 0;
+            Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) = len;
+#ifndef ZEND_ENGINE_2_4
+            STR_FREE(Z_STRVAL(OP2_CONST(op)));
+            /* TODO */
+#endif
+            memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+            DEFINED_OP(op->op1)->result_type = op->result_type;
+#endif
+            DEFINED_OP(op->op1)->opcode = op->opcode;
+            if (OP1_TYPE(DEFINED_OP(op->op1)) == RES_TYPE(DEFINED_OP(op->op1)) &&
+                    OP1_VARR(DEFINED_OP(op->op1)) == RES_VARR(DEFINED_OP(op->op1))) {
+                DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
+            }
+            SET_DEFINED(DEFINED_OP(op->op1));
+            SET_TO_NOP(op);
+            /* ADD_STRING($x,CONST,$y) + ADD_STRING($y,CONST,$z) => ADD_STRING($x, CONST, $z)
+               ADD_STRING($x,CONST,$y) + CONCAT($y,CONST,$z) => CONCAT($x, CONST, $z)
+               CONCAT($x,CONST,$y) + ADD_STRING($y,CONST,$z) => CONCAT($x, CONST, $z)
+               CONCAT($x,CONST,$y) + CONCAT($y,CONST,$z) => CONCAT($x, CONST, $z)
+            */
+        } else if ((op->opcode == ZEND_ADD_STRING ||
+                    op->opcode == ZEND_CONCAT) &&
+                   OP2_TYPE(op) == IS_CONST &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   (DEFINED_OP(op->op1)->opcode == ZEND_CONCAT ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_ADD_STRING) &&
+                   OP2_TYPE(DEFINED_OP(op->op1)) == IS_CONST) {
+            size_t len;
+            convert_to_string(&OP2_CONST(DEFINED_OP(op->op1)));
+            convert_to_string(&OP2_CONST(op));
+            len = Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) + Z_STRLEN(OP2_CONST(op));
+#ifdef ZEND_ENGINE_2_4
+            if (IS_INTERNED(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))) ) {
+                //char *tmp = safe_emalloc(1, len, 1);
+                char *tmp = emalloc(len + 1);
+                memcpy(tmp, Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))), Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) + 1);
+                Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))) = tmp;
+            } else {
+                //Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))) = safe_erealloc(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))), 1, len, 1);
+                STR_REALLOC(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))), len + 1);
+            }
+#else
+            STR_REALLOC(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))), len + 1);
+#endif
+            memcpy(Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1))) + Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))),
+                   Z_STRVAL(OP2_CONST(op)), Z_STRLEN(OP2_CONST(op)));
+            Z_STRVAL(OP2_CONST(DEFINED_OP(op->op1)))[len] = 0;
+            Z_STRLEN(OP2_CONST(DEFINED_OP(op->op1))) = len;
+#ifndef ZEND_ENGINE_2_4
+            STR_FREE(Z_STRVAL(OP2_CONST(op)));
+            /* TODO */
+#endif
+            memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+            DEFINED_OP(op->op1)->result_type = op->result_type;
+#endif
+            if (op->opcode == ZEND_CONCAT) {
+                DEFINED_OP(op->op1)->opcode = ZEND_CONCAT;
+            }
+            if (OP1_TYPE(DEFINED_OP(op->op1)) == RES_TYPE(DEFINED_OP(op->op1)) &&
+                    OP1_VARR(DEFINED_OP(op->op1)) == RES_VARR(DEFINED_OP(op->op1))) {
+                DEFINED_OP(op->op1)->opcode = ZEND_ADD_STRING;
+            }
+            SET_DEFINED(DEFINED_OP(op->op1));
+            SET_TO_NOP(op);
+#ifndef ZEND_ENGINE_2_3
+            /* TODO: Doesn't work with PHP-5.3. Needs more research */
+
+            /* FETCH_X      local("GLOBALS"),$x => FETCH_X global($y),$z
+               FETCH_DIM_X  $x,$y,$z               NOP
+            */
+        } else if (
+            ((op->opcode == ZEND_FETCH_DIM_R &&
+              OP1_TYPE(op) == IS_VAR &&
+              /*???               op->extended_value == ZEND_FETCH_STANDARD &&*/
               IS_DEFINED(op->op1) &&
-              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_IS &&
-              FETCH_TYPE(DEFINED_OP(op->op1)) == ZEND_FETCH_GLOBAL &&
-              DEFINED_OP(op->op1)->op1.op_type == IS_CONST &&
-              DEFINED_OP(op->op1)->op1.u.constant.type == IS_STRING &&
-              DEFINED_OP(op->op1)->op1.u.constant.value.str.len == (sizeof("GLOBALS")-1) &&
-              memcmp(DEFINED_OP(op->op1)->op1.u.constant.value.str.val, "GLOBALS", sizeof("GLOBALS")-1) == 0) {
-      zend_op* x = DEFINED_OP(op->op1);
-      STR_FREE(x->op1.u.constant.value.str.val);
-      x->opcode = ZEND_ISSET_ISEMPTY_VAR;
-      x->extended_value = op->extended_value;
-      FETCH_TYPE(x) = ZEND_FETCH_GLOBAL;
-      memcpy(&x->op1,&op->op2,sizeof(znode));
-      memcpy(&x->result,&op->result,sizeof(znode));
-      SET_DEFINED(x);
-      SET_TO_NOP(op);
-    } else if (op->opcode == ZEND_FREE &&
-               op->op1.op_type == IS_TMP_VAR &&
-               IS_DEFINED(op->op1)) {
-      /* POST_INC + FREE => PRE_INC */
-      if (DEFINED_OP(op->op1)->opcode == ZEND_POST_INC) {
-        DEFINED_OP(op->op1)->opcode = ZEND_PRE_INC;
-        DEFINED_OP(op->op1)->result.op_type = IS_VAR;
-        DEFINED_OP(op->op1)->result.u.EA.type |= EXT_TYPE_UNUSED;
-        SET_UNDEFINED(op->op1);
-        SET_TO_NOP(op);
-      /* POST_DEC + FREE => PRE_DEC */
-      } else if (DEFINED_OP(op->op1)->opcode == ZEND_POST_DEC) {
-        DEFINED_OP(op->op1)->opcode = ZEND_PRE_DEC;
-        DEFINED_OP(op->op1)->result.op_type = IS_VAR;
-        DEFINED_OP(op->op1)->result.u.EA.type |= EXT_TYPE_UNUSED;
-        SET_UNDEFINED(op->op1);
-        SET_TO_NOP(op);
-      /* PRINT + FREE => ECHO */
-      } else if (DEFINED_OP(op->op1)->opcode == ZEND_PRINT) {
-        DEFINED_OP(op->op1)->opcode = ZEND_ECHO;
-        DEFINED_OP(op->op1)->result.op_type = IS_UNUSED;
-        SET_UNDEFINED(op->op1);
-        SET_TO_NOP(op);
-      /* BOOL + FREE => NOP + NOP */
-      } else if (DEFINED_OP(op->op1)->opcode == ZEND_BOOL) {
-        SET_TO_NOP(DEFINED_OP(op->op1));
-        SET_UNDEFINED(op->op1);
-        SET_TO_NOP(op);
-      }
-    /* CMP + BOOL     => CMP + NOP */
-    } else if (op->opcode == ZEND_BOOL &&
-               op->op1.op_type == IS_TMP_VAR &&
-               (!global[VAR_NUM(op->op1.u.var)] ||
-                (op->result.op_type == IS_TMP_VAR &&
-                 op->op1.u.var == op->result.u.var)) &&
-               IS_DEFINED(op->op1) &&
-               (DEFINED_OP(op->op1)->opcode == ZEND_IS_IDENTICAL ||
-                DEFINED_OP(op->op1)->opcode == ZEND_IS_NOT_IDENTICAL ||
-                DEFINED_OP(op->op1)->opcode == ZEND_IS_EQUAL ||
-                DEFINED_OP(op->op1)->opcode == ZEND_IS_NOT_EQUAL ||
-                DEFINED_OP(op->op1)->opcode == ZEND_IS_SMALLER ||
-                DEFINED_OP(op->op1)->opcode == ZEND_IS_SMALLER_OR_EQUAL)) {
-      memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
-      SET_DEFINED(DEFINED_OP(op->op1));
-      SET_TO_NOP(op);
-    /* BOOL + BOOL     => NOP + BOOL
-       BOOL + BOOL_NOT => NOP + BOOL_NOT
-       BOOL + JMP...   => NOP + JMP...
-    */
-    } else if ((op->opcode == ZEND_BOOL ||
-                op->opcode == ZEND_BOOL_NOT ||
-                op->opcode == ZEND_JMPZ||
-                op->opcode == ZEND_JMPNZ ||
-                op->opcode == ZEND_JMPZNZ ||
-                op->opcode == ZEND_JMPZ_EX ||
-                op->opcode == ZEND_JMPNZ_EX) &&
-                op->op1.op_type == IS_TMP_VAR &&
-                (!global[VAR_NUM(op->op1.u.var)] ||
-                 (op->result.op_type == IS_TMP_VAR &&
-                  op->op1.u.var == op->result.u.var)) &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_BOOL) {
-      zend_op *x = DEFINED_OP(op->op1);
-      SET_UNDEFINED(op->op1);
-      memcpy(&op->op1, &x->op1, sizeof(op->op1));
-      SET_TO_NOP(x);
-    /* BOOL_NOT + BOOL     => NOP + BOOL_NOT
-       BOOL_NOT + BOOL_NOT => NOP + BOOL
-       BOOL_NOT + JMP...   => NOP + JMP[n]...
-    */
-    } else if ((op->opcode == ZEND_BOOL ||
-                op->opcode == ZEND_BOOL_NOT ||
-                op->opcode == ZEND_JMPZ||
-                op->opcode == ZEND_JMPNZ) &&
-                op->op1.op_type == IS_TMP_VAR &&
-                (!global[VAR_NUM(op->op1.u.var)] ||
-                 (op->result.op_type == IS_TMP_VAR &&
-                  op->op1.u.var == op->result.u.var)) &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_BOOL_NOT) {
-      zend_op *x = DEFINED_OP(op->op1);
-      switch (op->opcode) {
-        case ZEND_BOOL:     op->opcode = ZEND_BOOL_NOT; break;
-        case ZEND_BOOL_NOT: op->opcode = ZEND_BOOL;     break;
-        case ZEND_JMPZ:     op->opcode = ZEND_JMPNZ;    break;
-        case ZEND_JMPNZ:    op->opcode = ZEND_JMPZ;     break;
-      }
-      SET_UNDEFINED(op->op1);
-      memcpy(&op->op1, &x->op1, sizeof(op->op1));
-      SET_TO_NOP(x);
-    /* function_exists(STR) or is_callable(STR) */
-    } else if ((op->opcode == ZEND_BOOL ||
-                op->opcode == ZEND_BOOL_NOT ||
-                op->opcode == ZEND_JMPZ||
-                op->opcode == ZEND_JMPNZ ||
-                op->opcode == ZEND_JMPZNZ ||
-                op->opcode == ZEND_JMPZ_EX ||
-                op->opcode == ZEND_JMPNZ_EX) &&
-                op->op1.op_type == IS_VAR &&
-                !global[VAR_NUM(op->op1.u.var)] &&
-                IS_DEFINED(op->op1) &&
-                DEFINED_OP(op->op1)->opcode == ZEND_DO_FCALL &&
-                DEFINED_OP(op->op1)->extended_value == 1 &&
-                DEFINED_OP(op->op1)->op1.op_type == IS_CONST &&
-                DEFINED_OP(op->op1)->op1.u.constant.type == IS_STRING) {
-      zend_op* call = DEFINED_OP(op->op1);
-      zend_op* send = call-1;
-      if (send->opcode == ZEND_SEND_VAL &&
-          send->extended_value == ZEND_DO_FCALL &&
-          send->op1.op_type == IS_CONST &&
-          send->op1.u.constant.type == IS_STRING &&
-          (strcmp(call->op1.u.constant.value.str.val,"function_exists") == 0 ||
-           strcmp(call->op1.u.constant.value.str.val,"is_callable") == 0)) {
-        if (opt_function_exists(send->op1.u.constant.value.str.val, send->op1.u.constant.value.str.len  TSRMLS_CC)) {
-          SET_UNDEFINED(op->op1);
-          zval_dtor(&send->op1.u.constant);
-          SET_TO_NOP(send);
-          zval_dtor(&call->op1.u.constant);
-          SET_TO_NOP(call);
-          op->op1.op_type = IS_CONST;
-          op->op1.u.constant.type = IS_BOOL;
-          op->op1.u.constant.value.lval = 1;
-        }
-      } else if (send->opcode == ZEND_SEND_VAL &&
-          send->extended_value == ZEND_DO_FCALL &&
-          send->op1.op_type == IS_CONST &&
-          send->op1.u.constant.type == IS_STRING &&
-          strcmp(call->op1.u.constant.value.str.val,"extension_loaded") == 0) {
-        if (opt_extension_loaded(send->op1.u.constant.value.str.val, send->op1.u.constant.value.str.len  TSRMLS_CC)) {
-          SET_UNDEFINED(op->op1);
-          zval_dtor(&send->op1.u.constant);
-          SET_TO_NOP(send);
-          zval_dtor(&call->op1.u.constant);
-          SET_TO_NOP(call);
-          op->op1.op_type = IS_CONST;
-          op->op1.u.constant.type = IS_BOOL;
-          op->op1.u.constant.value.lval = 1;
-        }
-      } else if (send->opcode == ZEND_SEND_VAL &&
-          send->extended_value == ZEND_DO_FCALL &&
-          send->op1.op_type == IS_CONST &&
-          send->op1.u.constant.type == IS_STRING &&
-          strcmp(call->op1.u.constant.value.str.val,"defined") == 0) {
-        zend_constant *c = NULL;
-        if (opt_get_constant(send->op1.u.constant.value.str.val, send->op1.u.constant.value.str.len, &c TSRMLS_CC) && c != NULL && ((c->flags & CONST_PERSISTENT) != 0)) {
-          SET_UNDEFINED(op->op1);
-          zval_dtor(&send->op1.u.constant);
-          SET_TO_NOP(send);
-          zval_dtor(&call->op1.u.constant);
-          SET_TO_NOP(call);
-          op->op1.op_type = IS_CONST;
-          op->op1.u.constant.type = IS_BOOL;
-          op->op1.u.constant.value.lval = 1;
-        }
-      }
-    /* QM_ASSIGN($x,$x) => NOP */
-    } else if (op->opcode == ZEND_QM_ASSIGN &&
-               op->op1.op_type == IS_TMP_VAR &&
-               op->result.op_type == IS_TMP_VAR &&
-               op->op1.u.var == op->result.u.var) {
-      SET_TO_NOP(op);
-    /* ?(,,$tmp_x) +QM_ASSIGN($tmp_x,$tmp_y) => ?(,,$tmp_y) + NOP */
-    } else if (op->opcode == ZEND_QM_ASSIGN &&
-               op->op1.op_type == IS_TMP_VAR &&
-               !global[VAR_NUM(op->op1.u.var)] &&
-               op->op1.u.var != op->result.u.var &&
-               IS_DEFINED(op->op1)) {
-      zend_op *x = DEFINED_OP(op->op1);
-      if (x->opcode != ZEND_ADD_ARRAY_ELEMENT &&
-          x->opcode != ZEND_ADD_STRING &&
-          x->opcode != ZEND_ADD_CHAR &&
-          x->opcode != ZEND_ADD_VAR) {
-        SET_UNDEFINED(op->op1);
-        memcpy(&x->result, &op->result, sizeof(op->result));
-        SET_DEFINED(x);
-        SET_TO_NOP(op);
-      }
-    /* ECHO(const) + ECHO(const) => ECHO(const) */
-    } else if (prev != NULL &&
-               op->opcode == ZEND_ECHO &&
-               op->op1.op_type == IS_CONST &&
-               prev->opcode == ZEND_ECHO &&
-               prev->op1.op_type == IS_CONST) {
-      int len;
-      convert_to_string(&prev->op1.u.constant);
-      convert_to_string(&op->op1.u.constant);
-      len = prev->op1.u.constant.value.str.len + op->op1.u.constant.value.str.len;
-      STR_REALLOC(prev->op1.u.constant.value.str.val,len+1);
-      memcpy(prev->op1.u.constant.value.str.val+prev->op1.u.constant.value.str.len,
-             op->op1.u.constant.value.str.val, op->op1.u.constant.value.str.len);
-      prev->op1.u.constant.value.str.val[len] = 0;
-      prev->op1.u.constant.value.str.len = len;
-      STR_FREE(op->op1.u.constant.value.str.val);
-      SET_TO_NOP(op);
-    /* END_SILENCE + BEGIN_SILENCE => NOP + NOP */
-    } else if (prev != NULL &&
-               prev->opcode == ZEND_END_SILENCE &&
-               op->opcode == ZEND_BEGIN_SILENCE) {
-      zend_op *x = op+1;
-      while (x < end) {
-        if (x->opcode == ZEND_END_SILENCE &&
-            x->op1.u.var == op->result.u.var) {
-          x->op1.u.var = prev->op1.u.var;
-          SET_TO_NOP(prev);
-          SET_TO_NOP(op);
-          break;
-        }
-        x++;
-      }
-    /* BEGIN_SILENCE + END_SILENCE => NOP + NOP */
-    } else if (prev != NULL &&
-               prev->opcode == ZEND_BEGIN_SILENCE &&
-               op->opcode == ZEND_END_SILENCE &&
-               prev->result.u.var == op->op1.u.var) {
-      SET_TO_NOP(prev);
-      SET_TO_NOP(op);
-    /* SEND_VAR_NO_REF => SEND_VAR (cond) */
-    } else if (op->opcode == ZEND_SEND_VAR_NO_REF &&
-               (op->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) &&
-               !(op->extended_value & ZEND_ARG_SEND_BY_REF)) {
-      op->opcode = ZEND_SEND_VAR;
-      op->extended_value = ZEND_DO_FCALL;
-    /* INIT_FCALL_BY_NAME + DO_FCALL_BY_NAME => DO_FCALL $x */
-    } else if (prev != NULL &&
-               op->opcode == ZEND_DO_FCALL_BY_NAME &&
-               op->extended_value == 0 &&
-               op->op1.op_type == IS_CONST &&
-               op->op1.u.constant.type == IS_STRING &&
-               prev->opcode == ZEND_INIT_FCALL_BY_NAME &&
-               prev->op1.op_type == IS_UNUSED &&
-               prev->op2.op_type == IS_CONST &&
-               prev->op2.u.constant.type == IS_STRING &&
-               op->op1.u.constant.value.str.len == prev->op2.u.constant.value.str.len &&
-               (memcmp(op->op1.u.constant.value.str.val,prev->op2.u.constant.value.str.val,op->op1.u.constant.value.str.len) == 0)) {
-       op->opcode = ZEND_DO_FCALL;
-       STR_FREE(prev->op2.u.constant.value.str.val);
-       SET_TO_NOP(prev);
-    }
-
-    /* $a = $a + ? => $a+= ? */
-    if (op->opcode == ZEND_ASSIGN &&
-        op->op1.op_type == IS_VAR &&
-        op->op2.op_type == IS_TMP_VAR &&
-        IS_DEFINED(op->op1) &&
-        IS_DEFINED(op->op2)) {
-      zend_op* l = DEFINED_OP(op->op1);
-      zend_op* r = DEFINED_OP(op->op2);
-      if (l->opcode == ZEND_FETCH_W &&
-          l->op1.op_type == IS_CONST &&
-          l->op1.u.constant.type == IS_STRING &&
-          (r->opcode  == ZEND_ADD ||
-           r->opcode  == ZEND_SUB ||
-           r->opcode  == ZEND_MUL ||
-           r->opcode  == ZEND_DIV ||
-           r->opcode  == ZEND_MOD ||
-           r->opcode  == ZEND_SL ||
-           r->opcode  == ZEND_SR ||
-           r->opcode  == ZEND_CONCAT ||
-           r->opcode  == ZEND_BW_OR ||
-           r->opcode  == ZEND_BW_AND ||
-           r->opcode  == ZEND_BW_XOR) &&
-         r->op1.op_type == IS_VAR &&
-         IS_DEFINED(r->op1)) {
-        zend_op* rl = DEFINED_OP(r->op1);
-        if (rl->opcode == ZEND_FETCH_R &&
-            rl->op1.op_type == IS_CONST &&
-            rl->op1.u.constant.type == IS_STRING &&
-            FETCH_TYPE(rl) == FETCH_TYPE(l) &&
-            l->op1.u.constant.value.str.len ==
-              rl->op1.u.constant.value.str.len &&
-            memcmp(l->op1.u.constant.value.str.val,
-              rl->op1.u.constant.value.str.val,
-              l->op1.u.constant.value.str.len) == 0) {
-          switch (r->opcode) {
-            case ZEND_ADD:    op->opcode = ZEND_ASSIGN_ADD; break;
-            case ZEND_SUB:    op->opcode = ZEND_ASSIGN_SUB; break;
-            case ZEND_MUL:    op->opcode = ZEND_ASSIGN_MUL; break;
-            case ZEND_DIV:    op->opcode = ZEND_ASSIGN_DIV; break;
-            case ZEND_MOD:    op->opcode = ZEND_ASSIGN_MOD; break;
-            case ZEND_SL:     op->opcode = ZEND_ASSIGN_SL;  break;
-            case ZEND_SR:     op->opcode = ZEND_ASSIGN_SR;  break;
-            case ZEND_CONCAT: op->opcode = ZEND_ASSIGN_CONCAT; break;
-            case ZEND_BW_OR:  op->opcode = ZEND_ASSIGN_BW_OR;  break;
-            case ZEND_BW_AND: op->opcode = ZEND_ASSIGN_BW_AND; break;
-            case ZEND_BW_XOR: op->opcode = ZEND_ASSIGN_BW_XOR; break;
-            default:
-              break;
-          }
-          memcpy(&op->op2, &r->op2, sizeof(op->op2));
-          l->opcode = ZEND_FETCH_RW;
-          SET_TO_NOP(r);
-          STR_FREE(rl->op1.u.constant.value.str.val);
-          SET_TO_NOP(rl);
-        }
-      }
-    }
-
-    if (pass == 1) {
-      /* FETCH_W var,$x + ASSIGN $x,?,_  + FETCH_R var,$y =>
-         FETCH_W var,$x + ASSIGN $x,?,$y */
-      if (op->opcode == ZEND_UNSET_VAR ||
-          op->opcode == ZEND_DO_FCALL ||
-          op->opcode == ZEND_DO_FCALL_BY_NAME ||
-          op->opcode == ZEND_POST_INC ||
-          op->opcode == ZEND_POST_DEC ||
-          op->opcode == ZEND_UNSET_DIM ||
-          op->opcode == ZEND_UNSET_OBJ ||
-          op->opcode == ZEND_INCLUDE_OR_EVAL ||
-          op->opcode == ZEND_ASSIGN_DIM ||
-          op->opcode == ZEND_ASSIGN_OBJ) {
-        zend_hash_clean(&assigns);
-        zend_hash_clean(&fetch_dim);
-      } else if (op->opcode == ZEND_ASSIGN_REF ||
-                 op->opcode == ZEND_ASSIGN ||
-                 op->opcode == ZEND_PRE_INC ||
-                 op->opcode == ZEND_PRE_DEC ||
-                 op->opcode == ZEND_ASSIGN_ADD ||
-                 op->opcode == ZEND_ASSIGN_SUB ||
-                 op->opcode == ZEND_ASSIGN_MUL ||
-                 op->opcode == ZEND_ASSIGN_DIV ||
-                 op->opcode == ZEND_ASSIGN_MOD ||
-                 op->opcode == ZEND_ASSIGN_SL ||
-                 op->opcode == ZEND_ASSIGN_SR ||
-                 op->opcode == ZEND_ASSIGN_CONCAT ||
-                 op->opcode == ZEND_ASSIGN_BW_OR ||
-                 op->opcode == ZEND_ASSIGN_BW_AND ||
-                 op->opcode == ZEND_ASSIGN_BW_XOR) {
-        zend_hash_clean(&assigns);
-        zend_hash_clean(&fetch_dim);
-        if ((op->result.u.EA.type & EXT_TYPE_UNUSED) != 0 &&
-            op->op1.op_type == IS_VAR &&
-            op->extended_value != ZEND_ASSIGN_DIM &&
-            op->extended_value != ZEND_ASSIGN_OBJ &&
-            IS_DEFINED(op->op1)) {
-          zend_op *x = DEFINED_OP(op->op1);
-          if ((x->opcode == ZEND_FETCH_W || x->opcode == ZEND_FETCH_RW) && 
-              x->op1.op_type == IS_CONST && x->op1.u.constant.type == IS_STRING) {
-            union {
-              zend_op *v;
-              void *ptr;
-            } op_copy;
-            char *s = emalloc(x->op1.u.constant.value.str.len+2);
-            op_copy.v = op;
-            memcpy(s,x->op1.u.constant.value.str.val,x->op1.u.constant.value.str.len);
-            s[x->op1.u.constant.value.str.len] = (char)FETCH_TYPE(x);
-            s[x->op1.u.constant.value.str.len+1] = '\0';
-            zend_hash_update(&assigns, s, x->op1.u.constant.value.str.len+2, &op_copy.ptr, 
-                sizeof(void*), NULL);
-            efree(s);
-          }
-        }
-      } else if ((op->opcode == ZEND_FETCH_R || op->opcode == ZEND_FETCH_IS) && 
-          !global[VAR_NUM(op->result.u.var)] && op->op1.op_type == IS_CONST &&
-          op->op1.u.constant.type == IS_STRING) {
-        union {
-          zend_op *v;
-          void *ptr;
-        } x;
-        char *s = emalloc(op->op1.u.constant.value.str.len+2);
-        memcpy(s,op->op1.u.constant.value.str.val,op->op1.u.constant.value.str.len);
-        s[op->op1.u.constant.value.str.len] = (char)FETCH_TYPE(op);
-        s[op->op1.u.constant.value.str.len+1] = '\0';
-
-        if (zend_hash_find(&assigns, s, op->op1.u.constant.value.str.len+2, 
-              &x.ptr) == SUCCESS) {
-          x.v = *(zend_op**)x.v;
-          memcpy(&x.v->result, &op->result, sizeof(op->result));
-          x.v->result.u.EA.type = 0;
-          SET_DEFINED(x.v);
-          zend_hash_del(&assigns, s, op->op1.u.constant.value.str.len+2);
-          STR_FREE(op->op1.u.constant.value.str.val);
-          SET_TO_NOP(op);
-        }
-        efree(s);
-      } else if (op->opcode == ZEND_FETCH_DIM_R &&
-          op->extended_value != ZEND_FETCH_ADD_LOCK &&
-          op->op1.op_type == IS_VAR &&
-          IS_DEFINED(op->op1)) {
-        zend_op *x = DEFINED_OP(op->op1);
-        while ((x->opcode == ZEND_ASSIGN_REF ||
-                x->opcode == ZEND_ASSIGN ||
-                x->opcode == ZEND_PRE_INC ||
-                x->opcode == ZEND_PRE_DEC ||
-                x->opcode == ZEND_ASSIGN_ADD ||
-                x->opcode == ZEND_ASSIGN_SUB ||
-                x->opcode == ZEND_ASSIGN_MUL ||
-                x->opcode == ZEND_ASSIGN_DIV ||
-                x->opcode == ZEND_ASSIGN_MOD ||
-                x->opcode == ZEND_ASSIGN_SL ||
-                x->opcode == ZEND_ASSIGN_SR ||
-                x->opcode == ZEND_ASSIGN_CONCAT ||
-                x->opcode == ZEND_ASSIGN_BW_OR ||
-                x->opcode == ZEND_ASSIGN_BW_AND ||
-                x->opcode == ZEND_ASSIGN_BW_XOR) &&
-                x->op1.op_type == IS_VAR &&
-                IS_DEFINED(x->op1)) {
-          x = DEFINED_OP(x->op1);
-        }
-        if ((x->opcode == ZEND_FETCH_R || x->opcode == ZEND_FETCH_W || 
-              x->opcode == ZEND_FETCH_RW) && x->op1.op_type == IS_CONST && 
-            x->op1.u.constant.type == IS_STRING) {
-          union {
-            zend_op *v;
-            void *ptr;
-          } y;
-          union {
-            zend_op *v;
-            void *ptr;
-          } op_copy;
-          char *s = emalloc(x->op1.u.constant.value.str.len+2);
-          op_copy.v = op;
-          memcpy(s,x->op1.u.constant.value.str.val,x->op1.u.constant.value.str.len);
-          s[x->op1.u.constant.value.str.len] = (char)FETCH_TYPE(x);
-          s[x->op1.u.constant.value.str.len+1] = '\0';
-          if (zend_hash_find(&fetch_dim, s, x->op1.u.constant.value.str.len+2, 
-                &y.ptr) == SUCCESS) {
-            y.v = *(zend_op**)y.v;
-            y.v->extended_value = ZEND_FETCH_ADD_LOCK;
-            zend_hash_update(&fetch_dim, s, x->op1.u.constant.value.str.len+2, 
-                &op_copy.ptr, sizeof(void*), NULL);
-            SET_UNDEFINED(x->result);
-            STR_FREE(x->op1.u.constant.value.str.val);
+              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_R) ||
+             (op->opcode == ZEND_FETCH_DIM_W &&
+              OP1_TYPE(op) == IS_VAR &&
+              IS_DEFINED(op->op1) &&
+              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_W) ||
+             (op->opcode == ZEND_FETCH_DIM_RW &&
+              OP1_TYPE(op) == IS_VAR &&
+              IS_DEFINED(op->op1) &&
+              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_RW) ||
+             (op->opcode == ZEND_FETCH_DIM_IS &&
+              OP1_TYPE(op) == IS_VAR &&
+              IS_DEFINED(op->op1) &&
+              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_IS) ||
+             (op->opcode == ZEND_FETCH_DIM_FUNC_ARG &&
+              OP1_TYPE(op) == IS_VAR &&
+              IS_DEFINED(op->op1) &&
+              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_FUNC_ARG) ||
+             (op->opcode == ZEND_FETCH_DIM_UNSET &&
+              OP1_TYPE(op) == IS_VAR &&
+              IS_DEFINED(op->op1) &&
+              DEFINED_OP(op->op1)->opcode == ZEND_FETCH_UNSET)) &&
+            FETCH_TYPE(DEFINED_OP(op->op1)) == ZEND_FETCH_GLOBAL &&
+            OP1_TYPE(DEFINED_OP(op->op1)) == IS_CONST &&
+            DEFINED_OP(op->op1)->op1.u.constant.type == IS_STRING &&
+            DEFINED_OP(op->op1)->op1.u.constant.value.str.len == (sizeof("GLOBALS")-1) &&
+            memcmp(DEFINED_OP(op->op1)->op1.u.constant.value.str.val, "GLOBALS", sizeof("GLOBALS")-1) == 0) {
+            zend_op *x = op+1;
+            if (x->opcode != op->opcode) {
+                x = DEFINED_OP(op->op1);
+                SET_UNDEFINED(op->op1);
+                STR_FREE(x->op1.u.constant.value.str.val);
+                FETCH_TYPE(x) = ZEND_FETCH_GLOBAL;
+                memcpy(&x->op1,&op->op2,sizeof(op->op2));
+                memcpy(&x->result,&op->result,sizeof(op->result));
+                SET_DEFINED(x);
+                SET_TO_NOP(op);
+            }
+#endif
+#ifndef ZEND_ENGINE_2_4
+            /* FETCH_IS               local("GLOBALS"),$x    ISSET_ISEMPTY_VAR $y(global),res
+               ISSET_ISEMPTY_DIM_OBJ  $x,$y,$res          => NOP
+            */
+        } else if (op->opcode == ZEND_ISSET_ISEMPTY_DIM_OBJ &&
+                   OP1_TYPE(op) == IS_VAR &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_FETCH_IS &&
+                   FETCH_TYPE(DEFINED_OP(op->op1)) == ZEND_FETCH_GLOBAL &&
+                   OP1_TYPE(DEFINED_OP(op->op1)) == IS_CONST &&
+                   Z_TYPE(OP1_CONST(DEFINED_OP(op->op1))) == IS_STRING &&
+                   Z_STRLEN(OP1_CONST(DEFINED_OP(op->op1))) == (sizeof("GLOBALS")-1) &&
+                   memcmp(Z_STRVAL(OP1_CONST(DEFINED_OP(op->op1))), "GLOBALS", sizeof("GLOBALS") - 1) == 0) {
+            zend_op* x = DEFINED_OP(op->op1);
+#ifndef ZEND_ENGINE_2_4
+            STR_FREE(Z_STRVAL(OP1_CONST(x)));
+            /* TODO */
+#endif
+            x->opcode = ZEND_ISSET_ISEMPTY_VAR;
+            x->extended_value = op->extended_value;
+            FETCH_TYPE(x) = ZEND_FETCH_GLOBAL;
+            memcpy(&x->op1, &op->op2, sizeof(op->op2));
+            memcpy(&x->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+            x->op1_type = op->op2_type;
+            x->result_type = op->result_type;
+#endif
+            SET_DEFINED(x);
+            SET_TO_NOP(op);
+#endif
+        } else if (op->opcode == ZEND_FREE &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   IS_DEFINED(op->op1)) {
+            /* POST_INC + FREE => PRE_INC */
+            if (DEFINED_OP(op->op1)->opcode == ZEND_POST_INC) {
+                DEFINED_OP(op->op1)->opcode = ZEND_PRE_INC;
+                RES_TYPE(DEFINED_OP(op->op1)) = IS_VAR;
+                RES_USED(DEFINED_OP(op->op1)) |= EXT_TYPE_UNUSED;
+                SET_UNDEFINED(op->op1);
+                SET_TO_NOP(op);
+                /* POST_DEC + FREE => PRE_DEC */
+            } else if (DEFINED_OP(op->op1)->opcode == ZEND_POST_DEC) {
+                DEFINED_OP(op->op1)->opcode = ZEND_PRE_DEC;
+                RES_TYPE(DEFINED_OP(op->op1)) = IS_VAR;
+                RES_USED(DEFINED_OP(op->op1)) |= EXT_TYPE_UNUSED;
+                SET_UNDEFINED(op->op1);
+                SET_TO_NOP(op);
+                /* PRINT + FREE => ECHO */
+            } else if (DEFINED_OP(op->op1)->opcode == ZEND_PRINT) {
+                DEFINED_OP(op->op1)->opcode = ZEND_ECHO;
+                RES_TYPE(DEFINED_OP(op->op1)) = IS_UNUSED;
+                SET_UNDEFINED(op->op1);
+                SET_TO_NOP(op);
+                /* BOOL + FREE => NOP + NOP */
+            } else if (DEFINED_OP(op->op1)->opcode == ZEND_BOOL) {
+                SET_TO_NOP(DEFINED_OP(op->op1));
+                SET_UNDEFINED(op->op1);
+                SET_TO_NOP(op);
+            }
+            /* CMP + BOOL     => CMP + NOP */
+        } else if (op->opcode == ZEND_BOOL &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   (!global[VAR_NUM(OP1_VARR(op))] ||
+                    (RES_TYPE(op) == IS_TMP_VAR &&
+                     OP1_VARR(op) == RES_VARR(op))) &&
+                   IS_DEFINED(op->op1) &&
+                   (DEFINED_OP(op->op1)->opcode == ZEND_IS_IDENTICAL ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_IS_NOT_IDENTICAL ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_IS_EQUAL ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_IS_NOT_EQUAL ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_IS_SMALLER ||
+                    DEFINED_OP(op->op1)->opcode == ZEND_IS_SMALLER_OR_EQUAL)) {
+            memcpy(&DEFINED_OP(op->op1)->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+            DEFINED_OP(op->op1)->result_type = op->result_type;
+#endif
+            SET_DEFINED(DEFINED_OP(op->op1));
+            SET_TO_NOP(op);
+            /* BOOL + BOOL     => NOP + BOOL
+               BOOL + BOOL_NOT => NOP + BOOL_NOT
+               BOOL + JMP...   => NOP + JMP...
+            */
+        } else if ((op->opcode == ZEND_BOOL ||
+                    op->opcode == ZEND_BOOL_NOT ||
+                    op->opcode == ZEND_JMPZ||
+                    op->opcode == ZEND_JMPNZ ||
+                    op->opcode == ZEND_JMPZNZ ||
+                    op->opcode == ZEND_JMPZ_EX ||
+                    op->opcode == ZEND_JMPNZ_EX) &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   (!global[VAR_NUM(OP1_VARR(op))] ||
+                    (RES_TYPE(op) == IS_TMP_VAR &&
+                     OP1_VARR(op) == RES_VARR(op))) &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_BOOL) {
+            zend_op *x = DEFINED_OP(op->op1);
+            SET_UNDEFINED(op->op1);
+            memcpy(&op->op1, &x->op1, sizeof(x->op1));
+#ifdef ZEND_ENGINE_2_4
+            op->op1_type = x->op1_type;
+#endif
+            SET_TO_NOP(x);
+            /* BOOL_NOT + BOOL     => NOP + BOOL_NOT
+               BOOL_NOT + BOOL_NOT => NOP + BOOL
+               BOOL_NOT + JMP...   => NOP + JMP[n]...
+            */
+        } else if ((op->opcode == ZEND_BOOL ||
+                    op->opcode == ZEND_BOOL_NOT ||
+                    op->opcode == ZEND_JMPZ||
+                    op->opcode == ZEND_JMPNZ) &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   (!global[VAR_NUM(OP1_VARR(op))] ||
+                    (RES_TYPE(op) == IS_TMP_VAR &&
+                     OP1_VARR(op) == RES_VARR(op))) &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_BOOL_NOT) {
+            zend_op *x = DEFINED_OP(op->op1);
+            switch (op->opcode) {
+            case ZEND_BOOL:
+                op->opcode = ZEND_BOOL_NOT;
+                break;
+            case ZEND_BOOL_NOT:
+                op->opcode = ZEND_BOOL;
+                break;
+            case ZEND_JMPZ:
+                op->opcode = ZEND_JMPNZ;
+                break;
+            case ZEND_JMPNZ:
+                op->opcode = ZEND_JMPZ;
+                break;
+            }
+            SET_UNDEFINED(op->op1);
+            memcpy(&op->op1, &x->op1, sizeof(x->op1));
+#ifdef ZEND_ENGINE_2_4
+            op->op1_type = x->op1_type;
+#endif
             SET_TO_NOP(x);
-            memcpy(&op->op1, &y.v->op1, sizeof(op->op1));
-          } else {
-            zend_hash_update(&fetch_dim, s, x->op1.u.constant.value.str.len+2, 
-                &op_copy.ptr, sizeof(void*), NULL);
-          }
-          efree(s);
-        }
-      }
-    }
-
-    if (op->opcode != ZEND_NOP) {
-      prev = op;
-    }
-    if ((op->result.op_type == IS_VAR &&
-        (op->opcode == ZEND_RECV || op->opcode == ZEND_RECV_INIT ||
-         (op->result.u.EA.type & EXT_TYPE_UNUSED) == 0)) ||
-        (op->result.op_type == IS_TMP_VAR)) {
-      if (op->opcode == ZEND_RECV ||
-          op->opcode == ZEND_RECV_INIT) {
-        SET_UNDEFINED(op->result);
-      } else {
-        SET_DEFINED(op);
-      }
+            /* function_exists(STR) or is_callable(STR) */
+        } else if ((op->opcode == ZEND_BOOL ||
+                    op->opcode == ZEND_BOOL_NOT ||
+                    op->opcode == ZEND_JMPZ||
+                    op->opcode == ZEND_JMPNZ ||
+                    op->opcode == ZEND_JMPZNZ ||
+                    op->opcode == ZEND_JMPZ_EX ||
+                    op->opcode == ZEND_JMPNZ_EX) &&
+                   OP1_TYPE(op) == IS_VAR &&
+                   !global[VAR_NUM(OP1_VARR(op))] &&
+                   IS_DEFINED(op->op1) &&
+                   DEFINED_OP(op->op1)->opcode == ZEND_DO_FCALL &&
+                   DEFINED_OP(op->op1)->extended_value == 1 &&
+                   OP1_TYPE(DEFINED_OP(op->op1)) == IS_CONST &&
+                   Z_TYPE(OP1_CONST(DEFINED_OP(op->op1))) == IS_STRING) {
+            zend_op* call = DEFINED_OP(op->op1);
+            zend_op* send = call-1;
+            if (send->opcode == ZEND_SEND_VAL &&
+                    send->extended_value == ZEND_DO_FCALL &&
+                    OP1_TYPE(send) == IS_CONST &&
+                    Z_TYPE(OP1_CONST(send)) == IS_STRING &&
+                    (strcmp(Z_STRVAL(OP1_CONST(call)), "function_exists") == 0 ||
+                     strcmp(Z_STRVAL(OP1_CONST(call)), "is_callable") == 0)) {
+                if (opt_function_exists(Z_STRVAL(OP1_CONST(send)), Z_STRLEN(OP1_CONST(send))  TSRMLS_CC)) {
+                    SET_UNDEFINED(op->op1);
+#ifndef ZEND_ENGINE_2_4
+                    zval_dtor(&send->op1.u.constant);
+                    zval_dtor(&call->op1.u.constant);
+                    /* TODO: check */
+#endif
+                    SET_TO_NOP(send);
+                    SET_TO_NOP(call);
+                    OP1_TYPE(op) = IS_CONST;
+                    Z_TYPE(OP1_CONST(op)) = IS_BOOL;
+                    Z_LVAL(OP1_CONST(op)) = 1;
+                }
+            } else if (send->opcode == ZEND_SEND_VAL &&
+                       send->extended_value == ZEND_DO_FCALL &&
+                       OP1_TYPE(send) == IS_CONST &&
+                       Z_TYPE(OP1_CONST(send)) == IS_STRING &&
+                       strcmp(Z_STRVAL(OP1_CONST(call)), "extension_loaded") == 0) {
+                if (opt_extension_loaded(Z_STRVAL(OP1_CONST(send)), Z_STRLEN(OP1_CONST(send))  TSRMLS_CC)) {
+                    SET_UNDEFINED(op->op1);
+#ifndef ZEND_ENGINE_2_4
+                    zval_dtor(&send->op1.u.constant);
+                    zval_dtor(&call->op1.u.constant);
+                    /* TODO: check */
+#endif
+                    SET_TO_NOP(send);
+                    SET_TO_NOP(call);
+                    OP1_TYPE(op) = IS_CONST;
+                    Z_TYPE(OP1_CONST(op)) = IS_BOOL;
+                    Z_LVAL(OP1_CONST(op)) = 1;
+                }
+            } else if (send->opcode == ZEND_SEND_VAL &&
+                       send->extended_value == ZEND_DO_FCALL &&
+                       OP1_TYPE(send) == IS_CONST &&
+                       Z_TYPE(OP1_CONST(send)) == IS_STRING &&
+                       strcmp(Z_STRVAL(OP1_CONST(call)), "defined") == 0) {
+                zend_constant *c = NULL;
+                if (opt_get_constant(Z_STRVAL(OP1_CONST(send)), Z_STRLEN(OP1_CONST(send)), &c TSRMLS_CC) && c != NULL && ((c->flags & CONST_PERSISTENT) != 0)) {
+                    SET_UNDEFINED(op->op1);
+#ifndef ZEND_ENGINE_2_4
+                    zval_dtor(&send->op1.u.constant);
+                    zval_dtor(&call->op1.u.constant);
+                    /* TODO: check */
+#endif
+                    SET_TO_NOP(send);
+                    SET_TO_NOP(call);
+                    OP1_TYPE(op) = IS_CONST;
+                    Z_TYPE(OP1_CONST(op)) = IS_BOOL;
+                    Z_LVAL(OP1_CONST(op)) = 1;
+                }
+            }
+            /* QM_ASSIGN($x,$x) => NOP */
+        } else if (op->opcode == ZEND_QM_ASSIGN &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   RES_TYPE(op) == IS_TMP_VAR &&
+                   OP1_VARR(op) == RES_VARR(op)) {
+            SET_TO_NOP(op);
+            /* ?(,,$tmp_x) +QM_ASSIGN($tmp_x,$tmp_y) => ?(,,$tmp_y) + NOP */
+        } else if (op->opcode == ZEND_QM_ASSIGN &&
+                   OP1_TYPE(op) == IS_TMP_VAR &&
+                   !global[VAR_NUM(OP1_VARR(op))] &&
+                   OP1_VARR(op) != RES_VARR(op) &&
+                   IS_DEFINED(op->op1)) {
+            zend_op *x = DEFINED_OP(op->op1);
+            if (x->opcode != ZEND_ADD_ARRAY_ELEMENT &&
+                    x->opcode != ZEND_ADD_STRING &&
+                    x->opcode != ZEND_ADD_CHAR &&
+                    x->opcode != ZEND_ADD_VAR) {
+                SET_UNDEFINED(op->op1);
+                memcpy(&x->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+                x->result_type = op->result_type;
+#endif
+                SET_DEFINED(x);
+                SET_TO_NOP(op);
+            }
+            /* ECHO(const) + ECHO(const) => ECHO(const) */
+        } else if (prev != NULL &&
+                   op->opcode == ZEND_ECHO &&
+                   OP1_TYPE(op) == IS_CONST &&
+                   prev->opcode == ZEND_ECHO &&
+                   OP1_TYPE(prev) == IS_CONST) {
+            int len;
+            convert_to_string(&OP1_CONST(prev));
+            convert_to_string(&OP1_CONST(op));
+            len = Z_STRLEN(OP1_CONST(prev)) + Z_STRLEN(OP1_CONST(op));
+#ifdef ZEND_ENGINE_2_4
+            if (IS_INTERNED(Z_STRVAL(OP1_CONST(prev))) ) {
+                //char *tmp = safe_emalloc(1, len, 1);
+                char *tmp = emalloc(len + 1);
+                memcpy(tmp, Z_STRVAL(OP1_CONST(prev)), Z_STRLEN(OP1_CONST(prev)));
+                Z_STRVAL(OP1_CONST(prev)) = tmp;
+            } else {
+                //Z_STRVAL(OP1_CONST(prev)) = safe_erealloc(Z_STRVAL(OP1_CONST(prev)), 1, len, 1);
+                STR_REALLOC(Z_STRVAL(OP1_CONST(prev)), len + 1);
+            }
+#else
+            STR_REALLOC(Z_STRVAL(OP1_CONST(prev)), len + 1);
+#endif
+            memcpy(Z_STRVAL(OP1_CONST(prev)) + Z_STRLEN(OP1_CONST(prev)),
+                   Z_STRVAL(OP1_CONST(op)), Z_STRLEN(OP1_CONST(op)));
+            Z_STRVAL(OP1_CONST(prev))[len] = 0;
+            Z_STRLEN(OP1_CONST(prev)) = len;
+#ifndef ZEND_ENGINE_2_4
+            /* TODO */
+            STR_FREE(Z_STRVAL(OP1_CONST(op)));
+#endif
+            SET_TO_NOP(op);
+            /* END_SILENCE + BEGIN_SILENCE => NOP + NOP */
+        } else if (prev != NULL &&
+                   prev->opcode == ZEND_END_SILENCE &&
+                   op->opcode == ZEND_BEGIN_SILENCE) {
+            zend_op *x = op + 1;
+            while (x < end) {
+                if (x->opcode == ZEND_END_SILENCE &&
+                        OP1_VARR(x) == RES_VARR(op)) {
+                    OP1_VARR(x) = OP1_VARR(prev);
+                    SET_TO_NOP(prev);
+                    SET_TO_NOP(op);
+                    break;
+                }
+                x++;
+            }
+            /* BEGIN_SILENCE + END_SILENCE => NOP + NOP */
+        } else if (prev != NULL &&
+                   prev->opcode == ZEND_BEGIN_SILENCE &&
+                   op->opcode == ZEND_END_SILENCE &&
+                   RES_VARR(prev) == OP1_VARR(op)) {
+            SET_TO_NOP(prev);
+            SET_TO_NOP(op);
+            /* SEND_VAR_NO_REF => SEND_VAR (cond) */
+        } else if (op->opcode == ZEND_SEND_VAR_NO_REF &&
+                   (op->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) &&
+                   !(op->extended_value & ZEND_ARG_SEND_BY_REF)) {
+            op->opcode = ZEND_SEND_VAR;
+            op->extended_value = ZEND_DO_FCALL;
+            /* INIT_FCALL_BY_NAME + DO_FCALL_BY_NAME => DO_FCALL $x */
+        } else if (prev != NULL &&
+                   op->opcode == ZEND_DO_FCALL_BY_NAME &&
+                   op->extended_value == 0 &&
+                   OP1_TYPE(op) == IS_CONST &&
+                   Z_TYPE(OP1_CONST(op)) == IS_STRING &&
+                   prev->opcode == ZEND_INIT_FCALL_BY_NAME &&
+                   OP1_TYPE(prev) == IS_UNUSED &&
+                   OP2_TYPE(prev) == IS_CONST &&
+                   Z_TYPE(OP2_CONST(prev)) == IS_STRING &&
+                   Z_STRLEN(OP1_CONST(op)) == Z_STRLEN(OP2_CONST(prev)) &&
+                   !memcmp(Z_STRVAL(OP1_CONST(op)), Z_STRVAL(OP2_CONST(prev)), Z_STRLEN(OP1_CONST(op)))) {
+            op->opcode = ZEND_DO_FCALL;
+#ifndef ZEND_ENGINE_2_4
+            STR_FREE(Z_STRVAL(OP2_CONST(prev)));
+            /* TODO */
+#endif
+            SET_TO_NOP(prev);
+        }
+
+        /* $a = $a + ? => $a+= ? */
+        if (op->opcode == ZEND_ASSIGN &&
+                OP1_TYPE(op) == IS_VAR &&
+                OP2_TYPE(op) == IS_TMP_VAR &&
+                IS_DEFINED(op->op1) &&
+                IS_DEFINED(op->op2)) {
+            zend_op* l = DEFINED_OP(op->op1);
+            zend_op* r = DEFINED_OP(op->op2);
+            if (l->opcode == ZEND_FETCH_W &&
+                    OP1_TYPE(l) == IS_CONST &&
+                    Z_TYPE(OP1_CONST(l)) == IS_STRING &&
+                    (r->opcode  == ZEND_ADD ||
+                     r->opcode  == ZEND_SUB ||
+                     r->opcode  == ZEND_MUL ||
+                     r->opcode  == ZEND_DIV ||
+                     r->opcode  == ZEND_MOD ||
+                     r->opcode  == ZEND_SL ||
+                     r->opcode  == ZEND_SR ||
+                     r->opcode  == ZEND_CONCAT ||
+                     r->opcode  == ZEND_BW_OR ||
+                     r->opcode  == ZEND_BW_AND ||
+                     r->opcode  == ZEND_BW_XOR) &&
+                    OP1_TYPE(r) == IS_VAR &&
+                    IS_DEFINED(r->op1)) {
+                zend_op* rl = DEFINED_OP(r->op1);
+                if (rl->opcode == ZEND_FETCH_R &&
+                        OP1_TYPE(rl) == IS_CONST &&
+                        Z_TYPE(OP1_CONST(rl)) == IS_STRING &&
+                        FETCH_TYPE(rl) == FETCH_TYPE(l) &&
+                        Z_STRLEN(OP1_CONST(l)) == Z_STRLEN(OP1_CONST(rl)) &&
+                        memcmp(Z_STRVAL(OP1_CONST(l)),
+                               Z_STRVAL(OP1_CONST(rl)),
+                               Z_STRLEN(OP1_CONST(l)) ) == 0) {
+                    switch (r->opcode) {
+                    case ZEND_ADD:
+                        op->opcode = ZEND_ASSIGN_ADD;
+                        break;
+                    case ZEND_SUB:
+                        op->opcode = ZEND_ASSIGN_SUB;
+                        break;
+                    case ZEND_MUL:
+                        op->opcode = ZEND_ASSIGN_MUL;
+                        break;
+                    case ZEND_DIV:
+                        op->opcode = ZEND_ASSIGN_DIV;
+                        break;
+                    case ZEND_MOD:
+                        op->opcode = ZEND_ASSIGN_MOD;
+                        break;
+                    case ZEND_SL:
+                        op->opcode = ZEND_ASSIGN_SL;
+                        break;
+                    case ZEND_SR:
+                        op->opcode = ZEND_ASSIGN_SR;
+                        break;
+                    case ZEND_CONCAT:
+                        op->opcode = ZEND_ASSIGN_CONCAT;
+                        break;
+                    case ZEND_BW_OR:
+                        op->opcode = ZEND_ASSIGN_BW_OR;
+                        break;
+                    case ZEND_BW_AND:
+                        op->opcode = ZEND_ASSIGN_BW_AND;
+                        break;
+                    case ZEND_BW_XOR:
+                        op->opcode = ZEND_ASSIGN_BW_XOR;
+                        break;
+                    default:
+                        break;
+                    }
+                    memcpy(&op->op2, &r->op2, sizeof(r->op2));
+#ifdef ZEND_ENGINE_2_4
+                    op->op2_type = r->op2_type;
+#endif
+                    l->opcode = ZEND_FETCH_RW;
+                    SET_TO_NOP(r);
+#ifndef ZEND_ENGINE_2_4
+                    STR_FREE(Z_STRVAL(OP1_CONST(rl)));
+                    /* TODO */
+#endif
+                    SET_TO_NOP(rl);
+                }
+            }
+        }
+
+        if (pass == 1) {
+            /* FETCH_W var,$x + ASSIGN $x,?,_  + FETCH_R var,$y =>
+               FETCH_W var,$x + ASSIGN $x,?,$y */
+            if (op->opcode == ZEND_UNSET_VAR ||
+                    op->opcode == ZEND_DO_FCALL ||
+                    op->opcode == ZEND_DO_FCALL_BY_NAME ||
+                    op->opcode == ZEND_POST_INC ||
+                    op->opcode == ZEND_POST_DEC ||
+                    op->opcode == ZEND_UNSET_DIM ||
+                    op->opcode == ZEND_UNSET_OBJ ||
+                    op->opcode == ZEND_INCLUDE_OR_EVAL ||
+                    op->opcode == ZEND_ASSIGN_DIM ||
+                    op->opcode == ZEND_ASSIGN_OBJ) {
+                zend_hash_clean(&assigns);
+                zend_hash_clean(&fetch_dim);
+            } else if (op->opcode == ZEND_ASSIGN_REF ||
+                       op->opcode == ZEND_ASSIGN ||
+                       op->opcode == ZEND_PRE_INC ||
+                       op->opcode == ZEND_PRE_DEC ||
+                       op->opcode == ZEND_ASSIGN_ADD ||
+                       op->opcode == ZEND_ASSIGN_SUB ||
+                       op->opcode == ZEND_ASSIGN_MUL ||
+                       op->opcode == ZEND_ASSIGN_DIV ||
+                       op->opcode == ZEND_ASSIGN_MOD ||
+                       op->opcode == ZEND_ASSIGN_SL ||
+                       op->opcode == ZEND_ASSIGN_SR ||
+                       op->opcode == ZEND_ASSIGN_CONCAT ||
+                       op->opcode == ZEND_ASSIGN_BW_OR ||
+                       op->opcode == ZEND_ASSIGN_BW_AND ||
+                       op->opcode == ZEND_ASSIGN_BW_XOR) {
+                zend_hash_clean(&assigns);
+                zend_hash_clean(&fetch_dim);
+                if ((RES_USED(op) & EXT_TYPE_UNUSED) != 0 &&
+                        OP1_TYPE(op) == IS_VAR &&
+                        op->extended_value != ZEND_ASSIGN_DIM &&
+                        op->extended_value != ZEND_ASSIGN_OBJ &&
+                        IS_DEFINED(op->op1)) {
+                    zend_op *x = DEFINED_OP(op->op1);
+                    if ((x->opcode == ZEND_FETCH_W || x->opcode == ZEND_FETCH_RW) &&
+                            OP1_TYPE(x) == IS_CONST && Z_TYPE(OP1_CONST(x)) == IS_STRING) {
+                        union {
+                            zend_op *v;
+                            void *ptr;
+                        } op_copy;
+                        zend_op *y = DEFINED_OP(x->op2);
+                        
+                        if (y){
+                            unsigned int use_classname = 0;
+                            unsigned int nKeyLength = Z_STRLEN(OP1_CONST(x)) + 2;
+                            char *s;
+
+                            if (y->opcode == ZEND_FETCH_CLASS &&
+                                OP2_TYPE(y) == IS_CONST && Z_TYPE(OP2_CONST(y)) == IS_STRING) {
+                                nKeyLength += Z_STRLEN(OP2_CONST(y));
+                                use_classname = 1;
+                            }
+                            s = emalloc(nKeyLength);
+                            op_copy.v = op;
+                            memcpy(s, Z_STRVAL(OP1_CONST(x)), Z_STRLEN(OP1_CONST(x)));
+                            s[Z_STRLEN(OP1_CONST(x))] = (char)FETCH_TYPE(x);
+                            if (y->opcode == ZEND_FETCH_CLASS && use_classname) {
+                                memcpy(&s[(Z_STRLEN(OP1_CONST(x)) + 1)], Z_STRVAL(OP2_CONST(y)), Z_STRLEN(OP2_CONST(y)));
+                            }
+                            s[nKeyLength - 1] = 0;
+                            zend_hash_update(&assigns, s, nKeyLength, &op_copy.ptr, sizeof(void*), NULL);
+                            efree(s);
+                        }
+                    }
+                }
+            /* Eliminate FETCH if the value has already been assigned earlier */
+            } else if ((op->opcode == ZEND_FETCH_R || op->opcode == ZEND_FETCH_IS) &&
+                       !global[VAR_NUM(RES_VARR(op))] && OP1_TYPE(op) == IS_CONST &&
+                       Z_TYPE(OP1_CONST(op)) == IS_STRING) {
+                union {
+                    zend_op *v;
+                    void *ptr;
+                } x;
+                zend_op *y = DEFINED_OP(op->op2);
+                if (y) {
+                    unsigned int use_classname = 0;
+                    unsigned int nKeyLength = Z_STRLEN(OP1_CONST(op)) + 2;
+                    char *s;
+
+                    if (y->opcode == ZEND_FETCH_CLASS &&
+                        OP2_TYPE(y) == IS_CONST && Z_TYPE(OP2_CONST(y)) == IS_STRING) {
+                        nKeyLength += Z_STRLEN(OP2_CONST(y));
+                        use_classname = 1;
+                    }
+                    s = emalloc(nKeyLength);
+                    memcpy(s, Z_STRVAL(OP1_CONST(op)), Z_STRLEN(OP1_CONST(op)));
+                    s[Z_STRLEN(OP1_CONST(op))] = (char)FETCH_TYPE(op);
+                    if (y->opcode == ZEND_FETCH_CLASS && use_classname) {
+                        memcpy(&s[(Z_STRLEN(OP1_CONST(op)) + 1)], Z_STRVAL(OP2_CONST(y)), Z_STRLEN(OP2_CONST(y)));
+                    }
+                    s[nKeyLength - 1] = 0;
+
+                    if (zend_hash_find(&assigns, s, nKeyLength, &x.ptr) == SUCCESS) {
+                        x.v = *(zend_op**)x.v;
+                        memcpy(&x.v->result, &op->result, sizeof(op->result));
+#ifdef ZEND_ENGINE_2_4
+                        x.v->result_type = op->result_type;
+#endif
+                        RES_USED(x.v) &= ~EXT_TYPE_UNUSED;
+                        SET_DEFINED(x.v);
+                        zend_hash_del(&assigns, s, nKeyLength);
+#ifndef ZEND_ENGINE_2_4
+                        STR_FREE(Z_STRVAL(OP1_CONST(op)));
+                        /* TODO */
+#endif
+                        SET_TO_NOP(op);
+                    }
+                    efree(s);
+                }
+            } else if (op->opcode == ZEND_FETCH_DIM_R &&
+                       op->extended_value != ZEND_FETCH_ADD_LOCK &&
+                       OP1_TYPE(op) == IS_VAR &&
+                       IS_DEFINED(op->op1)) {
+                zend_op *x = DEFINED_OP(op->op1);
+                while ((x->opcode == ZEND_ASSIGN_REF ||
+                        x->opcode == ZEND_ASSIGN ||
+                        x->opcode == ZEND_PRE_INC ||
+                        x->opcode == ZEND_PRE_DEC ||
+                        x->opcode == ZEND_ASSIGN_ADD ||
+                        x->opcode == ZEND_ASSIGN_SUB ||
+                        x->opcode == ZEND_ASSIGN_MUL ||
+                        x->opcode == ZEND_ASSIGN_DIV ||
+                        x->opcode == ZEND_ASSIGN_MOD ||
+                        x->opcode == ZEND_ASSIGN_SL ||
+                        x->opcode == ZEND_ASSIGN_SR ||
+                        x->opcode == ZEND_ASSIGN_CONCAT ||
+                        x->opcode == ZEND_ASSIGN_BW_OR ||
+                        x->opcode == ZEND_ASSIGN_BW_AND ||
+                        x->opcode == ZEND_ASSIGN_BW_XOR) &&
+                        OP1_TYPE(x) == IS_VAR &&
+                        IS_DEFINED(x->op1)) {
+                    x = DEFINED_OP(x->op1);
+                }
+                if ((x->opcode == ZEND_FETCH_R || x->opcode == ZEND_FETCH_W ||
+                        x->opcode == ZEND_FETCH_RW) && OP1_TYPE(x) == IS_CONST &&
+                        Z_TYPE(OP1_CONST(x)) == IS_STRING) {
+                    union {
+                        zend_op *v;
+                        void *ptr;
+                    } y;
+                    union {
+                        zend_op *v;
+                        void *ptr;
+                    } op_copy;
+                    char *s = emalloc(Z_STRLEN(OP1_CONST(x)) + 2);
+                    op_copy.v = op;
+                    memcpy(s, Z_STRVAL(OP1_CONST(x)), Z_STRLEN(OP1_CONST(x)));
+                    s[Z_STRLEN(OP1_CONST(x))] = (char)FETCH_TYPE(x);
+                    s[Z_STRLEN(OP1_CONST(x)) + 1] = 0;
+                    if (zend_hash_find(&fetch_dim, s, Z_STRLEN(OP1_CONST(x)) + 2,
+                                       &y.ptr) == SUCCESS) {
+                        y.v = *(zend_op**)y.v;
+                        y.v->extended_value = ZEND_FETCH_ADD_LOCK;
+                        zend_hash_update(&fetch_dim, s, Z_STRLEN(OP1_CONST(x)) + 2, &op_copy.ptr, sizeof(void*), NULL);
+                        SET_UNDEFINED(x->result);
+#ifndef ZEND_ENGINE_2_4
+                        STR_FREE(Z_STRVAL(OP1_CONST(x)));
+                        /* TODO */
+#endif
+                        SET_TO_NOP(x);
+                        memcpy(&op->op1, &y.v->op1, sizeof(op->op1));
+#ifdef ZEND_ENGINE_2_4
+                        op->op1_type = y.v->op1_type;
+#endif
+                    } else {
+                        zend_hash_update(&fetch_dim, s, Z_STRLEN(OP1_CONST(x)) + 2, &op_copy.ptr, sizeof(void*), NULL);
+                    }
+                    efree(s);
+                }
+            }
+        }
+
+        if (op->opcode != ZEND_NOP) {
+            prev = op;
+        }
+        if ((RES_TYPE(op) & IS_VAR &&
+                (op->opcode == ZEND_RECV || op->opcode == ZEND_RECV_INIT ||
+                 (RES_USED(op) & EXT_TYPE_UNUSED) == 0)) ||
+                (RES_TYPE(op) & IS_TMP_VAR)) {
+            if (op->opcode == ZEND_RECV ||
+                    op->opcode == ZEND_RECV_INIT) {
+                SET_UNDEFINED(op->result);
+            } else {
+                SET_DEFINED(op);
+            }
+        }
+        ++op;
     }
-    ++op;
-  }
 
-  /* NOP Removing */
-  op = bb->start;
-  end = op + bb->len;
-  while (op < end) {
-    if (op->opcode == ZEND_NOP) {
-      zend_op *next = op+1;
-      while (next < end && next->opcode == ZEND_NOP) next++;
-      if (next < end) {
-        memmove(op,next,(end-next) * sizeof(zend_op));
-        while (next > op) {
-          --end;
-          SET_TO_NOP(end);
-          --next;
-        }
-      } else {
-        end -= (next-op);
-      }
-    } else {
-      ++op;
+    /* NOP Removing */
+    op = bb->start;
+    end = op + bb->len;
+    while (op < end) {
+        if (op->opcode == ZEND_NOP) {
+            zend_op *next = op+1;
+            while (next < end && next->opcode == ZEND_NOP) {
+                next++;
+            }
+            if (next < end) {
+                memmove(op,next,(end-next) * sizeof(zend_op));
+                while (next > op) {
+                    --end;
+                    SET_TO_NOP(end);
+                    --next;
+                }
+            } else {
+                end -= (next-op);
+            }
+        } else {
+            ++op;
+        }
     }
-  }
-  bb->len = end - bb->start;
-  zend_hash_destroy(&fetch_dim);
-  zend_hash_destroy(&assigns);
+    bb->len = end - bb->start;
+    zend_hash_destroy(&fetch_dim);
+    zend_hash_destroy(&assigns);
 #ifdef ZEND_ENGINE_2_3
-  free_alloca(Ts, use_heap);
+    free_alloca(Ts, use_heap);
 #else
-  free_alloca(Ts);
+    free_alloca(Ts);
 #endif
 }
 
@@ -2592,335 +2844,294 @@
  */
 static int build_cfg(zend_op_array *op_array, BB* bb)
 {
-	zend_op* op = op_array->opcodes;
-	int len = op_array->last;
-	int line_num;
-	BB* p;
-	int remove_brk_cont_array = 1;
-
-    /* HOESH: Just to use later... */
-	zend_uint innermost_ketchup;
-
-	/* HOESH: Mark try & catch blocks */
-	if (op_array->last_try_catch > 0)
-	{
-		int i;
-		zend_try_catch_element* tc_element = op_array->try_catch_array;
-		for (i=0; i<op_array->last_try_catch; i++, tc_element++)
-		{
-			bb[tc_element->try_op].start = &op_array->opcodes[tc_element->try_op];
-			bb[tc_element->try_op].protect_merge = 1;
-
-			bb[tc_element->catch_op].start = &op_array->opcodes[tc_element->catch_op];
-			bb[tc_element->catch_op].protect_merge = 1;
-		}
-	}
-	
+    zend_op* op = op_array->opcodes;
+    int len = op_array->last;
+    int line_num;
+    BB* p;
+    zend_bool remove_brk_cont_array = 1;
+    zend_uint innermost_catch;
+
+    /* Mark try/catch blocks */
+    if (op_array->last_try_catch > 0) {
+        int i;
+        zend_try_catch_element* tc_element = op_array->try_catch_array;
+
+        for (i = 0; i < op_array->last_try_catch; i++, tc_element++) {
+            bb[tc_element->try_op].start = &op_array->opcodes[tc_element->try_op];
+            bb[tc_element->try_op].protect_merge = 1;
+
+            bb[tc_element->catch_op].start = &op_array->opcodes[tc_element->catch_op];
+            bb[tc_element->catch_op].protect_merge = 1;
+            
+            bb[tc_element->try_op].jmp_tc = &bb[tc_element->catch_op];
+        }
+    }
+
     /* Find Starts of Basic Blocks */
-	bb[0].start = op;
-	for (line_num=0; line_num < len; op++,line_num++)
-	{
-		const opcode_dsc* dsc = get_opcode_dsc(op->opcode);
-		if (dsc != NULL)
-		{
+    bb[0].start = op;
+    for (line_num = 0; line_num < len; op++,line_num++) {
+        const opcode_dsc* dsc = get_opcode_dsc(op->opcode);
+        if (dsc != NULL) {
 #ifndef ZEND_ENGINE_2_3
-			/* Does not work with PHP 5.3 due to namespaces */
-			if ((dsc->ops & OP1_MASK) == OP1_UCLASS)
-			{
-				if (op->op1.op_type != IS_UNUSED)
-				{
-					op->op1.op_type = IS_VAR;
-
-				}
-			}
-			else if ((dsc->ops & OP1_MASK) == OP1_CLASS)
-			{
-				op->op1.op_type = IS_VAR;
-			}
-			else
-#endif
-			if ((dsc->ops & OP1_MASK) == OP1_UNUSED)
-			{
-				op->op1.op_type = IS_UNUSED;
-			}
-			if ((dsc->ops & OP2_MASK) == OP2_CLASS)
-			{
-				op->op2.op_type = IS_VAR;
-			}
-			else if ((dsc->ops & OP2_MASK) == OP2_UNUSED)
-			{
-				op->op2.op_type = IS_UNUSED;
-			}
-			else if ((dsc->ops & OP2_MASK) == OP2_FETCH &&
-					op->op2.u.EA.type == ZEND_FETCH_STATIC_MEMBER)
-			{
-				op->op2.op_type = IS_VAR;
-			}
-			if ((dsc->ops & RES_MASK) == RES_CLASS)
-			{
-				op->result.op_type = IS_VAR;
-				op->result.u.EA.type &= ~EXT_TYPE_UNUSED;
-			}
-			else if ((dsc->ops & RES_MASK) == RES_UNUSED)
-			{
-				op->result.op_type = IS_UNUSED;
-			}
-		}
-		switch(op->opcode)
-		{
-			case ZEND_RETURN:
-			case ZEND_EXIT:
-				bb[line_num+1].start = op+1;
-				break;
+            /* Does not work with PHP 5.3 due to namespaces */
+            if ((dsc->ops & OP1_MASK) == OP1_UCLASS) {
+                if (OP1_TYPE(op) != IS_UNUSED) {
+                    OP1_TYPE(op) = IS_VAR;
+
+                }
+            } else if ((dsc->ops & OP1_MASK) == OP1_CLASS) {
+                OP1_TYPE(op) = IS_VAR;
+            } else
+#endif
+                if ((dsc->ops & OP1_MASK) == OP1_UNUSED) {
+                    OP1_TYPE(op) = IS_UNUSED;
+                }
+            if ((dsc->ops & OP2_MASK) == OP2_CLASS) {
+                OP2_TYPE(op) = IS_VAR;
+            } else if ((dsc->ops & OP2_MASK) == OP2_UNUSED) {
+                OP2_TYPE(op) = IS_UNUSED;
+            }
+#ifndef ZEND_ENGINE_2_4
+            else if ((dsc->ops & OP2_MASK) == OP2_FETCH &&
+                     FETCH_TYPE(op) == ZEND_FETCH_STATIC_MEMBER) {
+                OP2_TYPE(op) = IS_VAR;
+            }
+#else
+            else if ((dsc->ops & OP2_MASK) == OP2_FETCH &&
+                     FETCH_TYPE(op) == ZEND_FETCH_STATIC_MEMBER) {
+                OP2_TYPE(op) = IS_VAR;
+            }
+#endif
+
+            if ((dsc->ops & RES_MASK) == RES_CLASS) {
+                RES_TYPE(op) = IS_VAR;
+                RES_USED(op) &= ~EXT_TYPE_UNUSED;
+            } else if ((dsc->ops & RES_MASK) == RES_UNUSED) {
+                RES_TYPE(op) = IS_UNUSED;
+            }
+        }
+        switch(op->opcode) {
+        case ZEND_RETURN:
+#ifdef ZEND_ENGINE_2_4
+        case ZEND_RETURN_BY_REF:
+#endif
+        case ZEND_EXIT:
+            bb[line_num+1].start = op + 1;
+            break;
 #ifdef ZEND_GOTO
-            case ZEND_GOTO:
+        case ZEND_GOTO:
 #endif
-			case ZEND_JMP:
-				bb[op->op1.u.opline_num].start = &op_array->opcodes[op->op1.u.opline_num];
-				bb[line_num+1].start = op+1;
-				break;
-			case ZEND_JMPZNZ:
-				bb[op->extended_value].start = &op_array->opcodes[op->extended_value];
-				bb[op->op2.u.opline_num].start = &op_array->opcodes[op->op2.u.opline_num];
-				bb[line_num+1].start = op+1;
-				break;
-			case ZEND_JMPZ:
-			case ZEND_JMPNZ:
-			case ZEND_JMPZ_EX:
-			case ZEND_JMPNZ_EX:
+        case ZEND_JMP:
+            bb[OP1_OPLINE_NUM(op)].start = &op_array->opcodes[OP1_OPLINE_NUM(op)];
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_JMPZNZ:
+            bb[op->extended_value].start = &op_array->opcodes[op->extended_value];
+            bb[OP2_OPLINE_NUM(op)].start = &op_array->opcodes[OP2_OPLINE_NUM(op)];
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_JMPZ:
+        case ZEND_JMPNZ:
+        case ZEND_JMPZ_EX:
+        case ZEND_JMPNZ_EX:
 #ifdef ZEND_JMP_SET
-			case ZEND_JMP_SET:
+        case ZEND_JMP_SET:
 #endif
-			case ZEND_NEW:
-			case ZEND_FE_RESET:
-			case ZEND_FE_FETCH:
-				bb[line_num+1].start = op+1;
-				bb[op->op2.u.opline_num].start = &op_array->opcodes[op->op2.u.opline_num];
-				break;
-			case ZEND_BRK:
-				/* Replace BRK by JMP */
-				if (op->op1.u.opline_num == -1)
-				{
-				}
-				else if (op->op2.op_type == IS_CONST &&
-						op->op2.u.constant.type == IS_LONG)
-				{
-					int level  = op->op2.u.constant.value.lval;
-					zend_uint offset = op->op1.u.opline_num;
-					zend_brk_cont_element *jmp_to;
-					do
-					{
-						if (offset < 0 || offset >= op_array->last_brk_cont)
-						{
-							goto brk_failed;
-						}
-						jmp_to = &op_array->brk_cont_array[offset];
-						if (level>1 &&
-							(op_array->opcodes[jmp_to->brk].opcode == ZEND_SWITCH_FREE ||
-							op_array->opcodes[jmp_to->brk].opcode == ZEND_FREE))
-						{
-							goto brk_failed;
-						}
-						offset = jmp_to->parent;
-					}
-					while (--level > 0);
-					op->opcode = ZEND_JMP;
-					op->op1.u.opline_num = jmp_to->brk;
-					op->op2.op_type = IS_UNUSED;
-					op->extended_value = ZEND_BRK; /* Mark the opcode as former ZEND_BRK */
-					bb[op->op1.u.opline_num].start = &op_array->opcodes[jmp_to->brk];
-				}
-				else
-				{
+        case ZEND_NEW:
+        case ZEND_FE_RESET:
+        case ZEND_FE_FETCH:
+            bb[line_num + 1].start = op + 1;
+            bb[OP2_OPLINE_NUM(op)].start = &op_array->opcodes[OP2_OPLINE_NUM(op)];
+            break;
+        case ZEND_BRK:
+            /* Replace BRK by JMP */
+            if (OP1_OPLINE_NUM(op) == -1) {
+            }
+            else if (OP2_TYPE(op) == IS_CONST && Z_TYPE(OP2_CONST(op)) == IS_LONG) {
+                int level = Z_LVAL(OP2_CONST(op));
+                zend_uint offset = OP1_OPLINE_NUM(op);
+                zend_brk_cont_element *jmp_to;
+
+                do {
+                    if (offset == -1) {
+                        goto brk_failed;
+                    }
+                    jmp_to = &op_array->brk_cont_array[offset];
+                    offset = jmp_to->parent;
+                } while (--level > 0);
+
+                op->opcode = ZEND_JMP;
+                OP1_OPLINE_NUM(op) = jmp_to->brk;
+                OP2_TYPE(op) = IS_UNUSED;
+                op->extended_value = ZEND_BRK; /* Mark the opcode as former ZEND_BRK */
+                bb[OP1_OPLINE_NUM(op)].start = &op_array->opcodes[jmp_to->brk];
+            } else {
 brk_failed:
-				  remove_brk_cont_array = 0;
-				}
-				bb[line_num+1].start = op+1;
-				break;
-			case ZEND_CONT:
-				/* Replace CONT by JMP */
-				if (op->op1.u.opline_num == -1)
-				{
-				}
-				else if (op->op2.op_type == IS_CONST &&
-						op->op2.u.constant.type == IS_LONG)
-				{
-				int level  = op->op2.u.constant.value.lval;
-				zend_uint offset = op->op1.u.opline_num;
-				zend_brk_cont_element *jmp_to;
-				do
-				{
-					if (offset < 0 || offset >= op_array->last_brk_cont)
-					{
-						goto cont_failed;
-					}
-					jmp_to = &op_array->brk_cont_array[offset];
-					if (level>1 &&
-						(op_array->opcodes[jmp_to->brk].opcode == ZEND_SWITCH_FREE ||
-						op_array->opcodes[jmp_to->brk].opcode == ZEND_FREE))
-					{
-						goto cont_failed;
-					}
-					offset = jmp_to->parent;
-				}
-				while (--level > 0);
-				op->opcode = ZEND_JMP;
-				op->op1.u.opline_num = jmp_to->cont;
-				op->op2.op_type = IS_UNUSED;
-				op->extended_value = ZEND_CONT; /* Mark the opcode as former ZEND_CONT */
-				bb[op->op1.u.opline_num].start = &op_array->opcodes[jmp_to->cont];
-				}
-				else
-				{
+                remove_brk_cont_array = 0;
+            }
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_CONT:
+            /* Replace CONT by JMP */
+            if (OP1_OPLINE_NUM(op) == -1) {
+            }
+            else if (OP2_TYPE(op) == IS_CONST && Z_TYPE(OP2_CONST(op)) == IS_LONG) {
+                int level  = Z_LVAL(OP2_CONST(op));
+                zend_uint offset = OP1_OPLINE_NUM(op);
+                zend_brk_cont_element *jmp_to;
+
+                do {
+                    if (offset == -1) {
+                        goto cont_failed;
+                    }
+                    jmp_to = &op_array->brk_cont_array[offset];
+                    offset = jmp_to->parent;
+                } while (--level > 0);
+
+                op->opcode = ZEND_JMP;
+                OP1_OPLINE_NUM(op) = jmp_to->cont;
+                OP2_TYPE(op) = IS_UNUSED;
+                op->extended_value = ZEND_CONT; /* Mark the opcode as former ZEND_CONT */
+                bb[OP1_OPLINE_NUM(op)].start = &op_array->opcodes[jmp_to->cont];
+            } else {
 cont_failed:
-					remove_brk_cont_array = 0;
-				}
-				bb[line_num+1].start = op+1;
-				break;
-			case ZEND_CATCH:
-				bb[op->extended_value].start = &op_array->opcodes[op->extended_value];
-				bb[line_num+1].start = op+1;
-				break;
-			case ZEND_THROW:
-				if (op->op2.u.opline_num != -1)
-				{
-					bb[op->op2.u.opline_num].start = &op_array->opcodes[op->op2.u.opline_num];
-				}
-				bb[line_num+1].start = op+1;
-				break;
-			case ZEND_DO_FCALL:
-			case ZEND_DO_FCALL_BY_NAME:
-                                bb[line_num+1].start = op+1;
-				break;
-			case ZEND_UNSET_VAR:
-			case ZEND_UNSET_DIM:
-				op->result.op_type = IS_UNUSED;
-				break;
-			case ZEND_UNSET_OBJ:
-				op->result.op_type = IS_UNUSED;
-				break;
-			default:
-				break;
-		}
-	}
-
-	/* Find Lengths of Basic Blocks and build CFG */
-	p = bb;
-	for (line_num=1; line_num < len; line_num++)
-	{
-		/* Calculate innermost CATCH op */
-		innermost_ketchup = 0;
-		if (op_array->last_try_catch > 0)
-		{
-			int i;
-			zend_try_catch_element* tc_element = op_array->try_catch_array;
-			for (i=0; i<op_array->last_try_catch; i++, tc_element++)
-			{
-				// silence compile warnings. Line_num can't be negative here so casting is safe.
-				if (tc_element->try_op <= (zend_uint)line_num-1 &&
-					(zend_uint)line_num-1 < tc_element->catch_op &&
-						(innermost_ketchup == 0 ||
-						innermost_ketchup > tc_element->catch_op)
-					)
-				{
-					innermost_ketchup = tc_element->catch_op;
-				}
-			}
-		}
-		if (bb[line_num].start != NULL)
-		{
-			p->len  = bb[line_num].start - p->start;
-			p->next = &bb[line_num];
-			op = &p->start[p->len-1];
-			switch (op->opcode)
-			{
-				case ZEND_JMP:
-				    p->jmp_1 = &bb[op->op1.u.opline_num];
-					if (op->extended_value == ZEND_BRK || op->extended_value == ZEND_CONT)
-					{
-						/* This was a ZEND_BRK or ZEND_CONT opcode changed into a ZEND_JMP in an earlier stage.
-						   see comment above ZEND_BRK/ZEND_CONT below */
-						p->follow = (innermost_ketchup > 0) ? &bb[innermost_ketchup] : &bb[len-1];
-					}
+                remove_brk_cont_array = 0;
+            }
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_CATCH:
+            bb[op->extended_value].start = &op_array->opcodes[op->extended_value];
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_THROW:
+            if (OP2_OPLINE_NUM(op) != -1) {
+                bb[OP2_OPLINE_NUM(op)].start = &op_array->opcodes[OP2_OPLINE_NUM(op)];
+            }
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_DO_FCALL:
+        case ZEND_DO_FCALL_BY_NAME:
+            bb[line_num + 1].start = op + 1;
+            break;
+        case ZEND_UNSET_VAR:
+        case ZEND_UNSET_DIM:
+            RES_TYPE(op) = IS_UNUSED;
+            break;
+        case ZEND_UNSET_OBJ:
+            RES_TYPE(op) = IS_UNUSED;
+            break;
+        default:
+            break;
+        }
+    }
+
+    /* Find Lengths of Basic Blocks and build CFG */
+    p = bb;
+    for (line_num = 1; line_num < len; line_num++) {
+        /* Calculate innermost CATCH op */
+        innermost_catch = 0;
+        if (op_array->last_try_catch > 0) {
+            int i;
+            zend_try_catch_element* tc_element = op_array->try_catch_array;
+            for (i = 0; i < op_array->last_try_catch; i++, tc_element++) {
+                // silence compile warnings. Line_num can't be negative here so casting is safe.
+                if (tc_element->try_op <= (zend_uint)line_num - 1 &&
+                        (zend_uint)line_num - 1 < tc_element->catch_op &&
+                        (innermost_catch == 0 ||
+                         innermost_catch > tc_element->catch_op)
+                   ) {
+                    innermost_catch = tc_element->catch_op;
+                }
+            }
+        }
+        if (bb[line_num].start != NULL) {
+            p->len  = bb[line_num].start - p->start;
+            p->next = &bb[line_num];
+            op = &p->start[p->len - 1];
+            switch (op->opcode) {
+            case ZEND_JMP:
+                p->jmp_1 = &bb[OP1_OPLINE_NUM(op)];
 #  if (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 2 && PHP_RELEASE_VERSION >= 1) || PHP_MAJOR_VERSION >= 6
-					/* php >= 5.2.1 introduces a ZEND_JMP before a ZEND_FETCH_CLASS and ZEND_CATCH
-					   this leaves those blocks intact */
-					else if ((op+1)->opcode == ZEND_FETCH_CLASS && (op+2)->opcode == ZEND_CATCH) { /* fix for #242 */
-						p->follow = &bb[line_num];
-					}
+                /* php >= 5.2.1 introduces a ZEND_JMP before a ZEND_FETCH_CLASS and ZEND_CATCH
+                   this leaves those blocks intact */
+                if ((op + 1)->opcode == ZEND_FETCH_CLASS && (op + 2)->opcode == ZEND_CATCH) { /* fix for #242 */
+                    p->follow = &bb[line_num];
+                }
 #  endif
-					break;
-				case ZEND_JMPZNZ:
-					p->jmp_2 = &bb[op->op2.u.opline_num];
-					p->jmp_ext = &bb[op->extended_value];
-					break;
-				case ZEND_JMPZ:
-				case ZEND_JMPNZ:
-				case ZEND_JMPZ_EX:
-				case ZEND_JMPNZ_EX:
-				case ZEND_NEW:
-				case ZEND_FE_RESET:
-				case ZEND_FE_FETCH:
+                break;
+            case ZEND_JMPZNZ:
+                p->jmp_2 = &bb[OP2_OPLINE_NUM(op)];
+                p->jmp_ext = &bb[op->extended_value];
+                break;
+            case ZEND_JMPZ:
+            case ZEND_JMPNZ:
+            case ZEND_JMPZ_EX:
+            case ZEND_JMPNZ_EX:
+            case ZEND_NEW:
+            case ZEND_FE_RESET:
+            case ZEND_FE_FETCH:
 #ifdef ZEND_JMP_SET
-				case ZEND_JMP_SET:
+            case ZEND_JMP_SET:
 #endif
-					p->jmp_2 = &bb[op->op2.u.opline_num];
-					p->follow = &bb[line_num];
-					break;
+                p->jmp_2 = &bb[OP2_OPLINE_NUM(op)];
+                p->follow = &bb[line_num];
+                break;
 #ifdef ZEND_GOTO
-                case ZEND_GOTO:
-                    p->jmp_1 = &bb[op->op1.u.opline_num];
-                    p->follow = &bb[line_num];
-                    break;
+            case ZEND_GOTO:
+                p->jmp_1 = &bb[OP1_OPLINE_NUM(op)];
+                p->follow = &bb[line_num];
+                break;
 #endif
-				case ZEND_RETURN:
-				case ZEND_EXIT:
-				case ZEND_BRK:
-				case ZEND_CONT:
-					/* HOESH: The control might flow to the innermost CATCH
-					 * op if an exception thrown earlier. We can follow to CATCH
-					 * to protect it against unnecessary K.O. In that case,
-					 * the last RETURN will hold HANDLE_EXCEPTION.
-					 * If no CATCH op toward, then glue it to the last opcode,
-					 * that is HANDLE_EXCEPTION.
-					 */
-					p->follow = (innermost_ketchup > 0) ? &bb[innermost_ketchup] : &bb[len-1];
-					break;
-				case ZEND_DO_FCALL:
-				case ZEND_DO_FCALL_BY_NAME:
-					p->follow = &bb[line_num];
-					break;
-				case ZEND_CATCH:
-					p->jmp_ext = &bb[op->extended_value];
-					p->follow = &bb[line_num];
-					break;
-				case ZEND_THROW:
-					if (op->op2.u.opline_num != -1)
-					{
-						p->jmp_2 = &bb[op->op2.u.opline_num];
-					}
-					p->follow = &bb[line_num];
-					break;
-				default:
-					p->follow = &bb[line_num];
-			}
-			p = &bb[line_num];
-		}
-	}
-	p->len = (op_array->opcodes + op_array->last) - p->start;
-
-	/* Remove Unused brk_cont_array (BRK and CONT instructions replaced by JMP)
-	TODO: cannot be removed when ZEND_GOTO is used in oparray with php 5.3+
-	if (remove_brk_cont_array)
-	{
-		if (op_array->brk_cont_array != NULL)
-		{
-			efree(op_array->brk_cont_array);
-			op_array->brk_cont_array = NULL;
-		}
-		op_array->last_brk_cont = 0;
-	}*/
-	return remove_brk_cont_array;
+            case ZEND_RETURN:
+#ifdef ZEND_ENGINE_2_4
+            case ZEND_RETURN_BY_REF:
+#endif
+            case ZEND_EXIT:
+            case ZEND_BRK:
+            case ZEND_CONT:
+                /* HOESH: The control might flow to the innermost CATCH
+                 * op if an exception thrown earlier. We can follow to CATCH
+                 * to protect it against unnecessary K.O. In that case,
+                 * the last RETURN will hold HANDLE_EXCEPTION.
+                 * If no CATCH op toward, then glue it to the last opcode,
+                 * that is HANDLE_EXCEPTION.
+                 */
+                p->follow = (innermost_catch > 0) ? &bb[innermost_catch] : &bb[len - 1];
+                break;
+            case ZEND_DO_FCALL:
+            case ZEND_DO_FCALL_BY_NAME:
+                p->follow = &bb[line_num];
+                break;
+            case ZEND_CATCH:
+                p->jmp_ext = &bb[op->extended_value];
+                p->follow = &bb[line_num];
+                break;
+            case ZEND_THROW:
+                if (OP2_OPLINE_NUM(op) != -1) {
+                    p->jmp_2 = &bb[OP2_OPLINE_NUM(op)];
+                }
+                p->follow = &bb[line_num];
+                break;
+            default:
+                p->follow = &bb[line_num];
+            }
+            p = &bb[line_num];
+        }
+    }
+    p->len = (op_array->opcodes + op_array->last) - p->start;
+
+    /* Remove Unused brk_cont_array (BRK and CONT instructions replaced by JMP)
+    TODO: cannot be removed when ZEND_GOTO is used in oparray with php 5.3+
+    if (remove_brk_cont_array)
+    {
+    	if (op_array->brk_cont_array != NULL)
+    	{
+    		efree(op_array->brk_cont_array);
+    		op_array->brk_cont_array = NULL;
+    	}
+    	op_array->last_brk_cont = 0;
+    }*/
+    return remove_brk_cont_array;
 }
 
 /*
@@ -2928,112 +3139,107 @@
  */
 static void emit_cfg(zend_op_array *op_array, BB* bb)
 {
-  /* Compacting Optimized Code */
-  BB* p = bb;
-  zend_op* start = op_array->opcodes;
-  zend_op* op = start;
-  zend_op* end = op + op_array->last;
-  while (p != NULL)
-  {
-    if (p->used)
-	{
-      if (p->len > 0 && op != p->start)
-	  {
-        memmove(op, p->start, p->len * sizeof(zend_op));
-      }
-      p->start = op;
-      op += p->len;
+    /* Compacting Optimized Code */
+    BB* p = bb;
+    zend_op* start = op_array->opcodes;
+    zend_op* op = start;
+    zend_op* end = op + op_array->last;
+    while (p != NULL) {
+        if (p->used) {
+            if (p->len > 0 && op != p->start) {
+                memmove(op, p->start, p->len * sizeof(zend_op));
+            }
+            p->start = op;
+            op += p->len;
+        }
+        p = p->next;
+    }
+    op_array->last = op - start;
+#ifndef ZEND_ENGINE_2_4
+    op_array->start_op = NULL;
+#endif
+    while (op < end) {
+        SET_TO_NOP(op);
+        op++;
     }
-    p = p->next;
-  }
-  op_array->last = op - start;
-  op_array->start_op = NULL;
-  while (op < end)
-  {
-    SET_TO_NOP(op);
-    op++;
-  }
 
-  /* Set Branch Targets */
-  p = bb;
-  while (p != NULL) {
-    if (p->used && p->len > 0)
-	{
-      if (p->jmp_1 != NULL)
-	  {
-        p->start[p->len-1].op1.u.opline_num = p->jmp_1->start - start;
-      }
-      if (p->jmp_2 != NULL)
-	  {
-        p->start[p->len-1].op2.u.opline_num = p->jmp_2->start - start;
-      }
-      if (p->jmp_ext != NULL)
-	  {
-        p->start[p->len-1].extended_value = p->jmp_ext->start - start;
-      }
+    /* Set Branch Targets */
+    p = bb;
+    while (p != NULL) {
+        if (p->used && p->len > 0) {
+#ifdef ZEND_ENGINE_2_4
+            if (p->jmp_1 != NULL) {
+                p->start[p->len - 1].op1.opline_num = p->jmp_1->start - start;
+            }
+            if (p->jmp_2 != NULL) {
+                p->start[p->len - 1].op2.opline_num = p->jmp_2->start - start;
+            }
+#else
+            if (p->jmp_1 != NULL) {
+                p->start[p->len - 1].op1.u.opline_num = p->jmp_1->start - start;
+            }
+            if (p->jmp_2 != NULL) {
+                p->start[p->len - 1].op2.u.opline_num = p->jmp_2->start - start;
+            }
+#endif
+            if (p->jmp_ext != NULL) {
+                p->start[p->len - 1].extended_value = p->jmp_ext->start - start;
+            }
+        }
+        p = p->next;
     }
-    p = p->next;
-  }
 
-	/*
-	 * HOESH: Reassign try & catch blocks
-	 */
-	if (op_array->last_try_catch>0)
-	{
-		int i;
-		int last_try_catch = op_array->last_try_catch;
-		zend_try_catch_element* old_tc_element = op_array->try_catch_array;
-		for (i=0; i<op_array->last_try_catch; i++, old_tc_element++)
-		{
-			if (bb[old_tc_element->try_op].used &&
-				bb[old_tc_element->catch_op].used)
-			{
-				old_tc_element->try_op = bb[old_tc_element->try_op].start - start;
-				old_tc_element->catch_op = bb[old_tc_element->catch_op].start - start;
-			}
-			else
-			{
-				old_tc_element->try_op = 0;
-				old_tc_element->catch_op = 0;
-				last_try_catch--;
-			}
-		}
-		if (op_array->last_try_catch > last_try_catch)
-		{
-			zend_try_catch_element* new_tc_array = NULL;
-			if (last_try_catch > 0)
-			{
-				/* Lost some try & catch blocks */
-				zend_try_catch_element* new_tc_element = emalloc(sizeof(zend_try_catch_element)*last_try_catch);
-				new_tc_array = new_tc_element;
-				old_tc_element = op_array->try_catch_array;
-				for (i=0; i<op_array->last_try_catch; i++, old_tc_element++)
-				{
-					if (old_tc_element->try_op != old_tc_element->catch_op)
-					{
-						new_tc_element->try_op = old_tc_element->try_op;
-						new_tc_element->catch_op = old_tc_element->catch_op;
-						new_tc_element++;
-					}
-				}
-			}
-			/* Otherwise lost all try & catch blocks */
-			efree(op_array->try_catch_array);
-			op_array->try_catch_array = new_tc_array;
-			op_array->last_try_catch = last_try_catch;
-		}
-	}
+    /*
+     * HOESH: Reassign try & catch blocks
+     */
+    if (op_array->last_try_catch > 0) {
+        int i;
+        int last_try_catch = op_array->last_try_catch;
+        zend_try_catch_element* old_tc_element = op_array->try_catch_array;
+        for (i = 0; i < op_array->last_try_catch; i++, old_tc_element++) {
+            if (bb[old_tc_element->try_op].used &&
+                    bb[old_tc_element->catch_op].used) {
+                old_tc_element->try_op = bb[old_tc_element->try_op].start - start;
+                old_tc_element->catch_op = bb[old_tc_element->catch_op].start - start;
+            } else {
+                old_tc_element->try_op = 0;
+                old_tc_element->catch_op = 0;
+                last_try_catch--;
+            }
+        }
+        if (op_array->last_try_catch > last_try_catch) {
+            zend_try_catch_element* new_tc_array = NULL;
+            if (last_try_catch > 0) {
+                /* Lost some try & catch blocks */
+                zend_try_catch_element* new_tc_element = emalloc(sizeof(zend_try_catch_element)*last_try_catch);
+                new_tc_array = new_tc_element;
+                old_tc_element = op_array->try_catch_array;
+                for (i = 0; i < op_array->last_try_catch; i++, old_tc_element++) {
+                    if (old_tc_element->try_op != old_tc_element->catch_op) {
+                        new_tc_element->try_op = old_tc_element->try_op;
+                        new_tc_element->catch_op = old_tc_element->catch_op;
+                        new_tc_element++;
+                    }
+                }
+            }
+            /* Otherwise lost all try & catch blocks */
+            efree(op_array->try_catch_array);
+            op_array->try_catch_array = new_tc_array;
+            op_array->last_try_catch = last_try_catch;
+        }
+    }
 }
 
 #define GET_REG(R) {\
                      if (assigned[(R)] < 0) {\
                        zend_uint j = 0;\
                        while (j < op_array->T) {\
-                         if (reg_pool[j] == 0 &&\
-                             (global[(R)] == 0 || used[j] == 0)) {\
+                         if (reg_pool[j] == 0 && (global[(R)] == 0 || used[j] == 0)) {\
                            reg_pool[j] = 1;\
                            assigned[(R)] = j;\
-                           if (j+1 > n) {n = j+1;}\
+                           if (j + 1 > n) {\
+                             n = j + 1;\
+                           }\
                            break;\
                          }\
                          j++;\
@@ -3045,191 +3251,233 @@
 #define FREE_REG(R) reg_pool[(R)] = 0;
 
 
-void reassign_registers(zend_op_array *op_array, BB* p, char *global) {
-  zend_uint i;
-  zend_uint n = 0;
-
-#ifdef ZEND_ENGINE_2_3
-  int opline_num;
-  int first_class_delayed = -1;
-  int prev_class_delayed = -1;
-  int last_class_delayed_in_prev_bb = -1;
-  int last_class_delayed_in_this_bb = -1;
-
-  ALLOCA_FLAG(use_heap)
-  int* assigned  = do_alloca(op_array->T * sizeof(int), use_heap);
-  char* reg_pool = do_alloca(op_array->T * sizeof(char), use_heap);
-  char* used     = do_alloca(op_array->T * sizeof(char), use_heap);
-#else
-  int* assigned  = do_alloca(op_array->T * sizeof(int));
-  char* reg_pool = do_alloca(op_array->T * sizeof(char));
-  char* used     = do_alloca(op_array->T * sizeof(char));
-#endif
-
-  memset(assigned, -1, op_array->T * sizeof(int));
-  memset(reg_pool, 0, op_array->T * sizeof(char));
-  memset(used, 0, op_array->T * sizeof(char));
+void reassign_registers(zend_op_array *op_array, BB* p, char *global)
+{
+    zend_uint i;
+    zend_uint n = 0;
 
-  while (p != NULL) {
-    if (p->used && p->len > 0) {
-      zend_op* start = p->start;
-      zend_op* op    = start + p->len;
-      zend_op* op_data;
-
-      for (i = 0; i < op_array->T; i++) {
-        if (!global[i]) {
-          if (assigned[i] >= 0) {reg_pool[assigned[i]] = 0;}
-          assigned[i] = -1;
-        }
-      }
-
-      while (start < op) {
-        --op;
-        op_data = NULL;
-        if (op->opcode == ZEND_DO_FCALL_BY_NAME &&
-            op->op1.op_type == IS_CONST) {
-          zval_dtor(&op->op1.u.constant);
-          op->op1.op_type = IS_UNUSED;
-        }
-        if (op->op1.op_type == IS_VAR || op->op1.op_type == IS_TMP_VAR) {
-          int r = VAR_NUM(op->op1.u.var);
-          GET_REG(r);
-          if (op->opcode == ZEND_DO_FCALL_BY_NAME) {
-            op->op1.op_type = IS_UNUSED;
-          } else if (op->opcode == ZEND_FETCH_CONSTANT && op->op1.op_type == IS_VAR) {
-            op->op1.u.var = VAR_VAL(assigned[r]);
+#ifdef ZEND_ENGINE_2_3
+    int opline_num;
+    int first_class_delayed = -1;
+    int prev_class_delayed = -1;
+    int last_class_delayed_in_prev_bb = -1;
+    int last_class_delayed_in_this_bb = -1;
+
+    ALLOCA_FLAG(use_heap)
+    int* assigned  = do_alloca(op_array->T * sizeof(int), use_heap);
+    char* reg_pool = do_alloca(op_array->T * sizeof(char), use_heap);
+    char* used     = do_alloca(op_array->T * sizeof(char), use_heap);
+#else
+    int* assigned  = do_alloca(op_array->T * sizeof(int));
+    char* reg_pool = do_alloca(op_array->T * sizeof(char));
+    char* used     = do_alloca(op_array->T * sizeof(char));
+#endif
+
+    memset(assigned, -1, op_array->T * sizeof(int));
+    memset(reg_pool, 0, op_array->T * sizeof(char));
+    memset(used, 0, op_array->T * sizeof(char));
+
+    while (p != NULL) {
+        if (p->used && p->len > 0) {
+            zend_op* start = p->start;
+            zend_op* op    = start + p->len;
+
+            for (i = 0; i < op_array->T; i++) {
+                if (!global[i]) {
+                    if (assigned[i] >= 0) {
+                        reg_pool[assigned[i]] = 0;
+                    }
+                    assigned[i] = -1;
+                }
+            }
+
+            while (start < op) {
+                --op;
+                if (op->opcode == ZEND_DO_FCALL_BY_NAME && OP1_TYPE(op) == IS_CONST) {
+#ifndef ZEND_ENGINE_2_4
+                    zval_dtor(&op->op1.u.constant);
+#endif
+                    OP1_TYPE(op) = IS_UNUSED;
+                }
+                if (OP1_TYPE(op) == IS_VAR || OP1_TYPE(op) == IS_TMP_VAR) {
+                    int r = VAR_NUM(OP1_VARR(op));
+                    GET_REG(r);
+
+                    if (op->opcode == ZEND_DO_FCALL_BY_NAME) {
+                        OP1_TYPE(op) = IS_UNUSED;
+                    } else if (op->opcode == ZEND_FETCH_CONSTANT && OP1_TYPE(op) == IS_VAR) {
+                        OP1_VARR(op) = VAR_VAL(assigned[r]);
 #ifndef ZEND_ENGINE_2_3
-            /* restore op1 type from VAR to CONST (the opcode handler expects this or bombs out with invalid opcode)
-               FETCH_CONSTANT when fetching class constant screws up because of this with >=php-5.3 */
-            op->op1.op_type = IS_CONST;
-#endif
-          } else {
-            op->op1.u.var = VAR_VAL(assigned[r]);
-          }
-        }
-        if (op->op2.op_type == IS_VAR || op->op2.op_type == IS_TMP_VAR) {
-          int r = VAR_NUM(op->op2.u.var);
-          GET_REG(r);
-          op->op2.u.var = VAR_VAL(assigned[r]);
-        }
-#ifdef ZEND_ENGINE_2_3
-        if (op->opcode == ZEND_DECLARE_INHERITED_CLASS_DELAYED) {
-          int r = VAR_NUM(op->extended_value);
-          GET_REG(r);
-          op->extended_value = VAR_VAL(assigned[r]);
-
-          opline_num = op - op_array->opcodes;
-          /* store the very first occurence of ZEND_DECLARE_INHERITED_CLASS_DELAYED
-             we need this to restore op_array->early_binding later on */
-          if (first_class_delayed == -1)
-            first_class_delayed = opline_num;
-          if (last_class_delayed_in_this_bb == -1) {
-            last_class_delayed_in_this_bb = opline_num;
-          }
-
-          if (prev_class_delayed != -1) {
-            /* link current ZEND_DECLARE_INHERITED_CLASS_DELAYED to previous one */
-            op->result.u.opline_num = prev_class_delayed;
-          }
-          /* There might be another ZEND_DECLARE_INHERITED_CLASS_DELAYED down the road
-             (or actually up the road since were traversing the oparray backwards).
-             store current opline */
-          prev_class_delayed = opline_num;
-        }
-#endif
-        if (op->opcode == ZEND_DECLARE_INHERITED_CLASS) {
-
-          int r = VAR_NUM(op->extended_value);
-          GET_REG(r);
-          op->extended_value = VAR_VAL(assigned[r]);
-        }
-        if (op->result.op_type == IS_VAR ||
-            op->result.op_type == IS_TMP_VAR) {
-          int r = VAR_NUM(op->result.u.var);
-          GET_REG(r);
-          op->result.u.var = VAR_VAL(assigned[r]);
-          if (
-              (op->opcode != ZEND_RECV && op->opcode != ZEND_RECV_INIT &&
-              (op->result.u.EA.type & EXT_TYPE_UNUSED) != 0) ||
-              (!(op->op1.op_type == op->result.op_type && op->op1.u.var == op->result.u.var) &&
-              !(op->op2.op_type == op->result.op_type && op->op2.u.var == op->result.u.var) &&
-              !global[r] && op->opcode != ZEND_ADD_ARRAY_ELEMENT )
-             ) {
-                FREE_REG(VAR_NUM(op->result.u.var));
-          }
-        }
-      }
-    }
-#ifdef ZEND_ENGINE_2_3
-    if (last_class_delayed_in_prev_bb != -1 && last_class_delayed_in_this_bb != -1) {
-      op_array->opcodes[last_class_delayed_in_prev_bb].result.u.opline_num = prev_class_delayed;
-      last_class_delayed_in_prev_bb = -1;
-    }
-    if (last_class_delayed_in_this_bb != -1) {
-      last_class_delayed_in_prev_bb = last_class_delayed_in_this_bb;
-      last_class_delayed_in_this_bb = -1;
-    }
-    prev_class_delayed = -1;
+                        /* restore op1 type from VAR to CONST (the opcode handler expects this or bombs out with invalid opcode)
+                           FETCH_CONSTANT when fetching class constant screws up because of this with >=php-5.3 */
+                        OP1_TYPE(op) = IS_CONST;
+#endif
+                    } else {
+                        OP1_VARR(op) = VAR_VAL(assigned[r]);
+                    }
+                }
+                if (OP2_TYPE(op) == IS_VAR || OP2_TYPE(op) == IS_TMP_VAR) {
+                    int r = VAR_NUM(OP2_VARR(op));
+                    GET_REG(r);
+                    OP2_VARR(op) = VAR_VAL(assigned[r]);
+                }
+#ifdef ZEND_ENGINE_2_3
+                if (op->opcode == ZEND_DECLARE_INHERITED_CLASS_DELAYED) {
+                    int r = VAR_NUM(op->extended_value);
+                    GET_REG(r);
+                    op->extended_value = VAR_VAL(assigned[r]);
+
+                    opline_num = op - op_array->opcodes;
+                    /* store the very first occurence of ZEND_DECLARE_INHERITED_CLASS_DELAYED
+                       we need this to restore op_array->early_binding later on */
+                    if (first_class_delayed == -1) {
+                        first_class_delayed = opline_num;
+                    }
+                    if (last_class_delayed_in_this_bb == -1) {
+                        last_class_delayed_in_this_bb = opline_num;
+                    }
+
+                    if (prev_class_delayed != -1) {
+                        /* link current ZEND_DECLARE_INHERITED_CLASS_DELAYED to previous one */
+                        RES_OPLINE_NUM(op) = prev_class_delayed;
+                    }
+                    /* There might be another ZEND_DECLARE_INHERITED_CLASS_DELAYED down the road
+                       (or actually up the road since were traversing the oparray backwards).
+                       store current opline */
+                    prev_class_delayed = opline_num;
+                }
 #endif
-    
-    p = p->next;
-  }
-  op_array->T = n;
+                if (op->opcode == ZEND_DECLARE_INHERITED_CLASS) {
+
+                    int r = VAR_NUM(op->extended_value);
+                    GET_REG(r);
+                    op->extended_value = VAR_VAL(assigned[r]);
+                }
+                if (RES_TYPE(op) & IS_VAR || RES_TYPE(op) & IS_TMP_VAR) {
+                    int r = VAR_NUM(RES_VARR(op));
+                    GET_REG(r);
+                    RES_VARR(op) = VAR_VAL(assigned[r]);
+                    if (
+                        (op->opcode != ZEND_RECV && op->opcode != ZEND_RECV_INIT &&
+                         (RES_TYPE(op) & IS_VAR && RES_USED(op) & EXT_TYPE_UNUSED) != 0) ||
+                        (!(OP1_TYPE(op) == RES_TYPE(op) && OP1_VARR(op) == RES_VARR(op)) &&
+                         !(OP2_TYPE(op) == RES_TYPE(op) && OP2_VARR(op) == RES_VARR(op)) &&
+                         !global[r] && op->opcode != ZEND_ADD_ARRAY_ELEMENT )
+                    ) {
+                        FREE_REG(VAR_NUM(RES_VARR(op)));
+                    }
+                }
+            }
+        }
 #ifdef ZEND_ENGINE_2_3
-  /* link back op_array->early_binding to the first occurance of ZEND_DECLARE_INHERITED_CLASS_DELAYED */
-  if (first_class_delayed != -1)
-    op_array->early_binding = first_class_delayed;
-
-  free_alloca(used, use_heap);
-  free_alloca(reg_pool, use_heap);
-  free_alloca(assigned, use_heap);
-#else
-  free_alloca(used);
-  free_alloca(reg_pool);
-  free_alloca(assigned);
+        if (last_class_delayed_in_prev_bb != -1 && last_class_delayed_in_this_bb != -1) {
+#  ifdef ZEND_ENGINE_2_4
+            op_array->opcodes[last_class_delayed_in_prev_bb].result.opline_num = prev_class_delayed;
+#  else
+            op_array->opcodes[last_class_delayed_in_prev_bb].result.u.opline_num = prev_class_delayed;
+#  endif
+            last_class_delayed_in_prev_bb = -1;
+        }
+        if (last_class_delayed_in_this_bb != -1) {
+            last_class_delayed_in_prev_bb = last_class_delayed_in_this_bb;
+            last_class_delayed_in_this_bb = -1;
+        }
+        prev_class_delayed = -1;
+#endif
+
+        p = p->next;
+    }
+    op_array->T = n;
+#ifdef ZEND_ENGINE_2_3
+    /* link back op_array->early_binding to the first occurance of ZEND_DECLARE_INHERITED_CLASS_DELAYED */
+    if (first_class_delayed != -1) {
+        op_array->early_binding = first_class_delayed;
+    }
+
+    free_alloca(used, use_heap);
+    free_alloca(reg_pool, use_heap);
+    free_alloca(assigned, use_heap);
+#else
+    free_alloca(used);
+    free_alloca(reg_pool);
+    free_alloca(assigned);
 #endif
 }
 
-void restore_operand_types(zend_op_array *op_array) {
-	zend_op* op = op_array->opcodes;
-	int len = op_array->last;
-	int line_num;
-
-	for (line_num=0; line_num < len; op++,line_num++)
-	{
-          if (op->opcode == ZEND_FETCH_CONSTANT && op->op1.op_type == IS_VAR) {
+void restore_operand_types(zend_op_array *op_array)
+{
+    zend_op* op = op_array->opcodes;
+    int len = op_array->last;
+    int line_num;
+
+    for (line_num=0; line_num < len; op++,line_num++) {
+        if (op->opcode == ZEND_FETCH_CONSTANT && OP1_TYPE(op) == IS_VAR) {
             /* restore op1 type from VAR to CONST (the opcode handler expects this or bombs out with invalid opcode) */
-            op->op1.op_type = IS_CONST;
-	  }
-	}
+            OP1_TYPE(op) = IS_CONST;
+        }
+    }
 }
 
 #ifdef ZEND_ENGINE_2_3
 /*
- * Convert jmp_addrs back to opline_nums
+ * opt_undo_pass_two: Convert jmp_addrs back to opline_nums,
+ *                    convert literal pointers back to literals array indices
  */
-void restore_opline_num(zend_op_array *op_array)
+int opt_undo_pass_two(zend_op_array *op_array)
 {
     zend_op *opline, *end;
+
+    /* if pass_two() hasn't run yet, all opline nums and constant indexes are fine */
+#ifdef ZEND_ENGINE_2_4
+    if (!(op_array->fn_flags & ZEND_ACC_DONE_PASS_TWO)) {
+#else
+    if (!op_array->done_pass_two) {
+#endif
+        return 0;
+    }
+
     opline = op_array->opcodes;
     end = opline + op_array->last;
-    
+
     while (opline < end) {
-        switch (opline->opcode){
-            case ZEND_GOTO:
-            case ZEND_JMP:
-                opline->op1.u.opline_num = opline->op1.u.jmp_addr - op_array->opcodes;
-                break;
-            case ZEND_JMPZ:
-            case ZEND_JMPNZ:
-            case ZEND_JMPZ_EX:
-            case ZEND_JMPNZ_EX:
-            case ZEND_JMP_SET:
-                opline->op2.u.opline_num = opline->op2.u.jmp_addr - op_array->opcodes;
-                break;
+#ifdef ZEND_ENGINE_2_4
+        /* restore literal pointers back to literals array indices */
+        if (OP1_TYPE(opline) == IS_CONST) {
+            opline->op1.constant = opline->op1.literal - op_array->literals;
+        }
+        if (OP2_TYPE(opline) == IS_CONST) {
+            opline->op2.constant = opline->op2.literal - op_array->literals;
+        }
+#endif
+
+        switch (opline->opcode) {
+#ifdef ZEND_ENGINE_2_3
+        case ZEND_GOTO:
+#endif
+        case ZEND_JMP:
+            OP1_OPLINE_NUM(opline) = OP1_JMP_ADDR(opline) - op_array->opcodes;
+            break;
+        case ZEND_JMPZ:
+        case ZEND_JMPNZ:
+        case ZEND_JMPZ_EX:
+        case ZEND_JMPNZ_EX:
+#ifdef ZEND_ENGINE_2_3
+        case ZEND_JMP_SET:
+#endif
+            OP2_OPLINE_NUM(opline) = OP2_JMP_ADDR(opline) - op_array->opcodes;
+            break;
         }
         opline++;
     }
+
+    /* reset the pass_two flag */
+#ifdef ZEND_ENGINE_2_4
+    op_array->fn_flags &= ~ZEND_ACC_DONE_PASS_TWO;
+#else
+    op_array->done_pass_two = 0;
+#endif
+
+    return 0;
 }
 #endif
 
@@ -3238,125 +3486,139 @@
  */
 void eaccelerator_optimize(zend_op_array *op_array)
 {
-  BB* p;
-  int i;
-  BB* bb;
-  zend_uint orig_compiler_options;
+    BB* p;
+    int i;
+    BB* bb;
+    zend_uint orig_compiler_options;
 
 #ifdef ZEND_ENGINE_2_3
-  ALLOCA_FLAG(use_heap)
+    ALLOCA_FLAG(use_heap)
 #endif
 
-  TSRMLS_FETCH();
-  if (!EAG(compiler) || op_array->type != ZEND_USER_FUNCTION) {
-    return;
-  }
+    TSRMLS_FETCH();
+    if (!EAG(compiler) || op_array->type != ZEND_USER_FUNCTION) {
+        return;
+    }
 
 #ifdef ZEND_ENGINE_2_3
-  /* We run pass_two() here to let the Zend engine resolve ZEND_GOTO labels
-     this converts goto labels(string) to opline numbers(long)
-     we need opline numbers for CFG generation, otherwise the optimizer will
-     drop code blocks because it thinks they are unused.
-     
-     We set compiler options to 0 to prevent pass_two from running the
-     op array handler (the optimizer in our case) in an endless loop */
-  orig_compiler_options = CG(compiler_options);
-  CG(compiler_options) = 0;
-  pass_two(op_array TSRMLS_CC);
-  CG(compiler_options) = orig_compiler_options;
-  
-  /* Convert jmp_addrs generated by pass_two() back to opline_nums */
-  restore_opline_num(op_array);
-#endif
-  
-  /* Allocate memory for CFG */
+    /* We run pass_two() here to let the Zend engine resolve ZEND_GOTO labels
+       this converts goto labels(string) to opline numbers(long)
+       we need opline numbers for CFG generation, otherwise the optimizer will
+       drop code blocks because it thinks they are unused.
+
+       We set compiler options to 0 to prevent pass_two from running the
+       op array handler (the optimizer in our case) in an endless loop */
+
+    orig_compiler_options = CG(compiler_options);
+    CG(compiler_options) = 0;
+    pass_two(op_array TSRMLS_CC);
+    CG(compiler_options) = orig_compiler_options;
+
+    /* Convert jmp_addr pointers generated by pass_two() back to opline_nums
+       > PHP-5.4.x also converts literal pointers back to literals array indices */
+    opt_undo_pass_two(op_array);
+#endif
+
+    /* Allocate memory for CFG */
 #ifdef ZEND_ENGINE_2_3
-  bb = do_alloca(sizeof(BB)*(op_array->last+1), use_heap);
+    bb = do_alloca(sizeof(BB)*(op_array->last + 1), use_heap);
 #else
-  bb = do_alloca(sizeof(BB)*(op_array->last+1));
+    bb = do_alloca(sizeof(BB)*(op_array->last + 1));
 #endif
-  if (bb == NULL) {
-      return;
-  }
-  memset(bb, 0, sizeof(BB)*(op_array->last+1));
+    if (bb == NULL) {
+        return;
+    }
+    memset(bb, 0, sizeof(BB)*(op_array->last + 1));
 
-  /* Find All Basic Blocks and build CFG */
-  if (build_cfg(op_array, bb)) {
+    /* Find All Basic Blocks and build CFG */
+    if (build_cfg(op_array, bb)) {
 #ifdef ZEND_ENGINE_2_3
-    char *global = do_alloca(op_array->T * sizeof(char), use_heap);
+        char *global = do_alloca(op_array->T * sizeof(char), use_heap);
 #else
-    char *global = do_alloca(op_array->T * sizeof(char));
+        char *global = do_alloca(op_array->T * sizeof(char));
 #endif
-    if (global == NULL) return;
-
-    for (i=0; i<2; i++) {
-      /* Determine used blocks and its predecessors */
-      mark_used_bb(bb);
-
-      /* JMP Optimization */
-      optimize_jmp(bb, op_array);
-      compute_live_var(bb, op_array, global);
+        if (global == NULL) {
+            return;
+        }
+        /* TODO free bb here */
 
-      /* Optimize Each Basic Block */
-      p = bb;
-      while (p != NULL) {
-        optimize_bb(p, op_array, global, i TSRMLS_CC);
-        p = p->next;
-      }
+        for (i = 0; i < 2; i++) {
+            /* Determine used blocks and its predecessors */
+            mark_used_bb(bb);
+
+            /* JMP Optimization */
+            optimize_jmp(bb, op_array);
+            compute_live_var(bb, op_array, global);
+
+            /* Optimize Each Basic Block */
+            p = bb;
+            while (p != NULL) {
+                optimize_bb(p, op_array, global, i TSRMLS_CC);
+                p = p->next;
+            }
 
-      /* Mark All Basic Blocks as Unused. Free Predecessors Links. */
-      p = bb;
-      while (p != NULL) {
-        rm_bb(p);
-        p = p->next;
-      }
-    }
+            /* Mark All Basic Blocks as Unused. Free Predecessors Links. */
+            p = bb;
+            while (p != NULL) {
+                rm_bb(p);
+                p = p->next;
+            }
+        }
 
-    /* Mark Used Blocks */
-    mark_used_bb2(bb);
+        /* Mark Used Blocks */
+        mark_used_bb2(bb);
 
-    /* Remove Unused Basic Blocks */
-    p = bb;
-    while (p->next != NULL) {
-      if (p->next->used) {
-        p = p->next;
-      } else {
-        del_bb(p->next);
-        p->next = p->next->next;
-      }
-    }
+        /* Remove Unused Basic Blocks */
+        p = bb;
+        while (p->next != NULL) {
+            if (p->next->used) {
+                p = p->next;
+            } else {
+                del_bb(p->next);
+                p->next = p->next->next;
+            }
+        }
 
-    /* Store Optimized Code */
-    emit_cfg(op_array, bb);
-    reassign_registers(op_array, bb, global);
-    /* dump_bb(bb, op_array); */
+        /* Store Optimized Code */
+        emit_cfg(op_array, bb);
+        reassign_registers(op_array, bb, global);
+//    dump_bb(bb, op_array);
 
 #ifdef ZEND_ENGINE_2_3
-    free_alloca(global, use_heap);
+        free_alloca(global, use_heap);
 #else
-    free_alloca(global);
+        free_alloca(global);
 #endif
-  }
-  else {
-    /* build_cfg encountered some nested ZEND_BRK or ZEND_CONT's
-       which it could not replace with JMP's
-
-       now restore the operand type changes that build_cfg had
-       already applied, to prevent 'invalid opcode' errors
-       on opcode handlers that expect a strict set of operand
-       types since php-5.1 (like ZEND_FETCH_CONSTANT)
-    */
+    } else {
+        /* build_cfg encountered some nested ZEND_BRK or ZEND_CONT's
+           which it could not replace with JMP's
+
+           now restore the operand type changes that build_cfg had
+           already applied, to prevent 'invalid opcode' errors
+           on opcode handlers that expect a strict set of operand
+           types since php-5.1 (like ZEND_FETCH_CONSTANT)
+        */
 #ifndef ZEND_ENGINE_2_3
-    /* FETCH_CONSTANT when fetching class constant screws up
-       because of this with >=php-5.3 */
-    restore_operand_types(op_array);
+        /* FETCH_CONSTANT when fetching class constant screws up
+           because of this with >=php-5.3 */
+        restore_operand_types(op_array);
 #endif
-  }
+    }
 #ifdef ZEND_ENGINE_2_3
     free_alloca(bb, use_heap);
 #else
     free_alloca(bb);
 #endif
 }
-#endif
+
+#endif /* #ifdef WITH_EACCELERATOR_OPTIMIZER */
 #endif /* #ifdef HAVE_EACCELERATOR */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: et sw=4 ts=4 fdm=marker
+ * vim<600: et sw=4 ts=4
+ */
diff -Naur orig/README patched/README
--- orig/README	2010-02-18 16:00:43.000000000 +0100
+++ patched/README	2012-08-16 15:34:36.000000000 +0200
@@ -25,8 +25,8 @@
 with  Zend  Encoder  we  do  not  recommend  to  install  Zend  Optimizer with 
 eAccelerator.
 
-eAccelerator does not work in CGI mode but it does work in Fast-CGI mode with
-webservers like lighttpd.
+eAccelerator does not work in CGI mode but it does work in FastCGI mode with
+webservers like lighttpd or using php-fpm.
 
 
 Download
@@ -46,7 +46,7 @@
 -------------
 eAccelerator works with php version 5.1 and higher.
 It is being used on Linux, FreeBSD, Mac OS X, Solaris and Windows 
-with Apache 1.3 and 2, lighttpd and IIS.
+with Apache 1.3 and 2, lighttpd, php-fpm and IIS.
 
 
 Quick install
@@ -64,7 +64,7 @@
   $PHP_PREFIX/bin/phpize
   
   ./configure \
-  --enable-eaccelerator=shared \
+  --enable-shared \
   --with-php-config=$PHP_PREFIX/bin/php-config
   
   make
@@ -94,7 +94,6 @@
   eaccelerator.check_mtime="1"
   eaccelerator.debug="0"
   eaccelerator.filter=""
-  eaccelerator.shm_max="0"
   eaccelerator.shm_ttl="0"
   eaccelerator.shm_prune_period="0"
   eaccelerator.shm_only="0"
@@ -112,7 +111,6 @@
   eaccelerator.check_mtime="1"
   eaccelerator.debug="0"
   eaccelerator.filter=""
-  eaccelerator.shm_max="0"
   eaccelerator.shm_ttl="0"
   eaccelerator.shm_prune_period="0"
   eaccelerator.shm_only="0"
@@ -161,11 +159,6 @@
     which are matched by the following pattern. Default value is "" that means 
     all PHP scripts will be cached.
 
-eaccelerator.shm_max
-    Disables putting large values into shared memory by " eaccelerator_put() "
-    function. It indicates the largest allowed size in bytes (10240, 10K, 1M). 
-    The "0" disables the limit. Default value is "0".
-
 eaccelerator.shm_ttl
     When eaccelerator fails to get shared memory for new script it removes all
     scripts which were not accessed  at  last "shm_ttl"  seconds  from  shared
@@ -207,12 +200,7 @@
 You can set the username and password needed to access the disassembler at the
 top of dasm.php.
 
-eAccelerator API
-----------------
-
-API documentation can be found on this website: http://bart.eaccelerator.net/doc/phpdoc/
-
 Contact us
 ----------
-You can contact us with questions, patches or bugs, by sending an email to
-Bart Vanbrabant <bart at vanbrabant.eu>
+You can contact us with questions, patches or bugs on GitHub
+https://github.com/eaccelerator/eaccelerator
